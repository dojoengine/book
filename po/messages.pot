
msgid ""
msgstr ""
"Project-Id-Version: Dojo: The Provable Game Engine\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr ""

#: src/SUMMARY.md:4
#: src/theory/what-is-dojo.md:1
msgid "What is Dojo?"
msgstr ""

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr ""

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr ""

#: src/SUMMARY.md:7
#: src/theory/faqs.md:1
msgid "FAQs"
msgstr ""

#: src/SUMMARY.md:9
#: src/client/npm/core.md:10
#: src/misc/contributors.md:12
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:11
#: src/getting-started/quick-start.md:1
msgid "Quick Start"
msgstr ""

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr ""

#: src/SUMMARY.md:13
#: src/getting-started/setup.md:1
msgid "Development Setup"
msgstr ""

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr ""

#: src/SUMMARY.md:16
msgid "Community"
msgstr ""

#: src/SUMMARY.md:18
#: src/community/get-started.md:1
msgid "Get Started"
msgstr ""

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr ""

#: src/SUMMARY.md:22
#: src/cairo/hello-dojo.md:1
msgid "Hello Dojo"
msgstr ""

#: src/SUMMARY.md:23
#: src/cairo/config.md:1
msgid "Config"
msgstr ""

#: src/SUMMARY.md:24
msgid "World"
msgstr ""

#: src/SUMMARY.md:25
#: src/cairo/components.md:1
msgid "Components"
msgstr ""

#: src/SUMMARY.md:26
#: src/cairo/systems.md:1
msgid "Systems"
msgstr ""

#: src/SUMMARY.md:27
#: src/cairo/entities.md:1
msgid "Entities"
msgstr ""

#: src/SUMMARY.md:28
#: src/cairo/authorization.md:1
msgid "Authorization"
msgstr ""

#: src/SUMMARY.md:29
#: src/cairo/commands.md:1
msgid "Commands"
msgstr ""

#: src/SUMMARY.md:30
#: src/cairo/events.md:1
msgid "Events"
msgstr ""

#: src/SUMMARY.md:31
#: src/cairo/testing.md:1
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:32
#: src/cairo/modules.md:1
msgid "Dojo Modules"
msgstr ""

#: src/SUMMARY.md:33
#: src/cairo/modules/erc20.md:1
msgid "ERC20"
msgstr ""

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr ""

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr ""

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr ""

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr ""

#: src/SUMMARY.md:40
#: src/client/overview.md:1
msgid "Overview"
msgstr ""

#: src/SUMMARY.md:41
msgid "JS"
msgstr ""

#: src/SUMMARY.md:42
msgid "Core"
msgstr ""

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr ""

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr ""

#: src/SUMMARY.md:47
#: src/toolchain/sozo/overview.md:1
msgid "Sozo"
msgstr ""

#: src/SUMMARY.md:48
#: src/SUMMARY.md:60
#: src/SUMMARY.md:62
msgid "Reference"
msgstr ""

#: src/SUMMARY.md:49
msgid "init"
msgstr ""

#: src/SUMMARY.md:50
msgid "build"
msgstr ""

#: src/SUMMARY.md:51
msgid "test"
msgstr ""

#: src/SUMMARY.md:52
msgid "migrate"
msgstr ""

#: src/SUMMARY.md:53
msgid "execute"
msgstr ""

#: src/SUMMARY.md:54
msgid "register"
msgstr ""

#: src/SUMMARY.md:55
msgid "system"
msgstr ""

#: src/SUMMARY.md:56
msgid "component"
msgstr ""

#: src/SUMMARY.md:57
msgid "events"
msgstr ""

#: src/SUMMARY.md:58
msgid "auth"
msgstr ""

#: src/SUMMARY.md:59
#: src/toolchain/katana/overview.md:1
msgid "Katana"
msgstr ""

#: src/SUMMARY.md:61
msgid "Torii"
msgstr ""

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr ""

#: src/SUMMARY.md:66
msgid "Locally"
msgstr ""

#: src/SUMMARY.md:67
msgid "Remote"
msgstr ""

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr ""

#: src/SUMMARY.md:72
#: src/tutorial/onchain-chess/0-setup.md:1
msgid "0. Setup"
msgstr ""

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr ""

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr ""

#: src/SUMMARY.md:75
#: src/tutorial/onchain-chess/3-legal.md:1
msgid "3. Check Legal Move"
msgstr ""

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr ""

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr ""

#: src/index.md:1
msgid "![Dojo](images/dojo-mark-full-dark.svg)"
msgstr ""

#: src/index.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""

#: src/index.md:7
msgid "Dojo: The Provable Game Engine"
msgstr ""

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the "
"[Theory](./theory/autonomous-worlds.md) elucidates this emergent concept of "
"autonomous worlds and Provable games."
msgstr ""

#: src/index.md:13
msgid "[Quickstart](./getting-started/quick-start.md)"
msgstr ""

#: src/index.md:14
msgid "[What is Dojo? ](./theory/what-is-dojo.md)"
msgstr ""

#: src/index.md:15
msgid "[Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""

#: src/index.md:18
msgid "Explainer"
msgstr ""

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s "
"[Tarrence](https://twitter.com/tarrenceva) explaining how Dojo works at the "
"2023 [Autonomous Anonymous "
"Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""

#: src/index.md:30
msgid "Organizational Structure"
msgstr ""

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & "
"BibliothecaDAO](https://bibliothecadao.xyz/), "
"[briq](https://briq.construction/) and many more "
"[contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""

#: src/index.md:33
msgid "How do I get involved?"
msgstr ""

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our "
"[Twitter](https://twitter.com/dojostarknet), "
"[Discord](https://discord.gg/vUN4Xq9Qv6) and [contribution "
"guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building "
"[on-chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""

#: src/theory/what-is-dojo.md:9
msgid "Stop building infrastructure; start building games"
msgstr ""

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building "
"on-chain games. It includes:"
msgstr ""

#: src/theory/what-is-dojo.md:13
msgid "Entity Component System (ECS)"
msgstr ""

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr ""

#: src/theory/what-is-dojo.md:21
msgid "[Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr ""

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build "
"on-chain games. It also eliminates the need to manually create indexers, "
"which can be a tedious and error-prone process."
msgstr ""

#: src/theory/what-is-dojo.md:27
msgid "[Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr ""

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""

#: src/theory/what-is-dojo.md:31
msgid "[Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr ""

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""

#: src/theory/what-is-dojo.md:35
msgid "What Dojo doesn't give you"
msgstr ""

#: src/theory/what-is-dojo.md:37
msgid ""
"Visual graphics - While Dojo provides networking and contracts, it doesn't "
"offer graphical engines. You can bring your graphics of choice! Integrate "
"your Dojo world with Unreal, Godot, or Unity."
msgstr ""

#: src/theory/what-is-dojo.md:39
msgid "Understanding the Dojo Workflow: A Visual Guide"
msgstr ""

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""

#: src/theory/what-is-dojo.md:45
msgid "![Dojo Sozo Workflow](../images/dojo-sozo-workflow.jpg)"
msgstr ""

#: src/theory/autonomous-worlds.md:1
msgid "Autonomous Worlds"
msgstr ""

#: src/theory/autonomous-worlds.md:3
msgid ""
"\"Autonomous worlds represent persistent, permissionless, and decentralized "
"open environments that users can freely interact with and contribute to.\""
msgstr ""

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""

#: src/theory/autonomous-worlds.md:9
msgid ""
"Decentralized data availability layer: While the state execution may reside "
"on a centralized layer, it is crucial that the state can be reconstructed if "
"the execution layer ceases to exist. Rollups offer a solution, providing "
"increased capacity execution layers while ensuring data is permanently "
"settled on Ethereum. This guarantees the world's perpetual persistence."
msgstr ""

#: src/theory/autonomous-worlds.md:11
msgid ""
"Permissionless entry point for expanding the world: The World contract must "
"be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""

#: src/theory/autonomous-worlds.md:15
msgid "Homework"
msgstr ""

#: src/theory/autonomous-worlds.md:16
msgid ""
"[Wired - Autonomous Worlds "
"Primer](https://www.wired.com/story/autonomous-worlds-aim-to-free-online-games-from-corporate-control/)"
msgstr ""

#: src/theory/autonomous-worlds.md:17
msgid ""
"[0xParc - Autonomous Worlds (Part "
"1)](https://0xparc.org/blog/autonomous-worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:18
msgid ""
"[Gubsheep - The Strongest Crypto Gaming "
"Thesis](https://gubsheep.substack.com/p/the-strongest-crypto-gaming-thesis)"
msgstr ""

#: src/theory/autonomous-worlds.md:19
msgid ""
"[Lattice - MUD: An engine for Autonomous "
"Worlds](https://lattice.xyz/blog/mud-an-engine-for-autonomous-worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:20
msgid "[Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)"
msgstr ""

#: src/theory/autonomous-worlds.md:21
msgid ""
"[Guiltygyoza - Composable "
"Engineering](https://www.guiltygyoza.xyz/2023/05/composable-engineering)"
msgstr ""

#: src/theory/autonomous-worlds.md:22
msgid ""
"[Jay Springett - Wind-up "
"Worlds](https://www.thejaymo.net/2022/05/06/wind-up-worlds/)"
msgstr ""

#: src/theory/autonomous-worlds.md:23
msgid ""
"[Are.na collection on Autonomous "
"Worlds](https://www.are.na/sylve-chevet/on-chain-realities-and-autonomous-worlds)"
msgstr ""

#: src/theory/cairo.md:1
msgid "Provable games"
msgstr ""

#: src/theory/cairo.md:3
msgid ""
"Provable games demand "
"[zero-knowledge](https://ethereum.org/en/zero-knowledge-proofs/) properties "
"for efficient scaling and verification of computations. "
"[Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) addresses "
"this need by providing a generalized language, eliminating the complexity of "
"creating circuits to incorporate "
"[SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr ""

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual "
"Machine](https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) "
"(CVM), which is compatible with Starknet's Layer 2, Starknet appchains, and "
"even in-browser through WebAssembly (WASM)! Dojo aims to supply "
"straightforward ZK primitives to fuel your game development."
msgstr ""

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""

#: src/theory/cairo.md:11
#: src/getting-started/setup.md:8
msgid "Cairo"
msgstr ""

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of "
"[commands](../cairo/commands.md). Commands are a design pattern that helps "
"to reduce boilerplate code, resulting in cleaner and more maintainable "
"applications. They achieve this by encapsulating specific actions or "
"operations within self-contained, reusable units."
msgstr ""

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""

#: src/theory/cairo.md:21
msgid "Essential Reading"
msgstr ""

#: src/theory/cairo.md:22
msgid "[Cairo book](https://cairo-book.github.io/)"
msgstr ""

#: src/theory/cairo.md:23
msgid "[Awesome Cairo](https://github.com/auditless/awesome-cairo)"
msgstr ""

#: src/theory/cairo.md:24
msgid "[Starknet Book](https://book.starknet.io/)"
msgstr ""

#: src/theory/cairo.md:26
msgid "Starknet as an L2"
msgstr ""

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""

#: src/theory/cairo.md:32
msgid "Starknet as an Appchain"
msgstr ""

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for "
"Zero-Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, "
"and appchains. Remarkably, you can also run it in WebAssembly (WASM) to "
"generate proofs on the client-side! The Dojo team is working closely with "
"the [Madara](https://github.com/keep-starknet-strange/madara) team to enable "
"Starknet appchains to seamlessly run Dojo worlds."
msgstr ""

#: src/theory/faqs.md:3
msgid "Who owns Dojo?"
msgstr ""

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""

#: src/theory/faqs.md:7
msgid "Why Dojo?"
msgstr ""

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""

#: src/theory/faqs.md:11
msgid "What is the Dojo roadmap?"
msgstr ""

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo "
"Github](https://github.com/dojoengine/dojo/issues) and join the "
"[Discord](https://discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas "
"for the project, please open an issue."
msgstr ""

#: src/theory/faqs.md:15
msgid "What is an onchain game?"
msgstr ""

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""

#: src/theory/faqs.md:19
msgid "What is an autonomous world?"
msgstr ""

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous "
"Worlds](../theory/autonomous-worlds.md)."
msgstr ""

#: src/theory/faqs.md:23
msgid "What is Cairo?"
msgstr ""

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a "
"low-level language designed to compile to the Cairo Virtual Machine. Learn "
"more about it here: [Cairo](../theory/cairo.md)."
msgstr ""

#: src/theory/faqs.md:27
msgid "What is a provable game?"
msgstr ""

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""

#: src/getting-started/quick-start.md:3
msgid ""
"It is worth reading [theory](../theory/autonomous-worlds.md) to familiarize "
"yourself with the concept of Autonomous Worlds (AWs) and the [Cairo "
"ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""

#: src/getting-started/quick-start.md:6
msgid "Install Dojoup"
msgstr ""

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup "
"[here](https://github.com/dojoengine/dojo/blob/master/dojoup/README.md)."
msgstr ""

#: src/getting-started/quick-start.md:10
#: src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""

#: src/getting-started/quick-start.md:14
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen, "
"which will make the `dojoup` command available in your CLI."
msgstr ""

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see "
"[Dojoup](../toolchain/dojoup.md)."
msgstr ""

#: src/getting-started/quick-start.md:23
msgid "Next steps"
msgstr ""

#: src/getting-started/quick-start.md:25
msgid ""
"Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""

#: src/getting-started/from-source.md:1
msgid "Building from source"
msgstr ""

#: src/getting-started/from-source.md:3
msgid ""
"If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""

#: src/getting-started/from-source.md:5
#: src/getting-started/setup.md:5
msgid "Prerequisites"
msgstr ""

#: src/getting-started/from-source.md:7
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager. The easiest way to install both is with "
"[`rustup.rs`](https://rustup.rs/)."
msgstr ""

#: src/getting-started/from-source.md:10
msgid ""
"On Windows, you will also need a recent version of [Visual "
"Studio](https://visualstudio.microsoft.com/downloads/), installed with the "
"\"Desktop Development With C++\" Workloads option."
msgstr ""

#: src/getting-started/from-source.md:13
msgid "Building"
msgstr ""

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr ""

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr ""

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo "
"repository](https://github.com/dojoengine/dojo):"
msgstr ""

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""

#: src/getting-started/setup.md:3
msgid ""
"This article is a guide to setting up a development environment for Dojo. It "
"is not suggested to follow this guide if you are just wanting to play with "
"the toolchain. We strongly suggest following the [Quick "
"Start](../getting-started/quick-start.md) guide."
msgstr ""

#: src/getting-started/setup.md:7
msgid "Rust"
msgstr ""

#: src/getting-started/setup.md:12
msgid "Guide"
msgstr ""

#: src/getting-started/setup.md:14
msgid "Clone"
msgstr ""

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""

#: src/getting-started/setup.md:20
msgid "Linux & Mac"
msgstr ""

#: src/getting-started/setup.md:22
msgid "1. Install Rust and Dependencies"
msgstr ""

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr ""

#: src/getting-started/setup.md:30
msgid ""
"Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""

#: src/getting-started/setup.md:32
msgid "2. Install Scarb Package Manager"
msgstr ""

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""

#: src/getting-started/setup.md:40
msgid "3. Add the Cairo 1.0 VSCode Extension"
msgstr ""

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo "
"1.0](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1) "
"extension for Visual Studio Code."
msgstr ""

#: src/getting-started/setup.md:45
msgid "Windows"
msgstr ""

#: src/getting-started/setup.md:47
#: src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr ""

#: src/getting-started/setup.md:49
msgid "Container"
msgstr ""

#: src/getting-started/contributing.md:1
msgid "Contributing to the Core"
msgstr ""

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""

#: src/getting-started/contributing.md:5
msgid "How to Contribute"
msgstr ""

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""

#: src/community/get-started.md:3
msgid ""
"[Community "
"Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)"
msgstr ""

#: src/community/get-started.md:4
msgid "[Discord](https://discord.gg/KG9w9BmDrV)"
msgstr ""

#: src/community/get-started.md:5
msgid "[Twitter](https://twitter.com/dojostarknet)"
msgstr ""

#: src/community/get-started.md:6
msgid "[Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""

#: src/cairo/hello-dojo.md:3
msgid ""
"This section assumes that you have already installed the Dojo toolchain and "
"are familiar with Cairo. If not, please refer to the [Getting "
"Started](../getting-started/quick-start.md) section."
msgstr ""

#: src/cairo/hello-dojo.md:5
msgid "Dojo in 15 Minutes"
msgstr ""

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""

#: src/cairo/hello-dojo.md:19
msgid "Anatomy of a Dojo Project"
msgstr ""

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr ""

#: src/cairo/hello-dojo.md:54
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we _must_ include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr ""

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr ""

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr ""

#: src/cairo/hello-dojo.md:142
msgid "Explained the anatomy of a Dojo project"
msgstr ""

#: src/cairo/hello-dojo.md:143
msgid ""
"Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute"
msgstr ""

#: src/cairo/hello-dojo.md:144
msgid "Explained the `execute` function"
msgstr ""

#: src/cairo/hello-dojo.md:145
msgid "Explained the `Context` struct"
msgstr ""

#: src/cairo/hello-dojo.md:146
msgid "Touched on the `get!` and `set!` commands"
msgstr ""

#: src/cairo/hello-dojo.md:149
msgid "Run it locally!"
msgstr ""

#: src/cairo/hello-dojo.md:151
msgid "Now that we have some theory out of the way, lets build the Dojo project!"
msgstr ""

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr ""

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""

#: src/cairo/hello-dojo.md:221
msgid "Indexing"
msgstr ""

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr ""

#: src/cairo/hello-dojo.md:233
msgid "Built a Dojo world"
msgstr ""

#: src/cairo/hello-dojo.md:234
msgid "Deployed the project to Katana"
msgstr ""

#: src/cairo/hello-dojo.md:235
msgid "Ran the spawn system locally"
msgstr ""

#: src/cairo/hello-dojo.md:236
msgid "Indexed the world with Torii"
msgstr ""

#: src/cairo/hello-dojo.md:238
msgid "Next Steps"
msgstr ""

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a "
"[Scarb](https://docs.swmansion.com/scarb/) file which is an excellent Cairo "
"package manager and project manager."
msgstr ""

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr ""

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""

#: src/cairo/world.md:1
msgid "World Contract"
msgstr ""

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""

#: src/cairo/world.md:8
msgid ""
"**To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""

#: src/cairo/world.md:11
msgid "Context"
msgstr ""

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""

#: src/cairo/world.md:25
msgid "The `uuid()` command"
msgstr ""

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""

#: src/cairo/world.md:29
#: src/cairo/commands.md:20
#: src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr ""

#: src/cairo/world.md:36
msgid "Full World API"
msgstr ""

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:3
msgid "Components = Data"
msgstr ""

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""

#: src/cairo/components.md:10
msgid "Components are Structs"
msgstr ""

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""

#: src/cairo/components.md:23
msgid "The #\\[key\\] attribute"
msgstr ""

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""

#: src/cairo/components.md:53
msgid "Implementing Traits"
msgstr ""

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""

#: src/cairo/components.md:77
msgid "Custom Setting Components"
msgstr ""

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""

#: src/cairo/components.md:94
msgid "Types"
msgstr ""

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr ""

#: src/cairo/components.md:98
msgid "`u8`"
msgstr ""

#: src/cairo/components.md:99
msgid "`u16`"
msgstr ""

#: src/cairo/components.md:100
msgid "`u32`"
msgstr ""

#: src/cairo/components.md:101
msgid "`u64`"
msgstr ""

#: src/cairo/components.md:102
msgid "`u128`"
msgstr ""

#: src/cairo/components.md:103
msgid "`u256`"
msgstr ""

#: src/cairo/components.md:104
msgid "`ContractAddress`"
msgstr ""

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr ""

#: src/cairo/components.md:109
msgid "In practice with modularity in mind"
msgstr ""

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr ""

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: "
"position.y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: "
"position.y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:218
msgid ""
"A complete example can be found in the [Dojo "
"Starter](https://github.com/dojoengine/dojo-starter)"
msgstr ""

#: src/cairo/systems.md:3
msgid "Systems = Logic"
msgstr ""

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr ""

#: src/cairo/systems.md:31
msgid "The Execute function"
msgstr ""

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""

#: src/cairo/systems.md:35
msgid "Other functions in a System"
msgstr ""

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""

#: src/cairo/systems.md:39
msgid "Using View Functions"
msgstr ""

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr ""

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr ""

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr ""

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this "
"link](https://github.com/dojoengine/dojo-examples), illustrates how to "
"implement a view function:"
msgstr ""

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - "
"auction.start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr ""

#: src/cairo/systems.md:80
msgid ""
"**Using Dojo Core**: If you are working within the [Dojo "
"Core](../client/npm/core.md), utilize the `call` function. "
msgstr ""

#: src/cairo/systems.md:82
msgid ""
"**For Rust Users**: The [Starkli](https://book.starkli.rs/) library provides "
"a handy method to invoke view functions in Rust."
msgstr ""

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""

#: src/cairo/systems.md:86
msgid "System Authentication"
msgstr ""

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""

#: src/cairo/entities.md:3
msgid ""
"Entities are the primary key value within the world, to which components can "
"be attached."
msgstr ""

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the "
"`ctx.origin` to reference the current entity."
msgstr ""

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr ""

#: src/cairo/entities.md:58
msgid ""
"ECS Theory: Plenty has been written on ECS systems, to go deeper read "
"[ECS-FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""

#: src/cairo/authorization.md:3
msgid ""
"Authorization is crucial to a world, just like how authorization is crucial "
"to any smart contract."
msgstr ""

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""

#: src/cairo/authorization.md:7
msgid "Auth Architecture"
msgstr ""

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""

#: src/cairo/authorization.md:11
msgid "![Authorization Architecture](../images/dojo-auth.png)"
msgstr ""

#: src/cairo/authorization.md:13
msgid "Providing Authorization"
msgstr ""

#: src/cairo/authorization.md:15
msgid ""
"The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr ""

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""

#: src/cairo/commands.md:8
msgid "Using commands"
msgstr ""

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""

#: src/cairo/commands.md:16
msgid "The `get!` command"
msgstr ""

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr ""

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""

#: src/cairo/commands.md:30
msgid "The `set!` command"
msgstr ""

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr ""

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""

#: src/cairo/commands.md:52
msgid "The `emit!` command"
msgstr ""

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr ""

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to "
"[Torii](../toolchain/torii/overview.md), all these events are seamlessly "
"indexed, ensuring easy and efficient querying."
msgstr ""

#: src/cairo/events.md:6
msgid "Component Events"
msgstr ""

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr ""

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""

#: src/cairo/events.md:43
msgid "World Events"
msgstr ""

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""

#: src/cairo/events.md:74
msgid "Custom Events"
msgstr ""

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr ""

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr ""

#: src/cairo/events.md:107
msgid ""
"Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr ""

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr ""

#: src/cairo/testing.md:14
msgid "Writing Unit Tests"
msgstr ""

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the "
"Component/System you are writing."
msgstr ""

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr ""

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr ""

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""

#: src/cairo/testing.md:52
msgid "Writing Integration Tests"
msgstr ""

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""

#: src/cairo/testing.md:56
msgid ""
"This is the example from the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr ""

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr ""

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, "
"dojo::SerdeLen::<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, "
"dojo::SerdeLen::<Position>::len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/testing.md:113
msgid "Useful Dojo Test Functions"
msgstr ""

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""

#: src/cairo/modules.md:5
msgid "Module Architecture"
msgstr ""

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""

#: src/cairo/modules/erc20.md:5
msgid "Integration into Your World"
msgstr ""

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr ""

#: src/client/overview.md:7
msgid "[npm](./npm.md)"
msgstr ""

#: src/client/npm.md:1
msgid "Javascript Libraries"
msgstr ""

#: src/client/npm.md:3
msgid ""
"Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""

#: src/client/npm.md:5
msgid "Examples using these:"
msgstr ""

#: src/client/npm.md:7
msgid ""
"[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""

#: src/client/npm.md:8
msgid "[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""

#: src/client/npm.md:10
#: src/client/npm/core.md:1
msgid "@dojoengine/core"
msgstr ""

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr ""

#: src/client/npm.md:20
msgid "@dojoengine/react"
msgstr ""

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud "
"React](https://github.com/latticexyz/mud/tree/main/packages)"
msgstr ""

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr ""

#: src/client/npm.md:33
msgid "@dojoengine/create-burner"
msgstr ""

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr ""

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr ""

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""

#: src/client/npm/core.md:5
msgid "World explorers"
msgstr ""

#: src/client/npm/core.md:6
msgid "World deployers"
msgstr ""

#: src/client/npm/core.md:7
msgid "Games"
msgstr ""

#: src/client/npm/core.md:8
msgid "Anaylitics"
msgstr ""

#: src/client/npm/core.md:16
msgid "Example Usage"
msgstr ""

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React "
"App](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new "
"RPCProvider(import.meta.env.VITE_PUBLIC_WORLD_ADDRESS, "
"import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: "
"num.BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => "
"provider.entity(component, query),\n"
"        entities: async (component: string, partition: number) => "
"provider.entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new "
"GraphQLClient(import.meta.env.VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:1
msgid "`dojoup`"
msgstr ""

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr ""

#: src/toolchain/dojoup.md:5
msgid "Installing"
msgstr ""

#: src/toolchain/dojoup.md:11
#: src/toolchain/katana/overview.md:22
msgid "Usage"
msgstr ""

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr ""

#: src/toolchain/dojoup.md:18
msgid ""
"Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr ""

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr ""

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr ""

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at "
"`~/git/dojo`, assuming you're in the home directory)"
msgstr ""

#: src/toolchain/dojoup.md:66
msgid ""
"Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""

#: src/toolchain/dojoup.md:78
msgid "Precompiled binaries"
msgstr ""

#: src/toolchain/dojoup.md:80
msgid ""
"Precompiled binaries are available from the [GitHub releases "
"page](https://github.com/dojoengine/dojo/releases). These are better managed "
"by using [Dojoup](#using-dojoup)."
msgstr ""

#: src/toolchain/dojoup.md:84
msgid "ℹ️ **Note**"
msgstr ""

#: src/toolchain/dojoup.md:86
msgid ""
"If you're on Windows, you will need to install and use [Git "
"BASH](https://gitforwindows.org/) or "
"[WSL](https://learn.microsoft.com/en-us/windows/wsl/install), as your "
"terminal, since Dojoup currently does not support Powershell or Cmd."
msgstr ""

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of "
"World-building. In the future, it may include a GUI."
msgstr ""

#: src/toolchain/sozo/overview.md:5
#: src/toolchain/katana/overview.md:5
msgid "Features"
msgstr ""

#: src/toolchain/sozo/overview.md:7
msgid ""
"**Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""

#: src/toolchain/sozo/overview.md:9
#: src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
msgid "Installation"
msgstr ""

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via "
"[`dojoup`](../../getting-started/quick-start.md), our dedicated installation "
"package manager."
msgstr ""

#: src/toolchain/sozo/overview.md:13
#: src/toolchain/torii/overview.md:18
msgid "Installing from Source"
msgstr ""

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr ""

#: src/toolchain/sozo/overview.md:23
#: src/toolchain/katana/overview.md:60
#: src/toolchain/torii/overview.md:28
msgid "📚 **Reference**"
msgstr ""

#: src/toolchain/sozo/overview.md:25
msgid ""
"See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""

#: src/toolchain/sozo/reference.md:1
msgid "sozo reference"
msgstr ""

#: src/toolchain/sozo/reference.md:3
msgid "Project Commands"
msgstr ""

#: src/toolchain/sozo/reference.md:5
msgid "[init](./project-commands/init.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:6
msgid "[build](./project-commands/build.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:7
msgid "[test](./project-commands/test.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:8
msgid "[migrate](./project-commands/migrate.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:10
msgid "World Commands"
msgstr ""

#: src/toolchain/sozo/reference.md:12
msgid "[execute](./world-commands/execute.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:13
msgid "[register](./world-commands/register.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:14
msgid "[system](./world-commands/system.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:15
msgid "[component](./world-commands/component.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:16
msgid "[events](./world-commands/events.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:17
msgid "[auth](./world-commands/auth.md)"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:1
msgid "sozo init"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter)."
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:1
msgid "sozo build"
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:1
msgid "sozo test"
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "sozo migrate"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7
#: src/toolchain/torii/reference.md:7
msgid "USAGE"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105
#: src/toolchain/torii/reference.md:33
msgid "OPTIONS"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107
#: src/toolchain/torii/reference.md:35
msgid "General Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"    Name of the World. At the moment, the only usage for this option is to "
"be used as a salt when deploying the World contract to avoid address "
"conflicts. This option is **required** when performing the initial migration "
"of the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
msgid "World Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"    The address of the World contract.  \n"
"    ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
msgid "Starknet Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"    The Starknet RPC endpoint. \\[default: http://localhost:5050\\]  \n"
"    ENV: `STARKNET_RPC_URL`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
msgid "Account Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"    The Starknet account address.  \n"
"    ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
msgid "Signer Options - Raw"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"    The raw private key associated with the account contract.  \n"
"    ENV: `DOJO_PRIVATE_KEY`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
msgid "Signer Options - Keystore"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
msgid "`--keystore` _PATH_  \n    Use the keystore in the given folder or file."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"    The keystore password. Used with --keystore.  \n"
"    ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:178
#: src/toolchain/katana/reference.md:186
msgid "EXAMPLES"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "Deploying your World for the first time to a local Katana node"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "Updating a remote World after making some changes"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "sozo execute"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"    The calldata to be passed to the system that you want to execute.  \n"
"    Comma seperated values e.g., 0x12345,0x69420."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:56
msgid ""
"Executing the _position_ system which takes two values (_x_: 0x77 and _y_: "
"0x44)"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:1
msgid "sozo register"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:1
msgid "sozo system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "SUBCOMMANDS"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "`get`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "Arguments"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid "_`NAME`_  \n    The name of the system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:30
msgid "`dependency`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:59
msgid "Get the class hash of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:65
msgid "Get the component dependencies of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:1
msgid "sozo component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
#: src/toolchain/sozo/world-commands/component.md:54
msgid "_`NAME`_  \n    The name of the component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:31
msgid "`schema`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:44
msgid "`entity`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
"    The keys of the entity that you want to query.  \n"
"    Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:1
msgid "sozo events"
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "sozo auth"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr ""

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""

#: src/toolchain/katana/overview.md:7
msgid ""
"[Starknet JSON-RPC "
"v0.3.0](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) support"
msgstr ""

#: src/toolchain/katana/overview.md:8
msgid "Custom methods for manipulating the blockchain states"
msgstr ""

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via "
"[`dojoup`](../../getting-started/quick-start.md)."
msgstr ""

#: src/toolchain/katana/overview.md:14
msgid "Installing from source"
msgstr ""

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:62
msgid ""
"See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""

#: src/toolchain/katana/reference.md:1
msgid "katana reference"
msgstr ""

#: src/toolchain/katana/reference.md:3
msgid "NAME"
msgstr ""

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr ""

#: src/toolchain/katana/reference.md:13
#: src/toolchain/torii/reference.md:13
msgid "DESCRIPTION"
msgstr ""

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""

#: src/toolchain/katana/reference.md:19
msgid "Mining Modes"
msgstr ""

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""

#: src/toolchain/katana/reference.md:30
msgid "Supported Transport Layers"
msgstr ""

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""

#: src/toolchain/katana/reference.md:38
msgid "Starknet Feature Compatibility"
msgstr ""

#: src/toolchain/katana/reference.md:40
msgid "Supported Transaction Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Version"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "INVOKE"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "1"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "DECLARE"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "1, 2"
msgstr ""

#: src/toolchain/katana/reference.md:46
msgid "DEPLOY_ACCOUNT"
msgstr ""

#: src/toolchain/katana/reference.md:48
msgid "Supported RPC Methods"
msgstr ""

#: src/toolchain/katana/reference.md:50
msgid "Starknet Methods"
msgstr ""

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on "
"[this](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) "
"reference."
msgstr ""

#: src/toolchain/katana/reference.md:54
msgid "`starknet_blockNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:55
msgid "`starknet_blockHashAndNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:56
msgid "`starknet_getBlockWithTxs`"
msgstr ""

#: src/toolchain/katana/reference.md:57
msgid "`starknet_getBlockWithTxHashes`"
msgstr ""

#: src/toolchain/katana/reference.md:58
msgid "`starknet_getBlockTransactionCount`"
msgstr ""

#: src/toolchain/katana/reference.md:59
msgid "`starknet_getTransactionByHash`"
msgstr ""

#: src/toolchain/katana/reference.md:60
msgid "`starknet_getTransactionByBlockIdAndIndex`"
msgstr ""

#: src/toolchain/katana/reference.md:61
msgid "`starknet_getTransactionReceipt`"
msgstr ""

#: src/toolchain/katana/reference.md:62
msgid "`starknet_pendingTransactions`"
msgstr ""

#: src/toolchain/katana/reference.md:63
msgid "`starknet_getStateUpdate`"
msgstr ""

#: src/toolchain/katana/reference.md:65
msgid "`starknet_call`"
msgstr ""

#: src/toolchain/katana/reference.md:66
msgid "`starknet_estimateFee`"
msgstr ""

#: src/toolchain/katana/reference.md:68
msgid "`starknet_chainId`"
msgstr ""

#: src/toolchain/katana/reference.md:70
msgid "`starknet_getNonce`"
msgstr ""

#: src/toolchain/katana/reference.md:71
msgid "`starknet_getEvents`"
msgstr ""

#: src/toolchain/katana/reference.md:72
msgid "`starknet_getStorageAt`"
msgstr ""

#: src/toolchain/katana/reference.md:73
msgid "`starknet_getClassHashAt`"
msgstr ""

#: src/toolchain/katana/reference.md:74
msgid "`starknet_getClass`"
msgstr ""

#: src/toolchain/katana/reference.md:75
msgid "`starknet_getClassAt`"
msgstr ""

#: src/toolchain/katana/reference.md:77
msgid "`starknet_syncing`"
msgstr ""

#: src/toolchain/katana/reference.md:79
msgid "`starknet_addInvokeTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:80
msgid "`starknet_addDeclareTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:81
msgid "`starknet_addDeployAccountTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:83
msgid "Custom Methods"
msgstr ""

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""

#: src/toolchain/katana/reference.md:90
msgid "`katana_nextBlockTimestamp`  \nGet the time for the next block."
msgstr ""

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""

#: src/toolchain/katana/reference.md:102
msgid "`katana_setStorageAt`  \nSet an exact value of a contract's storage slot."
msgstr ""

#: src/toolchain/katana/reference.md:109
msgid "`--silent`  \n     Don't print anything on startup."
msgstr ""

#: src/toolchain/katana/reference.md:112
msgid ""
"`--no-mining`  \n"
"     Disable auto and interval mining, and mine on demand instead."
msgstr ""

#: src/toolchain/katana/reference.md:115
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"     Block time in seconds for interval mining."
msgstr ""

#: src/toolchain/katana/reference.md:118
msgid ""
"`--dump-state <PATH>`  \n"
"     Dump the state of chain on exit to the given file.  \n"
"     If the value is a directory, the state will be written to "
"`<PATH>/state.bin`."
msgstr ""

#: src/toolchain/katana/reference.md:122
msgid ""
"`--load-state <PATH>`  \n"
"     Initialize the chain from a previously saved state snapshot."
msgstr ""

#: src/toolchain/katana/reference.md:125
msgid "`-h, --help`  \n     Print help (see a summary with '-h')."
msgstr ""

#: src/toolchain/katana/reference.md:128
msgid "`-V, --version`  \n     Print version information."
msgstr ""

#: src/toolchain/katana/reference.md:131
msgid "Server Options"
msgstr ""

#: src/toolchain/katana/reference.md:133
msgid "`-p, --port <PORT>`  \n     Port number to listen on. \\[default: 5050\\]"
msgstr ""

#: src/toolchain/katana/reference.md:136
msgid "`--host <HOST>`  \n     The IP address the server will listen on."
msgstr ""

#: src/toolchain/katana/reference.md:141
msgid ""
"`--seed <SEED>`  \n"
"     Specify the seed for randomness of accounts to be predeployed."
msgstr ""

#: src/toolchain/katana/reference.md:144
msgid ""
"`--accounts <NUM>`  \n"
"     Number of pre-funded accounts to generate. \\[default: 10\\]"
msgstr ""

#: src/toolchain/katana/reference.md:147
msgid "`--disable-fee`  \n     Disable charging fee for transactions."
msgstr ""

#: src/toolchain/katana/reference.md:150
msgid "Environment Options"
msgstr ""

#: src/toolchain/katana/reference.md:152
msgid "`--chain-id <CHAIN_ID>`  \n     The chain ID. \\[default: KATANA\\]"
msgstr ""

#: src/toolchain/katana/reference.md:155
msgid "`--gas-price <GAS_PRICE>`  \n     The gas price."
msgstr ""

#: src/toolchain/katana/reference.md:158
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account validation logic."
msgstr ""

#: src/toolchain/katana/reference.md:161
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account execution logic."
msgstr ""

#: src/toolchain/katana/reference.md:164
msgid "Shell Completions"
msgstr ""

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr ""

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr ""

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr ""

#: src/toolchain/katana/reference.md:172
msgid "bash"
msgstr ""

#: src/toolchain/katana/reference.md:173
msgid "elvish"
msgstr ""

#: src/toolchain/katana/reference.md:174
msgid "fish"
msgstr ""

#: src/toolchain/katana/reference.md:175
msgid "powershell"
msgstr ""

#: src/toolchain/katana/reference.md:176
msgid "zsh"
msgstr ""

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr ""

#: src/toolchain/katana/reference.md:188
msgid "Create 15 dev accounts and disable transaction fee mechanism"
msgstr ""

#: src/toolchain/katana/reference.md:194
msgid "Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""

#: src/toolchain/katana/reference.md:200
msgid ""
"Load previously stored state and dump the state of this session to a file on "
"shutdown"
msgstr ""

#: src/toolchain/torii/overview.md:1
msgid "Torii - Networking & Indexing"
msgstr ""

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""

#: src/toolchain/torii/overview.md:5
msgid "Dojo indexer"
msgstr ""

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr ""

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via "
"[`dojoup`](../../getting-started/quick-start.md), our dedicated installation "
"package manager."
msgstr ""

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr ""

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr ""

#: src/toolchain/torii/overview.md:30
msgid "See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""

#: src/toolchain/torii/reference.md:1
msgid "torii reference"
msgstr ""

#: src/toolchain/torii/reference.md:3
msgid "Name"
msgstr ""

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr ""

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""

#: src/toolchain/torii/reference.md:19
msgid "Database URL"
msgstr ""

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""

#: src/toolchain/torii/reference.md:23
msgid ""
"The in-memory database is ephermal and only lasts as long as the indexer is "
"running. This is a fast and simple option to start the indexer for "
"development/testing."
msgstr ""

#: src/toolchain/torii/reference.md:24
msgid ""
"Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""

#: src/toolchain/torii/reference.md:37
msgid "`-w, --world`      Address of the world contract to index"
msgstr ""

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`      Starknet RPC endpoing to use \\[default: http//localhost:5050\\]"
msgstr ""

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`      Specify a local manifest to initialize from"
msgstr ""

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`      Database URL (read more above) "
"\\[default: sqlite::memory:\\]"
msgstr ""

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`      Specify a block to start indexing "
"from, ignored if stored head exists \\[default: 0\\]"
msgstr ""

#: src/toolchain/torii/reference.md:52
msgid "`-h, --help`      Print help"
msgstr ""

#: src/toolchain/torii/reference.md:55
msgid "`-V, --version`      Print version"
msgstr ""

#: src/deployment/locally.md:1
msgid "Deploying Locally"
msgstr ""

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""

#: src/deployment/locally.md:5
msgid "Katana Deployments"
msgstr ""

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr ""

#: src/deployment/locally.md:9
msgid ""
"This assumes you have followed the [Quick "
"Start](./getting-started/quick-start.md) guide and have a project "
"initialized."
msgstr ""

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr ""

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr ""

#: src/deployment/locally.md:19
msgid "Deploying to Katana"
msgstr ""

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr ""

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""

#: src/deployment/remote.md:1
msgid "Deployment to Remote Network"
msgstr ""

#: src/deployment/remote.md:3
msgid "_IMPORTANT: Dojo is unaudited. Use at your own risk._"
msgstr ""

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr ""

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:33
msgid "Remote Katana"
msgstr ""

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""

#: src/deployment/remote.md:37
msgid "**todo**: add instructions for deploying to remote katana"
msgstr ""

#: src/deployment/remote.md:40
msgid "Madara"
msgstr ""

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr ""

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr ""

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr ""

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:59
msgid "Starknet"
msgstr ""

#: src/deployment/remote.md:61
msgid "**todo**: add instructions for deploying to remote Starknet"
msgstr ""

#: src/tutorial/onchain-chess/index.md:1
msgid "Building a Chess Game"
msgstr ""

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr ""

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""

#: src/tutorial/onchain-chess/index.md:11
msgid "What are we building?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""

#: src/tutorial/onchain-chess/index.md:15
msgid "A system to spawn all the chess pieces"
msgstr ""

#: src/tutorial/onchain-chess/index.md:16
msgid "A system to make pieces move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:17
msgid "Add some functions to check a legal move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:18
msgid "Play chess ♟♙ - integration test!"
msgstr ""

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this "
"repo](https://github.com/rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""

#: src/tutorial/onchain-chess/index.md:24
msgid "What after this guide?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the "
"[`hello-dojo`](../../cairo/hello-dojo.md) chapter to gain a basic "
"understanding of the Dojo game._"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "Initializing the Project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "Cleaning Up the Boilerplate"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:42
msgid "Basic components"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:46
msgid ""
"Every square of the chess board (e.g., A1) will be treated as an entity. If "
"a piece exists on a square, the square entity will hold that piece."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this "
"[chapter](../../cairo/components.md)."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:78
msgid "Basic systems"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:111
msgid "Compile your project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "Run test"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:189
msgid "Add more components"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:193
#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
msgid "Requirements"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:195
msgid "`Color` enum enum with values White and Black"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:196
msgid "`Game` component:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:205
msgid "`GameTurn` component:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:212
msgid ""
"We will later set game entity composed of the `Game` and `GameTurn` "
"components."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:213
msgid "Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:215
msgid "Try to solve on your own, and before you move on check the answer below."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:1
msgid "1. Initiate System"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:5
msgid "What is `initiate_system`?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your "
"`systems/initiate.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:17
msgid ""
"Implement the game entity, comprised of the `Game` component and `GameTurn` "
"component we created in the previous step."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:18
msgid ""
"Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:19
msgid "Run `sozo test` and pass all the tests."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "Test Flow"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"Spawn the test world that imports the components and systems used in testing."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:24
msgid ""
"Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:25
msgid ""
"Retrieve the game entity and piece entity created during `initiate_system`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:26
msgid "Ensure the game has been correctly created."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:27
msgid "Verify that each `Piece` is located in the correct `Square`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
msgid "Unit Tests"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
msgid "Need help?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo "
"community](https://discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the "
"[answer](https://github.com/rkdud007/chess-dojo/blob/tutorialv2/src/systems/initiate.cairo) "
"for chapter 1 here."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:1
msgid "2. Move System"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:5
msgid "What is `move_system`?"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your "
"`systems/move.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:13
msgid "Write an `execute` function in the system with the following inputs:"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:25
msgid ""
"Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:27
msgid "Run `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:31
msgid "Follow the same logic as `test_initiate` from the previous chapter."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:32
msgid "Move the White Knight from (1,0) to (2,2) using the `move_system`."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:33
msgid ""
"Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:5
msgid "If the next move goes outside the board."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:6
msgid "If there's a piece that can be captured."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:7
msgid "If the next move is allowed for the type of piece."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:8
msgid "If the user can allow to make a action (based on the piece's color)."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:9
msgid "... You can also add other custom check functions."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:11
msgid "Make Check Functions"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:15
msgid "See if the next spot is allowed for the type of piece moving."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:23
msgid "See if the next spot is still on the board."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:29
msgid ""
"See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:35
msgid ""
"You can also add other check functions to be extra sure the move is allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:85
msgid "Testing Each Function"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:1
msgid "4. Test Contract"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:7
msgid "Spawn `white_pawn_1` to (0,1)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:8
msgid "Move `white_pawn_1` to (0,3)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:9
msgid "Move `black_pawn_2` to (1,6)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:10
msgid "Move `white_pawn_1` to (0,4)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:11
msgid "Move `black_pawn_2` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:12
msgid "Move `white_pawn_1` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:13
msgid "Capture `black_pawn_2`"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:19
msgid "Copy the test below and add it to your `src/tests.cairo` file."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:20
msgid ""
"Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:22
msgid "Full Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
" in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:143
msgid "Diving into the Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:212
msgid "Congratulations!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:217
msgid ""
"Add a checkmate feature. Our game doesn't end now, so decide when it should!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:218
msgid ""
"Include special moves like castling, En Passant Capture, or Pawn Promotion."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:219
msgid ""
"Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo "
"community](https://discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/misc/contributors.md:1
msgid "Contributing to Dojo Book"
msgstr ""

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""

#: src/misc/contributors.md:5
msgid "The purpose of the book"
msgstr ""

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr ""

#: src/misc/contributors.md:11
msgid "Framework Theory"
msgstr ""

#: src/misc/contributors.md:13
msgid "Building a World"
msgstr ""

#: src/misc/contributors.md:15
msgid "Code of Conduct"
msgstr ""

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of "
"Conduct](https://www.rust-lang.org/policies/code-of-conduct)."
msgstr ""

#: src/misc/contributors.md:19
msgid "Ways to contribute"
msgstr ""

#: src/misc/contributors.md:21
msgid "Issues"
msgstr ""

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""

#: src/misc/contributors.md:29
msgid "Pull requests"
msgstr ""

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""

#: src/misc/contributors.md:35
msgid "Writing style"
msgstr ""

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr ""

#: src/misc/contributors.md:39
msgid "Chapters start with a second level heading"
msgstr ""

#: src/misc/contributors.md:41
msgid "We use:"
msgstr ""

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr ""

