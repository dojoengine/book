msgid ""
msgstr ""
"Project-Id-Version: Dojo: The Provable Game Engine\n"
"POT-Creation-Date: 2023-10-04T10:45:06+08:00\n"
"PO-Revision-Date: 2023-09-18 14:38+0800\n"
"Last-Translator: LIB <libcreatesweb3@gmail.com>\n"
"Language-Team: Language ja\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "序文"

#: src/SUMMARY.md:4 src/theory/what-is-dojo.md:1
msgid "What is Dojo?"
msgstr "Dojoとは？"

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "AW理論"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "Cairo"

#: src/SUMMARY.md:7 src/theory/faqs.md:1
msgid "FAQs"
msgstr "よくあるご質問"

#: src/SUMMARY.md:9 src/client/npm/core.md:10 src/misc/contributors.md:12
msgid "Getting Started"
msgstr "はじめに"

#: src/SUMMARY.md:11 src/getting-started/quick-start.md:1
msgid "Quick Start"
msgstr "クイックスタート"

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr "手動インストール"

#: src/SUMMARY.md:13 src/getting-started/setup.md:1
msgid "Development Setup"
msgstr "開発セットアップ"

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr "貢献"

#: src/SUMMARY.md:16
msgid "Community"
msgstr "コミュニティ"

#: src/SUMMARY.md:18 src/community/get-started.md:1
msgid "Get Started"
msgstr "始めましょう"

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr "設計"

#: src/SUMMARY.md:22 src/cairo/hello-dojo.md:1
msgid "Hello Dojo"
msgstr "Hello Dojo"

#: src/SUMMARY.md:23 src/cairo/config.md:1
msgid "Config"
msgstr "Config"

#: src/SUMMARY.md:24
msgid "World"
msgstr "World"

#: src/SUMMARY.md:25 src/cairo/components.md:1
msgid "Components"
msgstr ""

#: src/SUMMARY.md:26 src/cairo/systems.md:1
msgid "Systems"
msgstr ""

#: src/SUMMARY.md:27 src/cairo/entities.md:1
msgid "Entities"
msgstr ""

#: src/SUMMARY.md:28 src/cairo/authorization.md:1
msgid "Authorization"
msgstr ""

#: src/SUMMARY.md:29 src/cairo/commands.md:1
msgid "Commands"
msgstr ""

#: src/SUMMARY.md:30 src/cairo/events.md:1
msgid "Events"
msgstr ""

#: src/SUMMARY.md:31 src/cairo/testing.md:1
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:32 src/cairo/modules.md:1
msgid "Dojo Modules"
msgstr ""

#: src/SUMMARY.md:33 src/cairo/modules/erc20.md:1
msgid "ERC20"
msgstr ""

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr ""

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr ""

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr ""

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr ""

#: src/SUMMARY.md:40 src/client/overview.md:1
msgid "Overview"
msgstr ""

#: src/SUMMARY.md:41
msgid "JS"
msgstr ""

#: src/SUMMARY.md:42
msgid "Core"
msgstr ""

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr ""

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr ""

#: src/SUMMARY.md:47 src/toolchain/sozo/overview.md:1
msgid "Sozo"
msgstr ""

#: src/SUMMARY.md:48 src/SUMMARY.md:60 src/SUMMARY.md:62
msgid "Reference"
msgstr ""

#: src/SUMMARY.md:49
msgid "init"
msgstr ""

#: src/SUMMARY.md:50
msgid "build"
msgstr ""

#: src/SUMMARY.md:51
msgid "test"
msgstr ""

#: src/SUMMARY.md:52
msgid "migrate"
msgstr ""

#: src/SUMMARY.md:53
msgid "execute"
msgstr ""

#: src/SUMMARY.md:54
msgid "register"
msgstr ""

#: src/SUMMARY.md:55
msgid "system"
msgstr ""

#: src/SUMMARY.md:56
msgid "component"
msgstr ""

#: src/SUMMARY.md:57
msgid "events"
msgstr ""

#: src/SUMMARY.md:58
msgid "auth"
msgstr ""

#: src/SUMMARY.md:59 src/toolchain/katana/overview.md:1
msgid "Katana"
msgstr ""

#: src/SUMMARY.md:61
msgid "Torii"
msgstr ""

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr ""

#: src/SUMMARY.md:66
msgid "Locally"
msgstr ""

#: src/SUMMARY.md:67
msgid "Remote"
msgstr ""

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr ""

#: src/SUMMARY.md:72 src/tutorial/onchain-chess/0-setup.md:1
msgid "0. Setup"
msgstr ""

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr ""

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr ""

#: src/SUMMARY.md:75 src/tutorial/onchain-chess/3-legal.md:1
msgid "3. Check Legal Move"
msgstr ""

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr ""

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr "貢献者たち"

#: src/index.md:1
msgid "![Dojo](images/dojo-mark-full-dark.svg)"
msgstr "![Dojo](images/dojo-mark-full-dark.svg)"

#: src/index.md:3
#, fuzzy
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"Dojoはオープンソースのプロジェクトで、現在開発初期段階にあり、プロジェクトへ"
"の貢献者を歓迎します。その他のリソースについては、[Discord](https://discord."
"gg/vUN4Xq9Qv6) でコミュニティに参加し、[貢献ガイド](./misc/contributors.md) "
"を確認してください。"

#: src/index.md:7
#, fuzzy
msgid "Dojo: The Provable Game Engine"
msgstr "Dojo: 証明可能なゲームエンジン"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""
"Dojoは[Cairo](https://github.com/starkware-libs/cairo)を採用し、Autonomous "
"Worldやオンチェーンゲームをデザインするための堅牢なアーキテクチャとツールセッ"
"トを提供します。統合されたエンティティコンポーネントシステム (ECS) が特徴"
"で、 ネイティブインデクサー、RPCテストネット、包括的なCLI管理ツールキットが含"
"まれています。"

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the [Theory](./theory/"
"autonomous-worlds.md) elucidates this emergent concept of autonomous worlds "
"and Provable games."
msgstr ""
"本書は、DojoエンジンとProvableゲームの可能性に親しんでいただくことを目的とし"
"ています。[理論](./theory/autonomous-worlds.md)の特別セクションでは、この自律"
"世界とプロバブル・ゲームの出現概念を解明しています。"

#: src/index.md:13
msgid "[Quickstart](./getting-started/quick-start.md)"
msgstr "[クイックスタート](./getting-started/quick-start.md)"

#: src/index.md:14
msgid "[What is Dojo? ](./theory/what-is-dojo.md)"
msgstr "[Dojoとは ](./theory/what-is-dojo.md)"

#: src/index.md:15
msgid "[Explore the Architecture](./cairo/hello-dojo.md)"
msgstr "[設計を知る](./cairo/hello-dojo.md)"

#: src/index.md:18
#, fuzzy
msgid "Explainer"
msgstr "解説者"

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://"
"twitter.com/tarrenceva) explaining how Dojo works at the 2023 [Autonomous "
"Anonymous Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""
"[Cartridge](https://cartridge.gg/)に所属している[Tarrence](https://twitter."
"com/tarrenceva)が2023年の[[Autonomous Anonymous Summit](https://twitter.com/"
"pet3rpan_/status/1666764726427353091)でDojoの仕組みについて説明している動画"
"だ:"

#: src/index.md:30
#, fuzzy
msgid "Organizational Structure"
msgstr "アーキテクチャー"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO]"
"(https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many "
"more [contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojoは、自律型世界(Autonomous Worlds: AWs)のコンセプトを推進し、発展させるこ"
"とを目的としたオープンソースのイニシアチブであり、MITの下でライセンスされてい"
"る。[Cartridge](https://cartridge.gg/)、[Realms & BibliothecaDAO](https://"
"bibliothecadao.xyz/)、[briq](https://briq.construction/)、その他多くの[貢献者"
"たち](https://github.com/orgs/dojoengine/people)によって先導されています。"

#: src/index.md:33
#, fuzzy
msgid "How do I get involved?"
msgstr "どうすれば関わることができるか？"

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) and "
"[contribution guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""
"[Github](https://github.com/dojoengine)、[Twitter](https://twitter.com/"
"dojostarknet)、[Discord](https://discord.gg/vUN4Xq9Qv6)、[コントリビューター"
"ガイド](https://book.dojoengine.org/misc/contributors.html)をご覧ください。"

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [on-"
"chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""
"Dojoは、ゲーム業界の新興分野である[オンチェーンゲーム](https://naavik.co/"
"digest/primer-fully-on-chain-gaming)の構築の試みから学んだ教訓の集大成です。"
"オンチェーンゲームの構築に取り組んだことのある開発者なら誰でも、エンジニアリ"
"ングに固有のハードルがあることを認識しています。新しいゲームを開発するたびに"
"Unityを作り直さないのと同じように、ここでも同じ原則が当てはまります。Dojoは複"
"雑なインフラを処理するように設計されており、開発者はゲームのユニークな側面に"
"集中することができます。"

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""
"Dojoは、証明可能なゲームを構築するためのツールとなることを目指しています。"
"Dojoは基本的にオープンソースであり、あらゆる貢献を歓迎する。"

#: src/theory/what-is-dojo.md:9
#, fuzzy
msgid "Stop building infrastructure; start building games"
msgstr "インフラ整備をやめ、ゲーム作りを始めよう"

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-"
"chain games. It includes:"
msgstr ""
"Dojoの一連のツールは、オンチェーンゲーム構築の複雑なインフラを取り除きます。"
"これには以下が含まれます:"

#: src/theory/what-is-dojo.md:13
#, fuzzy
msgid "Entity Component System (ECS)"
msgstr "Entity Component System (ECS)"

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""
"Dojoは、スマートコントラクト上でゲームを構築するための標準化されたアプローチ"
"を提供します。ゲームデザインの複雑さを認識するDojoは、開発プロセスを簡素化"
"し、クリエイターがゲームプレイのロジックに集中できるようにします。この標準化"
"は、ワールドの相互接続ネットワークへの道を開き、開発者の専門知識を合理化し、"
"ゲームの統合を促進する。"

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""
"ECS（エンティティ・コンポーネント・システム）をコア・アーキテクチャとして利用"
"するDojoは、自律型世界（AW）の状態と振る舞いを効果的に管理する。このモデル"
"は、純粋なデータコンポーネントの集まりであるエンティティに作用するシステムを"
"中心に展開されます。システムは、これらのコンポーネントに対する永続的なクエリ"
"に基づいて、処理するエンティティを効率的に決定します。"

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr "[Dojo ECS](../cairo/overview.md)の詳細情報を読む。"

#: src/theory/what-is-dojo.md:21
#, fuzzy
msgid "[Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr "[Torii](/crates/torii/README.md) - Starknetインデクサー"

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""
"オンチェーンゲームの構築には、オンチェーンステートの索引付けという課題が伴う"
"ことが多い。しかし、Dojo はコントラクトの状態を標準化し、伝統的なリレーショナ"
"ルデータベースをミラーリングします。このセットアップにより、[Torii Indexer]"
"(../toolchain/torii/overview.md) がすべてのコントラクトステートを自動インデッ"
"クス化し、効率的で合理的なクエリを保証します。Toriiは、これらの状態をGraphQL "
"APIまたはgRPC（近日公開予定）を介して公開し、開発者が簡単にデータを照会・取得"
"できるようにします。"

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-"
"chain games. It also eliminates the need to manually create indexers, which "
"can be a tedious and error-prone process."
msgstr ""
"Toriiを使用することで、オンチェーンゲームを構築するのに必要な時間と労力を大幅"
"に削減することができます。また、手作業でインデクサーを作成する必要もなくなり"
"ます。"

#: src/theory/what-is-dojo.md:27
#, fuzzy
msgid "[Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr "[Katana](/crates/katana/README.md) - 驚異的な速さの開発ネットワーク"

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable Starknet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""
"Katanaはカスタマイズ可能なStarknet開発ネットワークです。驚くほど高速で、ゲー"
"ムロジックを素早く反復することができます。"

#: src/theory/what-is-dojo.md:31
#, fuzzy
msgid "[Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr "[Sozo CLI](/crates/sozo/README.md) - CLI管理ツール"

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""
"Dojo ワールドは最大規模のコントラクトとなりそうです。Sozoはワールドの管理を支"
"援するCLIツールです。worldsの作成、ビルド、テスト、デプロイが可能です。さら"
"に、新しいコンポーネントやシステムを作成し、ワールドに登録することもできま"
"す。"

#: src/theory/what-is-dojo.md:35
#, fuzzy
msgid "What Dojo doesn't give you"
msgstr "Dojoではできないこと"

#: src/theory/what-is-dojo.md:37
#, fuzzy
msgid ""
"Visual graphics - While Dojo provides networking and contracts, it doesn't "
"offer graphical engines. You can bring your graphics of choice! Integrate "
"your Dojo world with Unreal, Godot, or Unity."
msgstr ""
"ビジュアルグラフィックス - Dojoはネットワークと契約を提供しますが、グラフィカ"
"ルエンジンは提供しません。好きなグラフィックを持ち込むことができます！Dojoの"
"世界をUnreal、Godot、またはUnityと統合できます。"

#: src/theory/what-is-dojo.md:39
#, fuzzy
msgid "Understanding the Dojo Workflow: A Visual Guide"
msgstr "Dojoワークフローを理解する:  ビジュアルガイド"

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""
"`sozo`の仕組みを理解していただくために、強力なsozoツールとカタナ開発ネット"
"ワークを使用した実行の流れを概説したビジュアルガイドを作成しました。"

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""
"この視覚的な表現は、Dojoを使用する基本的なステップを把握するのに役立ち、オン"
"チェーンゲームの作成と管理のプロセスをガイドします。"

#: src/theory/what-is-dojo.md:45
msgid "![Dojo Sozo Workflow](../images/dojo-sozo-workflow.jpg)"
msgstr "![Dojo Sozo Workflow](../images/dojo-sozo-workflow.jpg)"

#: src/theory/autonomous-worlds.md:1
#, fuzzy
msgid "Autonomous Worlds"
msgstr "Autonomous Worlds"

#: src/theory/autonomous-worlds.md:3
#, fuzzy
msgid ""
"\"Autonomous worlds represent persistent, permissionless, and decentralized "
"open environments that users can freely interact with and contribute to.\""
msgstr ""
"“Autonomous worldは、永続的で、無許可で、分散化されたオープンな環境であり、"
"ユーザーは自由に交流し、貢献することができる。”"

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""
"自律型世界（Autonomous Worlds：AWs）の正確な定義は、まだ完全に結晶化されてい"
"ない抽象的な概念であるため、ややとらえどころがない。ラティスがこの用語を最初"
"に[導入](https://0xparc.org/blog/autonomous-worlds)したのは2022年のことだが、"
"ブロックチェーン上で動作するオープンワールドという概念は以前から存在してい"
"た。MUDによって導入された抽象化は、市場がこうした世界の可能性を認識するきっか"
"けとなった。"

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""
"Autonomous Worldsは、その基本的な性質においてブロックチェーンと顕著な共通点が"
"ある。自律型ワールドは一度構築されると持続し、チェーンの寿命を通じてその状態"
"を維持する。プレイヤーは参加したり離脱したりすることができ、開発者は、コント"
"ラクトがチェーンに追加される方法と同じように、無許可で機能を展開することに"
"よって、このワールドを拡張することができる。自律型ワールドに普遍的な定義はな"
"いが、自律型ワールドとみなされるためには、少なくとも以下の2つの本質的な特徴を"
"備えていなければならないと考えている："

#: src/theory/autonomous-worlds.md:9
#, fuzzy
msgid ""
"Decentralized data availability layer: While the state execution may reside "
"on a centralized layer, it is crucial that the state can be reconstructed if "
"the execution layer ceases to exist. Rollups offer a solution, providing "
"increased capacity execution layers while ensuring data is permanently "
"settled on Ethereum. This guarantees the world's perpetual persistence."
msgstr ""
"分散型データ可用性レイヤー: 状態の実行は中央集権レイヤーに存在するかもしれな"
"いが、実行レイヤーが存在しなくなった場合に状態を再構築できることが極めて重要"
"である。ロールアップは解決策を提供し、イーサリアム上にデータが永続的に定住す"
"ることを保証しながら、容量の大きい実行レイヤーを提供する。これにより、世界の"
"永続性が保証される。"

#: src/theory/autonomous-worlds.md:11
msgid ""
"Permissionless entry point for expanding the world: The World contract must "
"be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""
"ワールドを拡張するためのパーミッションレス・エントリーポイント： ワールドの契"
"約は、許可を必要とせずに新しいシステムやコンポーネントを受け入れることができ"
"なければならない。これは、すべてのコンポーネントやシステムが利用されることを"
"意味するものではないが、潜在的な拡張のためのオープンで無制限のアクセスを保証"
"するために、このパターンに従わなければならない。"

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""
"私たちは、ゼロ知識証明とブロックチェーン技術によって提供されるメディアにおい"
"て、新しい形の探求の触媒となるAutonomous Worldsの可能性を固く信じています。こ"
"れはゲームに限ったことではなく、アートワーク、コーディネーション、楽しさと"
"いった新しい形が、いじりや急進的なイノベーションから生まれ、やがてはこの勇敢"
"で新しい分散化された信頼のない世界における「遊び」の概念そのものに疑問を投げ"
"かけることになるのです。"

#: src/theory/autonomous-worlds.md:15
#, fuzzy
msgid "Homework"
msgstr "もっと詳しく知りたい方は以下の外部リンクも参照ください"

#: src/theory/autonomous-worlds.md:16
msgid ""
"[Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)"
msgstr ""
"[Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)"

#: src/theory/autonomous-worlds.md:17
msgid ""
"[0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)"
msgstr ""
"[0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)"

#: src/theory/autonomous-worlds.md:18
msgid ""
"[Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)"
msgstr ""
"[Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)"

#: src/theory/autonomous-worlds.md:19
msgid ""
"[Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)"
msgstr ""
"[Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)"

#: src/theory/autonomous-worlds.md:20
msgid "[Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)"
msgstr "[Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)"

#: src/theory/autonomous-worlds.md:21
msgid ""
"[Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)"
msgstr ""
"[Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)"

#: src/theory/autonomous-worlds.md:22
msgid ""
"[Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-"
"worlds/)"
msgstr ""
"[Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-"
"worlds/)"

#: src/theory/autonomous-worlds.md:23
msgid ""
"[Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-"
"chain-realities-and-autonomous-worlds)"
msgstr ""
"[Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-"
"chain-realities-and-autonomous-worlds)"

#: src/theory/cairo.md:1
#, fuzzy
msgid "Provable games"
msgstr "証明可能なゲーム"

#: src/theory/cairo.md:3
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-"
"knowledge-proofs/) properties for efficient scaling and verification of "
"computations. [Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) "
"addresses this need by providing a generalized language, eliminating the "
"complexity of creating circuits to incorporate [SNARKs](https://consensys."
"net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""
"証明可能なゲームは、計算の効率的なスケーリングと検証のために、[ゼロ知識]"
"(https://ethereum.org/en/zero-knowledge-proofs/)の特性を要求する。[Cairo]"
"(https://book. Standards Track)[Cairo](https://book.starknet.io/chapter_1/"
"what_is_cairo.html)は、[SNARKs](https://consensys.net/blog/developers/"
"introduction-to-zk-snarks/)を組み込むための回路を作る複雑さをなくし、一般化さ"
"れた言語を提供することによって、この必要性に対処している。 "

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr ""
"**Cairoでプログラムを組むだけで、アプリケーションは自動的に証明可能になる**. "

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), "
"which is compatible with Starknet's Layer 2, Starknet appchains, and even in-"
"browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK "
"primitives to fuel your game development."
msgstr ""
"さらに、プログラムを [Cairo Virtual Machine](https://medium.com/starkware/"
"cairo-welcome-on-board-1cf3487554f) (CVM) 上にデプロイすることができます。"
"CVM は Starknet の Layer 2 や Starknet appchains と互換性があり、WebAssembly "
"(WASM) を使ってブラウザ内でデプロイすることもできます！Dojoは、あなたのゲーム"
"開発を促進するために、わかりやすいZKプリミティブを提供することを目指していま"
"す。"

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""
"Starknet、Cairo、その技術スタックについての詳細は、[Starknet & Cairo book]"
"(https://book.starknet.io/)をご覧ください。"

#: src/theory/cairo.md:11 src/getting-started/setup.md:8
#, fuzzy
msgid "Cairo"
msgstr "Cairo"

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""
"CairoはStarkwareが開発したオープンソースのチューリング完全スマートコントラク"
"ト言語で、Validity Rollup Starknetを動かすために設計された。この言語は非常に"
"表現力が豊かで検証可能な計算を可能にするため、分散型金融（DeFi）プロジェクト"
"など、スケーラブルで安全なアプリケーションの構築に適している。"

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""
"DojoはCairoをベースにして、自律型ワールド（AW）を開発するための堅牢なフレーム"
"ワークを作ります。Cairoの機能を活用することで、Dojoは開発プロセスを効率化し、"
"保守性を向上させ、AWの性能を高めることを目指しています。"

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/"
"commands.md). Commands are a design pattern that helps to reduce boilerplate "
"code, resulting in cleaner and more maintainable applications. They achieve "
"this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Dojo フレームワークの主な特徴は、[commands](../cairo/commands.md) の使用で"
"す。コマンドはデザインパターンのひとつで、 定型化されたコードを減らすことで、"
"よりクリーンで保守性の高いアプリケーションを実現します。特定のアクションや操"
"作を、自己完結的で再利用可能なユニット内にカプセル化することでこれを実現しま"
"す。"

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""
"開発者はSystems内で自由にコマンドを書くことができ、Cairoコンパイラが適切な関"
"数のインライン化を行います. "

#: src/theory/cairo.md:21
#, fuzzy
msgid "Essential Reading"
msgstr "必読書"

#: src/theory/cairo.md:22
msgid "[Cairo book](https://cairo-book.github.io/)"
msgstr "[Cairo book](https://cairo-book.github.io/)"

#: src/theory/cairo.md:23
msgid "[Awesome Cairo](https://github.com/auditless/awesome-cairo)"
msgstr "[Awesome Cairo](https://github.com/auditless/awesome-cairo)"

#: src/theory/cairo.md:24
msgid "[Starknet Book](https://book.starknet.io/)"
msgstr "[Starknet Book](https://book.starknet.io/)"

#: src/theory/cairo.md:26
#, fuzzy
msgid "Starknet as an L2"
msgstr "L2としてのStarknet"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknetは、イーサリアムをスケールさせるために設計されたValidity Rollup "
"Layer 2（L2）ソリューションです。イーサリアムのレイヤー1（L1）と同レベルのセ"
"キュリティを維持しながら、高いトランザクションスループットと低いガスコストを"
"提供することで運用されている。Starknetの戦略は、数独のパズルを解くのに似てい"
"る。同様に、Starknetは重くコストのかかるL1計算を、オフチェーンで計算される"
"STARK証明の使用により、より安価なL1検証で置き換えます。"

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""
"より専門的な用語で言えば、Starknetは一般的な計算をサポートするパーミッション"
"レスのValidity-Rollup（「ZK-Rollup」とも呼ばれる）であり、現在はイーサリアム"
"上のL2ネットワークとして稼働している。このネットワークのL1セキュリティは、最"
"も安全でスケーラブルとされるSTARK暗号証明システムの利用によって保証されてい"
"る。"

#: src/theory/cairo.md:32
#, fuzzy
msgid "Starknet as an Appchain"
msgstr "AppchainとしてのStarknet"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-"
"Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, and "
"appchains. Remarkably, you can also run it in WebAssembly (WASM) to generate "
"proofs on the client-side! The Dojo team is working closely with the [Madara]"
"(https://github.com/keep-starknet-strange/madara) team to enable Starknet "
"appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairoは同型の汎用言語で、ゼロ知識（ZK）証明に最適化されている。Starknetや"
"Starkex、appchainsの原動力となっています。驚くべきことに、WebAssembly（WASM）"
"で実行し、クライアントサイドで証明を生成することもできる！Dojoチームは"
"[Madara](https://github.com/keep-starknet-strange/madara)チームと密接に協力"
"し、Starknet appchainsでDojoの世界をシームレスに実行できるようにしています。"

#: src/theory/faqs.md:3
#, fuzzy
msgid "Who owns Dojo?"
msgstr "Dojoの所有権は誰か？"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""
"Dojoは厳密にオープンソースであり、Apache 2.0ライセンスを使用しています。誰で"
"も無料でDojoを使用することができ、誰でもプロジェクトに貢献することができま"
"す。"

#: src/theory/faqs.md:7
#, fuzzy
msgid "Why Dojo?"
msgstr "なぜDojoなのか？"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""
"Dojoは、創業者たちがオンチェーンゲームを構築する際に直面した問題を解決するた"
"めに作られた。Dojoは、そのようなゲームを構築するプロセスを標準化し、それを容"
"易にする一連のツールを提供する。"

#: src/theory/faqs.md:11
#, fuzzy
msgid "What is the Dojo roadmap?"
msgstr "Dojoのロードマップはありますか？"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) and join the [Discord](https://"
"discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas for the project, "
"please open an issue."
msgstr ""
"Dojo は急速に進化しています。[Dojo Github](https://github.com/dojoengine/"
"dojo/issues)で公開されている課題を見つけたり、[Discord](https://discord.gg/"
"vUN4Xq9Qv6)に参加して参加することができます。プロジェクトへのアイデアがあれ"
"ば、課題を開いてください。"

#: src/theory/faqs.md:15
#, fuzzy
msgid "What is an onchain game?"
msgstr "オンチェーンゲームとは？"

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""
"オンチェーンゲームとは、パブリックブロックチェーンネットワーク上に完全に存在"
"するゲームのことで、すべてのステートとロジックがオンチェーンである。クライア"
"ント（ウェブブラウザなど）はチェーン上には存在せず、純粋にオンチェーンの状態"
"と対話し解釈するためだけに存在する。"

#: src/theory/faqs.md:19
#, fuzzy
msgid "What is an autonomous world?"
msgstr "Autonomous Worldとは何か？"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous Worlds](../theory/"
"autonomous-worlds.md)."
msgstr ""
"Autonomous Worldとは、完全にオンチェーンで存在する世界のことです。単一のエン"
"ティティによって制御されるのではなく、その世界の中で設定されたルールによって"
"支配される。このトピックをさらに深く掘り下げるには、こちらをご覧ください： "
"[Autonomous Worlds](../theory/autonomous-worlds.md)。"

#: src/theory/faqs.md:23
#, fuzzy
msgid "What is Cairo?"
msgstr "Cairoとは？"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a low-"
"level language designed to compile to the Cairo Virtual Machine. Learn more "
"about it here: [Cairo](../theory/cairo.md)."
msgstr ""
"CairoはStarkwareが開発したオープンソースのプログラミング言語です。チューリン"
"グ完全言語であり、汎用計算を目的としている。Cairo 仮想マシンにコンパイルする"
"ように設計された低レベル言語です。詳しくはこちら： [Cairo](../theory/cairo."
"md)。"

#: src/theory/faqs.md:27
#, fuzzy
msgid "What is a provable game?"
msgstr "証明可能なゲームとは？"

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""
"ゼロ知識証明の魔法のおかげで、オフチェーンで作成されたzk証明を検証すること"
"で、ゲームが公正であることを保証することができる。しかし、それは何を意味する"
"のだろうか？チェスのゲームを考えてみよう。私たちは、プレーヤーが互いの手を信"
"頼し合えるようなゲームを目指している。もしこれがブロックチェーン環境であれ"
"ば、すべての手がブロックチェーン上で取引されることになる。これにはコストがか"
"かる。私たちは勝者を知りたいだけで、すべての手を知りたいわけではない。"

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""
"ゼロ知識証明とクライアント通信により、プレイヤーはステートチャネルを確立し、"
"オフチェーンで手を共有し、その有効性を保証することができる。最後に、zk証明を"
"ブロックチェーンに提出し、ゲームの公平性を確認することができる。これは証明可"
"能なゲームを構成する。"

#: src/getting-started/quick-start.md:3
#, fuzzy
msgid ""
"It is worth reading [theory](../theory/autonomous-worlds.md) to familiarize "
"yourself with the concept of Autonomous Worlds (AWs) and the [Cairo "
"ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""
"コードに入る前に、[theory](../theory/autonomous-worlds.md)を読んで自律世界"
"(AW)の概念と[cairo ecosystem](../theory/cairo.md)に慣れる価値がある。"

#: src/getting-started/quick-start.md:6
#, fuzzy
msgid "Install Dojoup"
msgstr "Dojoのインストール"

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup [here](https://github.com/dojoengine/dojo/blob/master/dojoup/README."
"md)."
msgstr ""
"Dojoは、Katana、Torii、Sozoといった一連の開発ツールを中心に構築されています。"
"Dojoupを使えば、これらすべてを簡単にインストールできます。Dojoupについての詳"
"しい情報は[こちら](https://github.com/dojoengine/dojo/blob/master/dojoup/"
"README.md)をご覧ください。"

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"

#: src/getting-started/quick-start.md:14
#, fuzzy
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen, "
"which will make the `dojoup` command available in your CLI."
msgstr ""
"これでDojoupがインストールされ、画面の指示に従うだけで、CLIで`dojoup`コマンド"
"が使えるようになる。"

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup."
"md)."
msgstr ""
"`dojoup`の完全なリファレンスとデバッグについては、[Dojoup](../toolchain/"
"dojoup.md)を参照してください。"

#: src/getting-started/quick-start.md:23
#, fuzzy
msgid "Next steps"
msgstr "次のステップ"

#: src/getting-started/quick-start.md:25
#, fuzzy
msgid ""
"Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""
"[Hello Dojo](../cairo/hello-dojo.md)にアクセスして、最初のDojoワールドを作成"
"してください。"

#: src/getting-started/from-source.md:1
#, fuzzy
msgid "Building from source"
msgstr "ソースからの構築"

#: src/getting-started/from-source.md:3
#, fuzzy
msgid ""
"If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""
"もし、ツールチェーンで遊びたいだけなら、[クイック・スタート](./quick-start."
"md)ガイドに従うことを強くお勧めします。"

#: src/getting-started/from-source.md:5 src/getting-started/setup.md:5
#, fuzzy
msgid "Prerequisites"
msgstr "前提条件"

#: src/getting-started/from-source.md:7
#, fuzzy
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager. The easiest way to install both is with [`rustup.rs`]"
"(https://rustup.rs/)."
msgstr ""
"[Rust](https://rust-lang.org)コンパイラとRustパッケージマネージャのCargoが必"
"要です。両方をインストールする最も簡単な方法は、[`rustup.rs`](https://rustup."
"rs/)を使うことです。"

#: src/getting-started/from-source.md:10
#, fuzzy
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://"
"visualstudio.microsoft.com/downloads/), installed with the \"Desktop "
"Development With C++\" Workloads option."
msgstr ""
"Windowsの場合、”Visual Studio”(https://visualstudio.microsoft.com/downloads/)"
"の最新バージョンと、”Desktop Development With C++”（C++によるデスクトップ開"
"発）オプションがインストールされている必要があります。ワークロード・オプショ"
"ンが必要です。"

#: src/getting-started/from-source.md:13
#, fuzzy
msgid "Building"
msgstr "構築"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "異なる[Dojoup](#using-dojoup)フラグを使うこともできる："

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "あるいは、Cargoのコマンドを1つ使う："

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""
"```sh\n"
"cargo install —git https://github.com/dojoengine/dojo —force sozo katana "
"torii\n"
"```"

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://"
"github.com/dojoengine/dojo):"
msgstr ""
"または、[Dojo リポジトリ](https://github.com/dojoengine/dojo) のローカルコ"
"ピーから手動でビルドします："

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install —path ./crates/sozo —force\n"
"# install Katana\n"
"cargo install —path ./crates/katana —force\n"
"# install Torii\n"
"cargo install —path ./crates/torii —force\n"
"```"

#: src/getting-started/setup.md:3
#, fuzzy
msgid ""
"This article is a guide to setting up a development environment for Dojo. It "
"is not suggested to follow this guide if you are just wanting to play with "
"the toolchain. We strongly suggest following the [Quick Start](../getting-"
"started/quick-start.md) guide."
msgstr ""
"この記事は Dojo の開発環境をセットアップするためのガイドです。ツールチェイン"
"で遊びたいだけなら、このガイドに従うことはお勧めしません。クイックスタート]"
"(../getting-started/quick-start.md) ガイドに従うことを強くお勧めします。"

#: src/getting-started/setup.md:7
msgid "Rust"
msgstr "Rust"

#: src/getting-started/setup.md:12
#, fuzzy
msgid "Guide"
msgstr "Guide"

#: src/getting-started/setup.md:14
#, fuzzy
msgid "Clone"
msgstr "Clone"

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"

#: src/getting-started/setup.md:20
#, fuzzy
msgid "Linux & Mac"
msgstr "Linux & Mac"

#: src/getting-started/setup.md:22
#, fuzzy
msgid "1. Install Rust and Dependencies"
msgstr "1. Rustと依存関係のインストール"

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr ""
"まずRustをインストールし、テスト・スイートを実行してセットアップを確認する:"

#: src/getting-started/setup.md:30
#, fuzzy
msgid ""
"Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""
"注意: お使いのLinuxディストリビューションによっては、追加の依存関係をインス"
"トールする必要がある場合があります。セットアップの過程で、推奨される依存関係"
"や不足している依存関係があれば、必ずインストールしてください。"

#: src/getting-started/setup.md:32
#, fuzzy
msgid "2. Install Scarb Package Manager"
msgstr "2. Scarbパッケージマネージャをインストールする"

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""
"次に、[Scarb](https://docs.swmansion.com/scarb) パッケージマネージャをインス"
"トールしてください："

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""
"```sh\n"
"curl —proto ‘=https’ —tlsv1.2 -sSf https://docs.swmansion.com/scarb/install."
"sh | sh\n"
"```"

#: src/getting-started/setup.md:40
#, fuzzy
msgid "3. Add the Cairo 1.0 VSCode Extension"
msgstr "3. Cairo 1.0 VSCode Extensionを追加します"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) extension for Visual Studio Code."
msgstr ""
"Visual Studio Codeの拡張機能[Cairo 1.0](https://marketplace.visualstudio.com/"
"items?itemName=starkware.cairo1)をインストールします。"

#: src/getting-started/setup.md:45
#, fuzzy
msgid "Windows"
msgstr "Windows"

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "_Coming soon_"

#: src/getting-started/setup.md:49
msgid "Container"
msgstr ""

#: src/getting-started/contributing.md:1
#, fuzzy
msgid "Contributing to the Core"
msgstr "コアへの貢献"

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""
"Dojoはオープンソースのプロジェクトで、現在開発初期段階にあり、貢献者を温かく"
"歓迎します。"

#: src/getting-started/contributing.md:5
#, fuzzy
msgid "How to Contribute"
msgstr "貢献の仕方"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""
"[Github](https://github.com/dojoengine/dojo/issues)のOpen Issueにアクセスして"
"ください。もし未割り当てのイシューを見つけたら、コメントで割り当てをリクエス"
"トしてください。新機能のアイデアがある場合は、`enhancement`タグを付けてissue"
"を作成してください。"

#: src/community/get-started.md:3
#, fuzzy
msgid ""
"[Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)"
msgstr ""
"[Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)"

#: src/community/get-started.md:4
msgid "[Discord](https://discord.gg/KG9w9BmDrV)"
msgstr "[Discord](https://discord.gg/KG9w9BmDrV)"

#: src/community/get-started.md:5
msgid "[Twitter](https://twitter.com/dojostarknet)"
msgstr "[Twitter](https://twitter.com/dojostarknet)"

#: src/community/get-started.md:6
msgid "[Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr "[Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"

#: src/cairo/hello-dojo.md:3
#, fuzzy
msgid ""
"This section assumes that you have already installed the Dojo toolchain and "
"are familiar with Cairo. If not, please refer to the [Getting Started](../"
"getting-started/quick-start.md) section."
msgstr ""
"この節では、Dojo ツールチェインをインストール済みで Cairo に慣れていることを"
"前提とします。そうでない場合は [Getting Started](../getting-started/quick-"
"start.md) セクションを参照ください。"

#: src/cairo/hello-dojo.md:5
#, fuzzy
msgid "Dojo in 15 Minutes"
msgstr "15分でできるDojo"

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""
"DojoはCairoを抽象化したもので、JavaScriptにおけるReactのようなものだと考えて"
"ください。コンパイル時に複雑なクエリに展開する省略記法のコマンドを書くことが"
"できます。Dojo はエンティティ・コンポーネント・システム (ECS) というよく知ら"
"れたアーキテクチャに基づいています。"

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""
"Dojoでは、システムとコンポーネントを使用して世界を設計します。システムは世界"
"のロジックの概要を示し、コンポーネントは状態を示します。この強力なパターンに"
"よって、ロジックを高度にモジュール化することができます。まだ理解できていなく"
"ても心配しないでください。"

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""
"まず始めに、あなたのマシン上でローカルに実行するプロジェクトをセットアップし"
"てみましょう。空のディレクトリから:"

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""
"おめでとうございます！これでローカルに Dojo プロジェクトができました。このコ"
"マンドはカレントディレクトリに `dojo-starter` プロジェクトを作成します。これ"
"は新しいプロジェクトの理想的な出発点であり、始めるために必要なものをすべて備"
"えています。"

#: src/cairo/hello-dojo.md:19
#, fuzzy
msgid "Anatomy of a Dojo Project"
msgstr "Dojoプロジェクトの解剖"

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""
"`dojo-starter`プロジェクトの中身を調べると、次のような構造になっていることに"
"気づくだろう（cairo以外のファイルは除く）:"

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""
"Dojo プロジェクトは標準的な Cairo プロジェクトとほぼ同じですが、`Components` "
"や `Systems` を作るときに使う特別な属性タグがあります。次はこれを調べてみま"
"しょう。"

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr "`src/components.cairo`ファイルを開いて続ける。"

#: src/cairo/hello-dojo.md:54
#, fuzzy
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we _must_ include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""
"`#[derive(Component,Copy,Drop,Serde,SerdeLen)]`属性に注目。コンポーネントを認"
"識するためには、 `Component` を含める必要があります。これはDojoコンパイラに、"
"この構造体はコンポーネントとして扱われるべきであるというシグナルを送ります。"

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""
"我々の `Moves` コンポーネントは、その状態に `remaining` 値を保持する。key]` "
"属性は、このコンポーネントが `player` フィールドによってインデックス化されて"
"いることを Dojo に知らせます。もし、これが馴染みのないものであれば、この章の"
"後半でその重要性を明らかにします。基本的には、`player` フィールドを使用してこ"
"のコンポーネントに問い合わせることができることを意味します。"

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""
"同様に、`x` と `y` の値を保持する `Position` コンポーネントを持つ。ここでも、"
"このコンポーネントは `player` フィールドによってインデックスされる。"

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr "では、`src/systems.cairo`ファイルを調べてみましょう:"

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr "これを分解してみましょう:"

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""
"`#[derive(Component)]`属性を使用するのと同様に、`#[system]`属性はDojoコンパイ"
"ラにこの構造体がシステムであることを通知し、それに応じてコンパイルするように"
"指示します。"

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""
"このシステムには `execute` 関数があります。すべての Dojo システムには "
"`execute` 関数が必要であることに注意してください。この関数は `Context` をパラ"
"メータとして受け取る。Context` は世界と呼び出し元の情報を提供する個別の構造体"
"である。"

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""
"システムには `execute` 関数以外も含めることができるということは言っておく価値"
"がある。必要に応じて多くの関数を自由に含めることができます。しかし、`execute`"
"関数はシステムが実行されるときに呼び出されるので、必須です。"

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr "次の行を見てみましょう:"

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""
"ここでは、`get!` [command](./commands.md) を使用して、`ctx.origin` エンティ"
"ティの `Position` コンポーネントを取得します。ctx.origin`は呼び出し元のアドレ"
"スである。初めて呼び出されたときは、この関数が返される："

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr "さて、次の行です:"

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""
"ここでは、`set!` [command](./commands.md) を使用して、`ctx.origin` エンティ"
"ティの `Moves` と `Position` コンポーネントを設定します。"

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr "短時間で多くをカバーしました。おさらいしましょう:"

#: src/cairo/hello-dojo.md:142
msgid "Explained the anatomy of a Dojo project"
msgstr "Dojoプロジェクトの構造について説明しました"

#: src/cairo/hello-dojo.md:143
msgid ""
"Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute"
msgstr ""
"`#[derive(Component)]`属性と`#[[system]`属性の重要性について説明しました"

#: src/cairo/hello-dojo.md:144
msgid "Explained the `execute` function"
msgstr "`execute`関数の説明"

#: src/cairo/hello-dojo.md:145
msgid "Explained the `Context` struct"
msgstr "`Context` 構造体についての説明"

#: src/cairo/hello-dojo.md:146
msgid "Touched on the `get!` and `set!` commands"
msgstr "`get!`コマンドと`set!`コマンドについて触れた"

#: src/cairo/hello-dojo.md:149
#, fuzzy
msgid "Run it locally!"
msgstr "ローカルで実行する！"

#: src/cairo/hello-dojo.md:151
msgid ""
"Now that we have some theory out of the way, lets build the Dojo project!"
msgstr ""
"さて、理論がある程度わかったところで、Dojoプロジェクトを構築してみよう！"

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""
"これでコンポーネントとシステムがデプロイ可能な成果物にコンパイルされた！単純"
"なことだ！"

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""
"では、これを[Katana](../toolchain/katana/overview.md)にデプロイしてみましょ"
"う！まずはKatanaを動かす必要がある："

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""
"成功しました！[Katana](../toolchain/katana/overview.md)があなたのマシン上で"
"ローカルに実行されているはずです。それではデプロイしてみましょう！"

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""
"これでアーティファクトが[Katana](../toolchain/katana/overview.md)にデプロイさ"
"れます。このようなターミナル出力が表示されるはずです:"

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""
"あなたの🌎は "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16` に配置さ"
"れました！"

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""
"プロジェクトの`Scarb.toml`ファイルについて説明しよう。このファイルには、プロ"
"ジェクト内でCLIコマンドを簡単に実行できるようにするための環境変数が含まれてい"
"ます。(詳しくは[こちら](./config.md))。"

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr "ワールドアドレスをファイルの一番下に追加する："

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""
"```toml\n"
"world_address = "
"“0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16”\n"
"```"

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""
"これでプロジェクトのワールドアドレスが確立されます。その後、次のようなコマン"
"ドを実行できる:"

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""
"そうすることで、spawn system.が有効になります。これで、あなたが交流できるロー"
"カルワールドができたことになります。"

#: src/cairo/hello-dojo.md:221
#, fuzzy
msgid "Indexing"
msgstr "インデックス作成"

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""
"ローカル・ワールドのセットアップが終わったところで、インデックスの作成に取り"
"かかろう。この簡単なコマンドでワールド全体のインデックスを作ることができます:"

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""
"上記を実行すると、SQLiteをデータベースとして使用するローカルのtoriiサーバーが"
"アクティブになり、`http://0.0.0.0:8080`で公開されます。このサーバーは自動的に"
"あなたの世界をテーブルに索引付けし、GraphQL を使ってクエリーできるようにしま"
"す。"

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr "我々はかなりの部分をカバーしてきました！以下はそのまとめです:"

#: src/cairo/hello-dojo.md:233
msgid "Built a Dojo world"
msgstr "Dojo worldを構築"

#: src/cairo/hello-dojo.md:234
msgid "Deployed the project to Katana"
msgstr "Katanaにプロジェクトを展開"

#: src/cairo/hello-dojo.md:235
msgid "Ran the spawn system locally"
msgstr "Spawn systemをローカルで実行"

#: src/cairo/hello-dojo.md:236
msgid "Indexed the world with Torii"
msgstr "ToriiでWorldをインデックス化"

#: src/cairo/hello-dojo.md:238
#, fuzzy
msgid "Next Steps"
msgstr "次のステップ"

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""
"この概要では、Dojoをエンドツーエンドで素早く垣間見ることができます。しかし、"
"これらの世界の可能性は広大です！何百ものシステムやコンポーネントを管理できる"
"ように設計されているため、Dojo には幅広い創造性が備わっています。さて、次は何"
"を作るのでしょうか？"

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a [Scarb]"
"(https://docs.swmansion.com/scarb/) file which is an excellent Cairo package "
"manager and project manager."
msgstr ""
"Dojo の世界は Scarb.toml ファイルで定義されています。これは単なる[Scarb]"
"(https://docs.swmansion.com/scarb/)ファイルで、優れたCairoパッケージマネー"
"ジャであり、プロジェクトマネージャです。"

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr "Scarb.tomlファイルの完全な例:"

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"“0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c”\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"“0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b”\n"
"\n"
"# world contract address\n"
"world_address = "
"“0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6”\n"
"```"

#: src/cairo/world.md:1
#, fuzzy
msgid "World Contract"
msgstr "World Contract"

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""
"World Contractは中央システムカーネルとして機能し、すべてのインタラクションを"
"開始し解決するための基盤として機能する。このカーネルの中で、コントラクトはデ"
"プロイ、登録、実行され、クライアントが潜在的に何百ものコントラクトと関わるの"
"ではなく、単一のコントラクトと関わることを可能にすることで、下流のシステムの"
"プロセスを合理化します。"

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""
"Dojo core はこの契約を開発者から抽象化しています。開発者はこの契約を書くこと"
"はありませんし、ワールドを構築するときに変更することもありません。しかし、こ"
"れがどのように動作し、システムの他の部分とどのように相互作用するかを理解する"
"ことは重要です。"

#: src/cairo/world.md:8
#, fuzzy
msgid ""
"**To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""
"**To think about:** Autonomous Worldsは、別のブロックチェーンの中に存在する主"
"権ブロックチェーン、いわば入れ子のブロックチェーンだと考えてほしい。イーサリ"
"アムの機能を強化するためにコントラクトをイーサリアム上にデプロイできるよう"
"に、同様にワールドのコントラクトにシステムを導入してその機能を強化することが"
"できる。Ethereumのように誰でもWorldに貢献することができる一方で、コンポーネン"
"トの状態と対話するには認可が必要だ。認可については専用のトピックがあります。"

#: src/cairo/world.md:11
#, fuzzy
msgid "Context"
msgstr "Context"

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""
"どのSystemも最初のパラメータとして `Context` 構造体を受け取ることに気づくだろ"
"う。これは特別な構造体で、世界と呼び出し元の情報を含んでいる。"

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"

#: src/cairo/world.md:25
#, fuzzy
msgid "The `uuid()` command"
msgstr "`uuid()` コマンド"

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""
"エンティティの一意なIDを生成することはしばしば有用である。一意なIDを生成する"
"には `uuid()` fn を使うことができる。"

#: src/cairo/world.md:29 src/cairo/commands.md:20 src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr "このように使います:"

#: src/cairo/world.md:36
msgid "Full World API"
msgstr ""

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""
"Worldは、どんなクライアントでも相互作用できるインターフェイスを公開している。"

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"

#: src/cairo/components.md:3
#, fuzzy
msgid "Components = Data"
msgstr "Components = Data"

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""
"コンポーネントは、世界の構造を定義する基盤として機能し、システムが変異するた"
"めの状態をカプセル化します "

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""
"ワールドのコンポーネントをデザインする際には、コンポーザビリティを常に念頭に"
"置きながら、作成する抽象化を慎重に検討することが極めて重要です。"

#: src/cairo/components.md:10
#, fuzzy
msgid "Components are Structs"
msgstr "コンポーネントは構造体"

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""
"コンポーネントは Cairo では構造体として定義されます。いくつでもフィールドを持"
"つことができますが、 ECS では孤立した小さなコンポーネントを持つのがベストプラ"
"クティスです。そうすることで、モジュール化やコンポーザビリティが促進され、 複"
"数のエンティティ型でコンポーネントを再利用できるようになります。"

#: src/cairo/components.md:23
#, fuzzy
msgid "The #\\[key\\] attribute"
msgstr "The #\\[key\\] attribute"

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""
"`#[key]` 属性は、このコンポーネントが `player` フィールドによってインデックス"
"化されていることを Dojo に示します。各コンポーネントに対してキーを定義する必"
"要があります。しかし、複数のフィールドをキーとして定義することで、複合キーを"
"作成することができます。 "

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""
"この場合、プレーヤーフィールドとロケーションフィールドの両方をコンポーネント"
"に設定することになる:"

#: src/cairo/components.md:53
#, fuzzy
msgid "Implementing Traits"
msgstr "Traitsの実装"

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""
"コンポーネントはtraitを実装できる。これはコンポーネント間で共通の機能を定義す"
"るのに便利です。例えば、 `Position` コンポーネントに `PositionTrait` 特性を実"
"装したいとします。この trait には `is_zero` や `is_equal` といった関数を定義"
"することができ、コンポーネントにアクセスするときに使用することができます。"

#: src/cairo/components.md:77
#, fuzzy
msgid "Custom Setting Components"
msgstr "Custom Setting Components"

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""
"将来的に柔軟に変更できるグローバルな値を保持する場所が必要だとします。例え"
"ば、エンティティが次の攻撃に備えるために必要な時間を定義するグローバルな"
"combat_cool_downパラメータを考えてみよう。これを実現するには、この値を保存す"
"る専用のコンポーネントを作り、同時に分散型ガバナンス・モデルによってその値を"
"変更できるようにすればよい。"

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""
"これらのコンポーネントを確立するには、通常の作成方法に従う。ただし、初期化す"
"るときは、GAME_SETTINGS_IDのような定数識別子を使用する。"

#: src/cairo/components.md:94
#, fuzzy
msgid "Types"
msgstr "Types"

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr "Support Component types:"

#: src/cairo/components.md:98
msgid "`u8`"
msgstr "`u8`"

#: src/cairo/components.md:99
msgid "`u16`"
msgstr "`u16`"

#: src/cairo/components.md:100
msgid "`u32`"
msgstr ""

#: src/cairo/components.md:101
msgid "`u64`"
msgstr ""

#: src/cairo/components.md:102
msgid "`u128`"
msgstr ""

#: src/cairo/components.md:103
msgid "`u256`"
msgstr ""

#: src/cairo/components.md:104
msgid "`ContractAddress`"
msgstr "`ContractAddress`"

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr "現在、配列を使用することはできません。"

#: src/cairo/components.md:109
#, fuzzy
msgid "In practice with modularity in mind"
msgstr "モジュール化を念頭に置いた実践"

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""
"人間とゴブリンという具体的な例えを考えてみよう。両者には本質的な違いはある"
"が、地位や健康といった共通の特徴がある。しかし、人間には追加のコンポーネント"
"がある。さらに、人間とゴブリンの数を集計する明確な特徴であるカウンター・コン"
"ポーネントを導入する。"

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""
"つまり、Humanは`Potions`、`Health`、`Position`コンポーネントを持ち、Goblinは"
"`Health`と`Position`コンポーネントを持つことになります。こうすることで、各エ"
"ンティティタイプごとにHealthとPositionのコンポーネントを作成する手間を省くこ"
"とができます。"

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr "そうなると、システムは次のようになる:"

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:218
#, fuzzy
msgid ""
"A complete example can be found in the [Dojo Starter](https://github.com/"
"dojoengine/dojo-starter)"
msgstr ""
"完全な例は[Dojo Starter](https://github.com/dojoengine/dojo-starter)にある。"

#: src/cairo/systems.md:3
#, fuzzy
msgid "Systems = Logic"
msgstr "Systems = Logic"

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""
"システムはあなたの世界のロジックを支える。システムは本質的にステートレスです"
"が、その主な役割はコンポーネントのステートを変更することです。すべてのシステ"
"ムは、ワールド内でのインタラクション中に呼び出される’execute’関数を備えていま"
"す。"

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr ""
"`Moves`コンポーネントの状態を変化させる最も単純なシステムを見てみよう。"

#: src/cairo/systems.md:31
#, fuzzy
msgid "The Execute function"
msgstr "Execute 関数"

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""
"`execute`関数はシステムで必須であり、呼び出されると `Context` を最初のパラ"
"メータとして実行される。詳しくは[Context](./world.md)を参照。"

#: src/cairo/systems.md:35
#, fuzzy
msgid "Other functions in a System"
msgstr "システムのその他の機能"

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""
"他の関数を追加することは自由ですが、ワールドから呼び出すことはできません。こ"
"れはロジックをより小さな塊に分割するのに便利です。"

#: src/cairo/systems.md:39
#, fuzzy
msgid "Using View Functions"
msgstr "View関数の使用"

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""
"コンポーネントの静的な状態を取得するのではなく、動的にコンポーネントの値を計"
"算する必要がある場合があります。例えば、VRGDAのコンテキストで、現在の価格を確"
"認したい場合、単にコンポーネントの状態を問い合わせるだけでは十分ではありませ"
"ん。その代わりに、特定のパラメータと現在の状態に基づいて価格を計算する必要が"
"あります。"

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr "そこで活躍するのがView関数です。"

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr "**View関数とは何ですか？**"

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""
"View関数は、コンポーネントの既存の状態から値を導出または計算する方法です。こ"
"れらはワールドによって呼び出され、引数としてコンポーネントの現在の状態を受け"
"取る。その後、これらの関数はこの状態に基づいて計算された値を返します。"

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr "**VRGDAの例**："

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this link]"
"(https://github.com/dojoengine/dojo-examples), illustrates how to implement "
"a view function:"
msgstr ""
"[このリンク](https://github.com/dojoengine/dojo-examples)にあるVRGDAの例か"
"ら、ビュー関数の実装方法を示します:"

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""
"この例では、オークションの進行状況に基づいて、VRGDAの現在価格を計算し、返しま"
"す。"

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr "**View関数を呼び出すには？**"

#: src/cairo/systems.md:80
msgid ""
"**Using Dojo Core**: If you are working within the [Dojo Core](../client/npm/"
"core.md), utilize the `call` function. "
msgstr ""
"**Dojo Core を使用します**:  Dojo Core](../client/npm/core.md) 内で作業してい"
"る場合は、 `call` 関数を使用します。 "

#: src/cairo/systems.md:82
#, fuzzy
msgid ""
"**For Rust Users**: The [Starkli](https://book.starkli.rs/) library provides "
"a handy method to invoke view functions in Rust."
msgstr ""
"**Rustユーザーの皆様へ**： Starkli](https://book.starkli.rs/)ライブラリは、"
"Rustでビュー関数を呼び出す便利なメソッドを提供しています。"

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""
"この改訂版によって、伝えたい情報がより明確になり、流れが良くなることを願って"
"いる！"

#: src/cairo/systems.md:86
#, fuzzy
msgid "System Authentication"
msgstr "システム認証"

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""
"システムには、コンポーネントへの書き込み権限が与えられていなければならない。"
"デフォルトでは何の権限もない。しかし、`sozo`を使うことで、コンポーネントに書"
"き込む権限を与えることができる。"

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""
"ここでは `Spawn` システムに `Moves` コンポーネントへの書き込みを許可してい"
"る。 "

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""
"詳しくは[sozo](../toolchain/sozo/overview.md)のドキュメントをご覧ください。"

#: src/cairo/entities.md:3
#, fuzzy
msgid ""
"Entities are the primary key value within the world, to which components can "
"be attached."
msgstr ""
"エンティティは、ワールド内の主要なキーとなる値で、これにコンポーネントをア"
"タッチすることができる。"

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""
"ECS システムによって、エンティティの扱い方はさまざまです。Dojoでは、エンティ"
"ティはワールド内のプライマリキー値として扱われ、そこにコンポーネントをアタッ"
"チすることができます。この概念を説明するために、単純な例として `Moves` と "
"`Position` コンポーネントを持つゲームのキャラクターを考えてみましょう。"

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""
"このエンティティのコンポーネントを定義する際、エンティティを直接参照しないこ"
"とに注意することが重要である。その代わりに、エンティティが含む2つの構造体を提"
"供するだけです。 "

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the `ctx."
"origin` to reference the current entity."
msgstr ""
"では、このキャラクター用に `Spawn` を作成しよう。注意すべき点は、Entityを明示"
"的に定義していないことだ。その代わりに、`ctx.origin` を使って現在のエンティ"
"ティを参照している。"

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr "この例では、`ctx.origin`を使って現在のエンティティを参照している。"

#: src/cairo/entities.md:58
#, fuzzy
msgid ""
"ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-"
"FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""
"ECS理論： ECSシステムについては多くのことが書かれているが、より深く知りたいな"
"ら[ECS-FAQ](https://github.com/SanderMertens/ecs-faq)を読んでほしい。"

#: src/cairo/authorization.md:3
#, fuzzy
msgid ""
"Authorization is crucial to a world, just like how authorization is crucial "
"to any smart contract."
msgstr ""
"認可がスマート・コントラクトにとって重要であるように、認可は世界にとって重要"
"である。"

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""
"[World](./world.md)の章で説明したように、自律ワールド（AW）はパブリック・ブ"
"ロックチェーン内に入れ子状に存在する主権チェーンとして機能する。これらのワー"
"ルドは一般にも公開されている。この構造により、誰でもコンポーネントやシステム"
"をデプロイしてワールドを拡張することができる。しかし、このオープン性にはセ"
"キュリティ上の配慮も必要だ。イーサリアムと同様に、システム内のコンポーネント"
"の状態と相互作用するには、コンポーネントの所有者からの適切な承認が必要です。"

#: src/cairo/authorization.md:7
#, fuzzy
msgid "Auth Architecture"
msgstr "認証アーキテクチャ"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""
"ある `System` で `set!` が呼ばれるたびに、ワールドは `System` がコンポーネン"
"トの状態を更新する権限を持っているかどうかをチェックする。System` が必要な認"
"可を持っている場合にのみ、`set!` が実行される。以下の図は認可アーキテクチャを"
"表している。"

#: src/cairo/authorization.md:11
msgid "![Authorization Architecture](../images/dojo-auth.png)"
msgstr "![認証アーキテクチャ](../images/dojo-auth.png)"

#: src/cairo/authorization.md:13
#, fuzzy
msgid "Providing Authorization"
msgstr "認可の提供"

#: src/cairo/authorization.md:15
#, fuzzy
msgid ""
"The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""
"コンポーネントのデプロイ元が最初の所有者となります。コンポーネントのオーナー"
"は `owner` ロールと `writer` ロールを与えることができます。所有者のみがシステ"
"ムに `writer` ロールを付与することができ、そのロールはコンポーネントを更新す"
"ることができます。"

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr "`sozo`はシステムを認証する便利なツールを提供している。"

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""
"このコマンドは `Moves` コンポーネントを更新するために `spawn` システムの "
"`writer` 認証を生成する。"

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""
"コマンドを理解することは、Dojo を理解する上で重要です。あなたが設計するシステ"
"ムでは、コマンドを大いに活用することになるでしょう。"

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""
"Dojo のコマンドは、システムの実行を容易にするためにコンパイル時に拡張される一"
"般化された関数です。コンポーネントの取得や更新、一意な ID の生成などの一般的"
"な操作を抽象化することで、システムが世界の状態と対話するための便利な方法を提"
"供します。これらのコマンドを活用することで、開発者はシステム実装を効率化し、"
"コードの可読性を向上させることができる。"

#: src/cairo/commands.md:8
#, fuzzy
msgid "Using commands"
msgstr "コマンドの使用"

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""
"コマンドは、ワールド・ステートと対話するためにシステム内で使用される。コマン"
"ドは以下の構文で呼び出される："

#: src/cairo/commands.md:16
#, fuzzy
msgid "The `get!` command"
msgstr "`get!`コマンド"

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr ""
"`get!`コマンドはワールドステートからコンポーネントを取得するために使われる。"

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""
"ここでは、ワールドの状態から `Position` と `Moves` コンポーネントを取得してい"
"る。また、現在のエンティティのコンポーネントを取得するために `ctx.origin` を"
"使用している。"

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""
"あとは他のカイロ構造体と同じように `position` や `moves` を使えば良いです。"

#: src/cairo/commands.md:30
#, fuzzy
msgid "The `set!` command"
msgstr "`set!`コマンド"

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr "`set!`コマンドはコンポーネントの状態を更新するために使われます。"

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""
"ここでは、`ctx.origin`をエンティティIDとして、ワールドステートの`Moves`コン"
"ポーネントと`Position`コンポーネントを更新している。"

#: src/cairo/commands.md:52
#, fuzzy
msgid "The `emit!` command"
msgstr "`emit!`コマンド"

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr "`emit!`コマンドはカスタムイベントを発するために使われる。"

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/"
"overview.md), all these events are seamlessly indexed, ensuring easy and "
"efficient querying."
msgstr ""
"イベントは、Dojo の世界のダイナミクスを理解する上で重要な役割を果たします。コ"
"ンポーネントが更新されるたびに、 `World` コントラクトはイベントを発行します。"
"さらにエキサイティングなのは、特定のニーズに合わせて独自のカスタムイベントを"
"作成できることです！さらに、[Torii](../toolchain/torii/overview.md) のおかげ"
"で、これらのイベントはすべてシームレスにインデックス化され、簡単で効率的なク"
"エリを保証します。"

#: src/cairo/events.md:6
#, fuzzy
msgid "Component Events"
msgstr "Component Events"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr "`Moves`コンポーネントの例を考えてみましょう:"

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""
"このコンポーネントが更新されると、`World`コントラクトは以下の構造を持つイベン"
"トを発行する:"

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""
"これは[Torii](../toolchain/torii/overview.md)によってキャプチャされ、クエリ用"
"にインデックス化される。これにより、世界の状態を再構築することができる。"

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""
"同様に、コンポーネントが削除されると、`World`コントラクトは以下のような構造の"
"イベントを発行します:"

#: src/cairo/events.md:43
#, fuzzy
msgid "World Events"
msgstr "World Events"

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""
"`World`コントラクトは初期化されたときや、新しいコンポーネントやシステムが登録"
"されたときにもイベントを発行する。これらのイベントは以下の構造体で発行され"
"る："

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""
"これらのイベントは[Torii](../toolchain/torii/overview.md)によってもキャプチャ"
"され、クエリのためにインデックス化される。"

#: src/cairo/events.md:74
#, fuzzy
msgid "Custom Events"
msgstr "Custom Events"

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""
"システム内でカスタムイベントを放出することは非常に有益です。幸いなことに、便"
"利な `emit!` マクロがあるので、ワールドから直接イベントを放出することができま"
"す。次のように使ってください:"

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr "これをシステムに組み込むと、以下のような構造のイベントが発生します:"

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr "カスタム・イベントを使用した完全な例です: "

#: src/cairo/events.md:107
#, fuzzy
msgid ""
"Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""
"注意: `get!` と `set!` マクロについては [Commands](./commands.md) を参照。"

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""
"テストはソフトウェア開発プロセスの重要な部分です。Dojo はスマートコントラクト"
"のテストを書くためのテストフレームワークを提供します。Dojo はカスタムコンパイ"
"ラを使用しているため、コントラクトのテストには `sozo` を使用する必要がありま"
"す。"

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr "プロジェクトディレクトリから、単純に:"

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr "これにより、プロジェクト内のすべてのテストが検索され、実行される。"

#: src/cairo/testing.md:14
#, fuzzy
msgid "Writing Unit Tests"
msgstr "ユニットテストを書く"

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the Component/"
"System you are writing."
msgstr ""
"ユニットテストは、書いているコンポーネントやシステムと同じファイルに含めるの"
"がベストプラクティスです。"

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the [dojo-starter](https://github."
"com/dojoengine/dojo-starter):"
msgstr ""
"[dojo-starter](https://github.com/dojoengine/dojo-starter)にある`コンポーネン"
"ト`のテスト例を見てみましょう:"

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr "`components.cairo`"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""
"このテストでは `Position` コンポーネントの `is_zero` と `is_equal` 関数をテス"
"トする。コンポーネントのすべての関数をテストするのは良い習慣です。"

#: src/cairo/testing.md:52
#, fuzzy
msgid "Writing Integration Tests"
msgstr "統合テストを書く"

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""
"統合テストはシステム全体をテストする e2e テストです。プロジェクトルートに "
"`tests` ディレクトリを作成することで、自分の世界の統合テストを書くことができ"
"る。それから、書きたい統合テストごとにファイルを作成する。"

#: src/cairo/testing.md:56
msgid ""
"This is the example from the [dojo-starter](https://github.com/dojoengine/"
"dojo-starter):"
msgstr ""
"これは[dojo-starter](https://github.com/dojoengine/dojo-starter)の例です:"

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr "`systems.cairo`"

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity(‘Moves’, keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, ‘moves is wrong’);\n"
"        let new_position = world\n"
"            .entity(‘Position’, keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, ‘position x is wrong’);\n"
"        assert(*new_position[1] == 10, ‘position y is wrong’);\n"
"    }\n"
"}\n"
"```"

#: src/cairo/testing.md:113
#, fuzzy
msgid "Useful Dojo Test Functions"
msgstr "便利なDojoテスト関数"

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""
"`spawn_test_world(components, systems)` - この関数は、あなたが渡したコンポー"
"ネントとシステムでテストワールドを作成します。また、ワールドをデプロイし、コ"
"ンポーネントとシステムを登録します。"

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""
"システムとコンポーネントの標準化により、Dojo のモジュールアーキテクチャを作成"
"できます。これにより、どの Dojo worldでも使用できる再利用可能なモジュールを作"
"成できます。"

#: src/cairo/modules.md:5
#, fuzzy
msgid "Module Architecture"
msgstr "Module Architecture"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""
"モジュールはDojoのERCだと考えてください。機能を作成し、共有するための標準的な"
"方法です。モジュールは Dojo の世界にインポートできる システムとコンポーネント"
"の集まりです。Dojo は ERC パターンに従っており、ERC20、ERC721、ERC1155 用のモ"
"ジュールがすでに定義されています。"

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""
"DojoのERC20モジュールはERC20トークン標準の実装ですが、Dojoシステムとコンポー"
"ネントを利用しています。これにより、ERC20 標準の優れた特性を活用し、Dojo 環境"
"でネイティブに使用することができます。"

#: src/cairo/modules/erc20.md:5
#, fuzzy
msgid "Integration into Your World"
msgstr "あなたのWorldへの統合"

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""
"ERC20モジュールをワールドに統合するには、まずERC20 Dojoコントラクトをデプロイ"
"する必要があります。その後、システムとコンポーネントをワールドにインストール"
"します。"

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""
"DojoはBYOクライアントです。つまり、Dojoネットワークに接続するのに好きなクライ"
"アントを使うことができます。"

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr ""
"リファレンス・クライアントは以下のプラットフォームでご利用いただけます:"

#: src/client/overview.md:7
#, fuzzy
msgid "[npm](./npm.md)"
msgstr "[npm](./npm.md)"

#: src/client/npm.md:1
#, fuzzy
msgid "Javascript Libraries"
msgstr "Javascript Libraries"

#: src/client/npm.md:3
#, fuzzy
msgid ""
"Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""
"Dojoを始めるには、Javascriptが最適です。使い方は簡単で、数分で始めることがで"
"きる。"

#: src/client/npm.md:5
#, fuzzy
msgid "Examples using these:"
msgstr "これらを使った例:"

#: src/client/npm.md:7
#, fuzzy
msgid ""
"[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""
"[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#: src/client/npm.md:8
msgid ""
"[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""
"[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#: src/client/npm.md:10 src/client/npm/core.md:1
#, fuzzy
msgid "@dojoengine/core"
msgstr "@dojoengine/core"

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""
"これは最下層のライブラリで、他のすべての下流ライブラリで使用されます。Dojo の"
"コア機能を含み、コントラクトインターフェースを公開しています。Dojo の上に独自"
"のライブラリを構築したい場合に使用します。"

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr "[Documentation](./npm/core.md)"

#: src/client/npm.md:20
#, fuzzy
msgid "@dojoengine/react"
msgstr "@dojoengine/react"

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud React](https://github.com/latticexyz/mud/tree/"
"main/packages)"
msgstr ""
"これは[Mud React](https://github.com/latticexyz/mud/tree/main/packages)の直接"
"のフォークです。"

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""
"このライブラリには、Dojoを使用してReactアプリを構築する際に使用できるReactコ"
"ンポーネントのセットが含まれています。"

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr "[Documentation](./npm/react.md)"

#: src/client/npm.md:33
#, fuzzy
msgid "@dojoengine/create-burner"
msgstr "@dojoengine/create-burner"

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr ""
"Create burner は、Dojo アプリにバーナーウォレットを組み込む簡単な方法です。"

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr "[Reopsitory](https://github.com/dojoengine/create-burner)"

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""
"このライブラリーはワールドのインターフェースを抽象化し、ワールドと対話するた"
"めのヘルパー関数のセットを提供する。ワールドと直接対話するよりも、このライブ"
"ラリを使うことが望ましい。"

#: src/client/npm/core.md:5
msgid "World explorers"
msgstr "World explorers"

#: src/client/npm/core.md:6
msgid "World deployers"
msgstr "World deployers"

#: src/client/npm/core.md:7
msgid "Games"
msgstr "Games"

#: src/client/npm/core.md:8
msgid "Anaylitics"
msgstr "Anaylitics"

#: src/client/npm/core.md:16
#, fuzzy
msgid "Example Usage"
msgstr "Example Usage"

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"
msgstr ""
"これは[Dojo React App](https://github.com/dojoengine/dojo-starter-react-app)"
"の例です。"

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"

#: src/toolchain/dojoup.md:1
#, fuzzy
msgid "`dojoup`"
msgstr "`dojoup`"

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr "特定の Dojo ブランチを簡単に更新したり、戻したりできます。"

#: src/toolchain/dojoup.md:5
#, fuzzy
msgid "Installing"
msgstr "Installing"

#: src/toolchain/dojoup.md:11 src/toolchain/katana/overview.md:22
#, fuzzy
msgid "Usage"
msgstr "使用方法"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr "最新の**stable**バージョンをインストールする:"

#: src/toolchain/dojoup.md:18
#, fuzzy
msgid ""
"Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""
"注: `dojoup` を使うには `jq` をインストールする必要があるかもしれない。以下の"
"コマンドでインストールできる:"

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr "特定の**version**（この場合は`nightly`バージョン）をインストールする:"

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""
"特定の**branch**（この場合は`release/0.1.0`ブランチの最新コミット）をインス"
"トールする:"

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""
"**フォークのメインブランチ**（この場合は `tarrencev/dojo` のメインブランチ）"
"をインストールする:"

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""
"**フォークの特定のブランチをインストールする** (この場合は `tarrencev/dojo` "
"にある `patch-10` ブランチの最新コミット)："

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr "**特定のPull Request**からインストールする："

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr "**特定のコミット**からインストールする:"

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/"
"dojo`, assuming you're in the home directory)"
msgstr ""
"ローカルディレクトリやリポジトリにインストールするには（ホームディレクトリに"
"いると仮定して、`~/git/dojo`にあるものなど）。"

#: src/toolchain/dojoup.md:66
#, fuzzy
msgid ""
"Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""
"注: -branch、—repo、—versionフラグは、ローカル・インストールでは無視される。"

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""
"**ヒント**： すべてのフラグには1文字の短縮形があります！バージョンの代わりに "
"`-v` を使うことができる。"

#: src/toolchain/dojoup.md:78
#, fuzzy
msgid "Precompiled binaries"
msgstr "コンパイル済みバイナリ"

#: src/toolchain/dojoup.md:80
#, fuzzy
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://"
"github.com/dojoengine/dojo/releases). These are better managed by using "
"[Dojoup](#using-dojoup)."
msgstr ""
"プリコンパイルされたバイナリは[GitHub releases page](https://github.com/"
"dojoengine/dojo/releases)から入手できます。これらは[Dojoup](#using-dojoup)を"
"使って管理するのが良いでしょう。"

#: src/toolchain/dojoup.md:84
msgid "ℹ️ **Note**"
msgstr "ℹ️ **注意**"

#: src/toolchain/dojoup.md:86
#, fuzzy
msgid ""
"If you're on Windows, you will need to install and use [Git BASH](https://"
"gitforwindows.org/) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install), as your terminal, since Dojoup currently does not support "
"Powershell or Cmd."
msgstr ""
"Windowsの場合、Dojoupは現在PowershellやCmdをサポートしていないため、ターミナ"
"ルとして[Git BASH](https://gitforwindows.org/)または[WSL](https://learn."
"microsoft.com/en-us/windows/wsl/install)をインストールして使用する必要があり"
"ます。"

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of World-"
"building. In the future, it may include a GUI."
msgstr ""
"`sozo`はDojoプロジェクトを管理するための強力なオールインワンツールです。新し"
"いプロジェクトの足場作りから、Dojo Worlds のデプロイやインタラクションに至る"
"まで、すべてを支援します。移行計画ツールも含まれており、AW の更新と展開を効率"
"化するように設計されています。堅牢なコマンドラインインターフェイス (CLI) を提"
"供し、World の管理タスクを簡素化することで、World 構築の創造的な側面に集中す"
"ることができます。将来的には、GUIも含まれるかもしれません。"

#: src/toolchain/sozo/overview.md:5 src/toolchain/katana/overview.md:5
#, fuzzy
msgid "Features"
msgstr "特徴"

#: src/toolchain/sozo/overview.md:7
#, fuzzy
msgid ""
"**Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""
"**バイナリCLI**: Sozoは直感的なバイナリCLIを提供し、既存のWorldの更新や新しい"
"Worldのデプロイなど、Worldを簡単に管理できます。"

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
#, fuzzy
msgid "Installation"
msgstr "インストール"

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-"
"start.md), our dedicated installation package manager."
msgstr ""
"`sozo`バイナリは、専用のインストールパッケージマネージャである[`dojoup`]"
"(../../getting-started/quick-start.md)からインストールすることができます。"

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
#, fuzzy
msgid "Installing from Source"
msgstr "ソースからのインストール"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install —path ./crates/sozo —locked —force\n"
"```"

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr ""
"これにより、Sozoと必要な依存関係がローカルシステムにインストールされます。"

#: src/toolchain/sozo/overview.md:23 src/toolchain/katana/overview.md:60
#: src/toolchain/torii/overview.md:28
msgid "📚 **Reference**"
msgstr "📚 **参考**"

#: src/toolchain/sozo/overview.md:25
#, fuzzy
msgid ""
"See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""
"利用可能なすべてのサブコマンドの完全な概要については、[`sozo` Reference](./"
"reference.md)を参照してください。"

#: src/toolchain/sozo/reference.md:1
#, fuzzy
msgid "sozo reference"
msgstr "sozoリファレンス"

#: src/toolchain/sozo/reference.md:3
#, fuzzy
msgid "Project Commands"
msgstr "Project Commands"

#: src/toolchain/sozo/reference.md:5
msgid "[init](./project-commands/init.md)"
msgstr "[init](./project-commands/init.md)"

#: src/toolchain/sozo/reference.md:6
msgid "[build](./project-commands/build.md)"
msgstr "[build](./project-commands/build.md)"

#: src/toolchain/sozo/reference.md:7
msgid "[test](./project-commands/test.md)"
msgstr "[test](./project-commands/test.md)"

#: src/toolchain/sozo/reference.md:8
msgid "[migrate](./project-commands/migrate.md)"
msgstr "[migrate](./project-commands/migrate.md)"

#: src/toolchain/sozo/reference.md:10
#, fuzzy
msgid "World Commands"
msgstr "World Commands"

#: src/toolchain/sozo/reference.md:12
msgid "[execute](./world-commands/execute.md)"
msgstr "[execute](./world-commands/execute.md)"

#: src/toolchain/sozo/reference.md:13
msgid "[register](./world-commands/register.md)"
msgstr "[register](./world-commands/register.md)"

#: src/toolchain/sozo/reference.md:14
msgid "[system](./world-commands/system.md)"
msgstr "[system](./world-commands/system.md)"

#: src/toolchain/sozo/reference.md:15
msgid "[component](./world-commands/component.md)"
msgstr "[component](./world-commands/component.md)"

#: src/toolchain/sozo/reference.md:16
msgid "[events](./world-commands/events.md)"
msgstr "[events](./world-commands/events.md)"

#: src/toolchain/sozo/reference.md:17
msgid "[auth](./world-commands/auth.md)"
msgstr "[auth](./world-commands/auth.md)"

#: src/toolchain/sozo/project-commands/init.md:1
#, fuzzy
msgid "sozo init"
msgstr "sozo init"

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."
msgstr ""
"`init`は新しいプロジェクトを初期化するために使用します。dojo-starter]"
"(https://github.com/dojoengine/dojo-starter)をクローンすることで、カレント"
"ディレクトリに新しいプロジェクトを初期化します。"

#: src/toolchain/sozo/project-commands/build.md:1
#, fuzzy
msgid "sozo build"
msgstr "sozo build"

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""
"`build` は cairo のコントラクトをコンパイルするために使われ、デプロイに必要な"
"成果物を生成する。"

#: src/toolchain/sozo/project-commands/test.md:1
#, fuzzy
msgid "sozo test"
msgstr "sozo test"

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""
"`test` はプロジェクトの cairo 契約をテストするために使われる。プロジェクト内"
"で見つかったすべてのテストを実行する。"

#: src/toolchain/sozo/project-commands/migrate.md:1
#, fuzzy
msgid "sozo migrate"
msgstr "sozo migrate"

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""
"`migrate`はマイグレーション（デプロイメント）プロセスを実行するために使用さ"
"れ、ワールドをデプロイまたはアップデートするために必要なコントラクトを宣言"
"し、デプロイする。"

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""
"最初のデプロイ後にローカルワールドに加えた変更は、`sozo migrate —world "
"<WORLD_ADDRESS>`（`WORLD_ADDRESS`はリモートワールドのアドレス）を実行すること"
"で、簡単にリモートワールドにプッシュすることができます。バックグラウンドで "
"`migrate` はローカルワールドとリモートワールドの差分を計算し、ローカルワール"
"ドのどの部分を上流にプッシュする必要があるかを判断するために、マイグレーショ"
"ン戦略の構築を開始します。"

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7
#, fuzzy
msgid "USAGE"
msgstr "USAGE"

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105 src/toolchain/torii/reference.md:33
msgid "OPTIONS"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107 src/toolchain/torii/reference.md:35
#, fuzzy
msgid "General Options"
msgstr "General Options"

#: src/toolchain/sozo/project-commands/migrate.md:17
#, fuzzy
msgid ""
"`--name` _NAME_  \n"
"    Name of the World. At the moment, the only usage for this option is to "
"be used as a salt when deploying the World contract to avoid address "
"conflicts. This option is **required** when performing the initial migration "
"of the World."
msgstr ""
"`—name` _NAME_  \n"
"    Name of the World. At the moment, the only usage for this option is to "
"be used as a salt when deploying the World contract to avoid address "
"conflicts. This option is **required** when performing the initial migration "
"of the World."

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
#, fuzzy
msgid "World Options"
msgstr "World Options"

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
#, fuzzy
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"    The address of the World contract.  \n"
"    ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""
"`—world` _WORLD_ADDRESS_  \n"
"    The address of the World contract.  \n"
"    ENV: `DOJO_WORLD_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
#, fuzzy
msgid "Starknet Options"
msgstr "Starknet Options"

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
#, fuzzy
msgid ""
"`--rpc-url` _URL_  \n"
"    The Starknet RPC endpoint. \\[default: http://localhost:5050\\]  \n"
"    ENV: `STARKNET_RPC_URL`"
msgstr ""
"`—rpc-url` _URL_  \n"
"    The Starknet RPC endpoint. \\[default: http://localhost:5050\\]  \n"
"    ENV: `STARKNET_RPC_URL`"

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
#, fuzzy
msgid "Account Options"
msgstr "Account Options"

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
#, fuzzy
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"    The Starknet account address.  \n"
"    ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""
"`—account-address` _ACCOUNT_ADDRESS_  \n"
"    The Starknet account address.  \n"
"    ENV: `DOJO_ACCOUNT_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
#, fuzzy
msgid "Signer Options - Raw"
msgstr "Signer Options - Raw"

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
#, fuzzy
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"    The raw private key associated with the account contract.  \n"
"    ENV: `DOJO_PRIVATE_KEY`"
msgstr ""
"`—private-key` _PRIVATE_KEY_  \n"
"    The raw private key associated with the account contract.  \n"
"    ENV: `DOJO_PRIVATE_KEY`"

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
#, fuzzy
msgid "Signer Options - Keystore"
msgstr "Signer Options - Keystore"

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
#, fuzzy
msgid ""
"`--keystore` _PATH_  \n"
"    Use the keystore in the given folder or file."
msgstr ""
"`—keystore` _PATH_  \n"
"    Use the keystore in the given folder or file."

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"    The keystore password. Used with --keystore.  \n"
"    ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:178 src/toolchain/katana/reference.md:186
msgid "EXAMPLES"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:55
#, fuzzy
msgid "Deploying your World for the first time to a local Katana node"
msgstr "ローカルKatanaノードに初めてWorldをデプロイする"

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:61
#, fuzzy
msgid "Updating a remote World after making some changes"
msgstr "変更後のリモートワールドの更新"

#: src/toolchain/sozo/world-commands/execute.md:1
#, fuzzy
msgid "sozo execute"
msgstr "sozo execute"

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr "`execute`はワールドのシステムを実行するために使われる。"

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""
"したがって、`execute`は、トランザクションを送信する前に、トランザクショ ンに"
"署名するために、アカウントアドレスとそれぞれの秘密鍵を必要とする。"

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"    The calldata to be passed to the system that you want to execute.  \n"
"    Comma seperated values e.g., 0x12345,0x69420."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:56
#, fuzzy
msgid ""
"Executing the _position_ system which takes two values (_x_: 0x77 and _y_: "
"0x44)"
msgstr "2つの値（_x_: 0x77、_y_: 0x44）を取る_position_システムを実行する。"

#: src/toolchain/sozo/world-commands/register.md:1
#, fuzzy
msgid "sozo register"
msgstr "sozo test"

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:1
#, fuzzy
msgid "sozo system"
msgstr "sozo test"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""
"`system`はワールドのシステムとやり取りするために使われる。システムの情報を問"
"い合わせるのに便利である。"

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "SUBCOMMANDS"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "`get`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr "システムのクラス・ハッシュを取得する"

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "Arguments"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid ""
"_`NAME`_  \n"
"    The name of the system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:30
msgid "`dependency`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr "システムのコンポーネント依存関係を取得します"

#: src/toolchain/sozo/world-commands/system.md:59
#, fuzzy
msgid "Get the class hash of the _spawn_ system"
msgstr "_spawn_システムのクラスハッシュを取得する。"

#: src/toolchain/sozo/world-commands/system.md:65
#, fuzzy
msgid "Get the component dependencies of the _spawn_ system"
msgstr "_spawn_システムのコンポーネントの依存関係を取得します"

#: src/toolchain/sozo/world-commands/component.md:1
#, fuzzy
msgid "sozo component"
msgstr "コンポーネントの追加"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""
"`component`はワールドのコンポーネントと対話するために使用される。コンポーネン"
"トの情報やエンティティのコンポーネントの値を問い合わせるのに便利である。"

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr "コンポーネントのクラスハッシュを取得します"

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
#: src/toolchain/sozo/world-commands/component.md:54
#, fuzzy
msgid ""
"_`NAME`_  \n"
"    The name of the component"
msgstr ""
"_`NAME`_  \n"
"    コンポーネントの名前"

#: src/toolchain/sozo/world-commands/component.md:31
msgid "`schema`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr "コンポーネントのスキーマを取得する"

#: src/toolchain/sozo/world-commands/component.md:44
msgid "`entity`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr "エンティティのコンポーネント値を取得する"

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
"    The keys of the entity that you want to query.  \n"
"    Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:1
#, fuzzy
msgid "sozo events"
msgstr "sozo execute"

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr "`events`は世界の出来事を問い合わせるのに使われます。"

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "sozo auth"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr "`auth`は世界の認可を管理するために使われます。"

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""

#: src/toolchain/katana/overview.md:7
msgid ""
"[Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-specs/"
"tree/v0.3.0) support"
msgstr ""

#: src/toolchain/katana/overview.md:8
msgid "Custom methods for manipulating the blockchain states"
msgstr "ブロックチェーンの状態を操作するカスタム・メソッド"

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via [`dojoup`](../../getting-started/quick-"
"start.md)."
msgstr ""

#: src/toolchain/katana/overview.md:14
#, fuzzy
msgid "Installing from source"
msgstr "ソースからのインストール"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:62
#, fuzzy
msgid ""
"See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""
"Katanaの詳細なリファレンスとドキュメントについては、[`katana` Reference](./"
"reference.md)を参照してください。"

#: src/toolchain/katana/reference.md:1
#, fuzzy
msgid "katana reference"
msgstr "torii リファレンス"

#: src/toolchain/katana/reference.md:3
msgid "NAME"
msgstr ""

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr ""
"katana - Starknetスマートコントラクトをデプロイしてテストするためのローカルテ"
"ストネットノードを作成する。"

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
msgid "DESCRIPTION"
msgstr ""

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"Starknetスマートコントラクトをデプロイしてテストするためのローカルテストネッ"
"トノードを作成する。Katanaは**新しい**だけでなく、**レガシー**（Cairo 0）"
"Cairoコントラクトのデプロイと実行もサポートしている。"

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""
"このセクションでは、採掘モード、サポートされるRPCメソッド、Katanaフラグとその"
"使用方法に関する情報を幅広く紹介します。複数のフラグを同時に実行することがで"
"きます。"

#: src/toolchain/katana/reference.md:19
msgid "Mining Modes"
msgstr ""

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""
"Katanaでは、採掘モードがブロックの採掘頻度を決定する。デフォルトでは、トラン"
"ザクションが送信されるとすぐに新しいブロックが自動的に採掘される。"

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <MILLISECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""
"デフォルトのマイニング動作から、ユーザーが選択した一定の時間間隔で新しいブ"
"ロックを作成するインターバルマイニングに切り替えることができます。このマイニ"
"ングモードを有効にするには、次の例のように `—block-time <MILLISECONDS>` フラ"
"グを使用します。"

#: src/toolchain/katana/reference.md:30
#, fuzzy
msgid "Supported Transport Layers"
msgstr "Support Component types:"

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""
"現在のところ、HTTP接続のみがサポートされている。サーバーはデフォルトでポート"
"5050でリッスンするが、以下のコマンドを実行することで変更できる:"

#: src/toolchain/katana/reference.md:38
msgid "Starknet Feature Compatibility"
msgstr ""

#: src/toolchain/katana/reference.md:40
msgid "Supported Transaction Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Version"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "INVOKE"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "1"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "DECLARE"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "1, 2"
msgstr ""

#: src/toolchain/katana/reference.md:46
msgid "DEPLOY_ACCOUNT"
msgstr ""

#: src/toolchain/katana/reference.md:48
msgid "Supported RPC Methods"
msgstr ""

#: src/toolchain/katana/reference.md:50
#, fuzzy
msgid "Starknet Methods"
msgstr "Starknet Options"

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on [this](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katanaは、Starknet JSON-RPC仕様のバージョン**v0.3.0**をサポートしています。標"
"準メソッドは、[this](https://github.com/starkware-libs/starknet-specs/tree/"
"v0.3.0) リファレンスに基づいています。"

#: src/toolchain/katana/reference.md:54
msgid "`starknet_blockNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:55
msgid "`starknet_blockHashAndNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:56
msgid "`starknet_getBlockWithTxs`"
msgstr ""

#: src/toolchain/katana/reference.md:57
msgid "`starknet_getBlockWithTxHashes`"
msgstr ""

#: src/toolchain/katana/reference.md:58
msgid "`starknet_getBlockTransactionCount`"
msgstr ""

#: src/toolchain/katana/reference.md:59
msgid "`starknet_getTransactionByHash`"
msgstr ""

#: src/toolchain/katana/reference.md:60
msgid "`starknet_getTransactionByBlockIdAndIndex`"
msgstr ""

#: src/toolchain/katana/reference.md:61
msgid "`starknet_getTransactionReceipt`"
msgstr ""

#: src/toolchain/katana/reference.md:62
msgid "`starknet_pendingTransactions`"
msgstr ""

#: src/toolchain/katana/reference.md:63
msgid "`starknet_getStateUpdate`"
msgstr ""

#: src/toolchain/katana/reference.md:65
msgid "`starknet_call`"
msgstr ""

#: src/toolchain/katana/reference.md:66
msgid "`starknet_estimateFee`"
msgstr ""

#: src/toolchain/katana/reference.md:68
msgid "`starknet_chainId`"
msgstr ""

#: src/toolchain/katana/reference.md:70
msgid "`starknet_getNonce`"
msgstr ""

#: src/toolchain/katana/reference.md:71
msgid "`starknet_getEvents`"
msgstr ""

#: src/toolchain/katana/reference.md:72
msgid "`starknet_getStorageAt`"
msgstr ""

#: src/toolchain/katana/reference.md:73
msgid "`starknet_getClassHashAt`"
msgstr ""

#: src/toolchain/katana/reference.md:74
msgid "`starknet_getClass`"
msgstr ""

#: src/toolchain/katana/reference.md:75
msgid "`starknet_getClassAt`"
msgstr ""

#: src/toolchain/katana/reference.md:77
msgid "`starknet_syncing`"
msgstr ""

#: src/toolchain/katana/reference.md:79
msgid "`starknet_addInvokeTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:80
msgid "`starknet_addDeclareTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:81
msgid "`starknet_addDeployAccountTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:83
#, fuzzy
msgid "Custom Methods"
msgstr "Custom Events"

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""
"Katanaは、テスト環境に合わせてノードを迅速かつ簡単に設定するための便利なカス"
"タムRPCメソッドセットを提供します。"

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock`  \n"
"現在保留中のすべてのトランザクションを含む新しいブロックを生成する。"

#: src/toolchain/katana/reference.md:90
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`\n"
"次のブロックの時間を取得する。"

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`  \n"
"秒単位で指定された時間だけブロックの時間を増やす。"

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""
"` katana_setNextBlockTimestamp`\n"
"` katana_increaseNextBlockTimestamp` と似ているが、次のブロックに欲しい正確な"
"タイムスタンプを取る。"

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"katana_predeployedAccounts`  \n"
"すべてのプレデプロイアカウントの情報を取得します。"

#: src/toolchain/katana/reference.md:102
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""
"`katana_setStorageAt`  \n"
"コントラクトのストレージスロットの正確な値を設定する。"

#: src/toolchain/katana/reference.md:109
#, fuzzy
msgid ""
"`--silent`  \n"
"     Don't print anything on startup."
msgstr ""
"`—silent`  \n"
"     起動時に何も表示しない。"

#: src/toolchain/katana/reference.md:112
#, fuzzy
msgid ""
"`--no-mining`  \n"
"     Disable auto and interval mining, and mine on demand instead."
msgstr ""
"`—no-mining`  \n"
"     自動採掘とインターバル採掘を無効にし、代わりにオンデマンド採掘を行う。"

#: src/toolchain/katana/reference.md:115
#, fuzzy
msgid ""
"`-b, --block-time <MILLISECONDS>`  \n"
"     Block time in milliseconds for interval mining."
msgstr ""
"`-b, —block-time <MILLISECONDS>`  \n"
"     インターバルマイニングのブロック時間（ミリ秒）。"

#: src/toolchain/katana/reference.md:118
#, fuzzy
msgid ""
"`--dump-state <PATH>`  \n"
"     Dump the state of chain on exit to the given file.  \n"
"     If the value is a directory, the state will be written to `<PATH>/state."
"bin`."
msgstr ""
"`—dump-state <PATH>`  \n"
"     終了時のチェーンの状態を指定されたファイルにダンプする。 \n"
"     値がディレクトリの場合、状態は `<PATH>/state.bin` に書き込まれます。"

#: src/toolchain/katana/reference.md:122
#, fuzzy
msgid ""
"`--load-state <PATH>`  \n"
"     Initialize the chain from a previously saved state snapshot."
msgstr ""
"`—load-state <PATH>`  \n"
"      以前に保存した状態のスナップショットからチェーンを初期化する。"

#: src/toolchain/katana/reference.md:125
#, fuzzy
msgid ""
"`-h, --help`  \n"
"     Print help (see a summary with '-h')."
msgstr ""
"`-h, —help`  \n"
"     ヘルプを表示する（’-h’ で概要を見る）。"

#: src/toolchain/katana/reference.md:128
#, fuzzy
msgid ""
"`-V, --version`  \n"
"     Print version information."
msgstr ""
"`-V, —version`  \n"
"     プリントバージョン情報。"

#: src/toolchain/katana/reference.md:131
#, fuzzy
msgid "Server Options"
msgstr "General Options"

#: src/toolchain/katana/reference.md:133
#, fuzzy
msgid ""
"`-p, --port <PORT>`  \n"
"     Port number to listen on. \\[default: 5050\\]"
msgstr ""
"`-p, —port <PORT>`  \n"
"     Port number to listen on. \\[default: 5050\\]"

#: src/toolchain/katana/reference.md:136
#, fuzzy
msgid ""
"`--host <HOST>`  \n"
"     The IP address the server will listen on."
msgstr ""
"`—host <HOST>`  \n"
"     サーバーがリッスンするIPアドレス。"

#: src/toolchain/katana/reference.md:141
#, fuzzy
msgid ""
"`--seed <SEED>`  \n"
"     Specify the seed for randomness of accounts to be predeployed."
msgstr ""
"`—seed <SEED>`  \n"
"     事前に配置するアカウントのランダム性のシードを指定する。"

#: src/toolchain/katana/reference.md:144
#, fuzzy
msgid ""
"`--accounts <NUM>`  \n"
"     Number of pre-funded accounts to generate. \\[default: 10\\]"
msgstr ""
"`—accounts <NUM>`  \n"
"     生成する事前資金アカウント数。 \\[default: 10\\]"

#: src/toolchain/katana/reference.md:147
#, fuzzy
msgid ""
"`--disable-fee`  \n"
"     Disable charging fee for transactions."
msgstr ""
"`—disable-fee`  \n"
"     取引に手数料を課さない."

#: src/toolchain/katana/reference.md:150
#, fuzzy
msgid "Environment Options"
msgstr "Environment Options"

#: src/toolchain/katana/reference.md:152
#, fuzzy
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"     The chain ID. \\[default: KATANA\\]"
msgstr ""
"`—chain-id <CHAIN_ID>`  \n"
"     The chain ID. \\[default: KATANA\\]"

#: src/toolchain/katana/reference.md:155
#, fuzzy
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"     The gas price."
msgstr ""
"`—gas-price <GAS_PRICE>`  \n"
"     ガス代。"

#: src/toolchain/katana/reference.md:158
#, fuzzy
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account validation logic."
msgstr ""
"`—validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"     アカウント検証ロジックで使用可能な最大ステップ数。"

#: src/toolchain/katana/reference.md:161
#, fuzzy
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account execution logic."
msgstr ""
"`—invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"     アカウント実行ロジックで使用可能な最大ステップ数。"

#: src/toolchain/katana/reference.md:164
#, fuzzy
msgid "Shell Completions"
msgstr "Shell Completions"

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr "` katana` 完了シェル"

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr "指定されたシェルの補完スクリプトを生成します。"

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr "対応シェルは以下の通りです:"

#: src/toolchain/katana/reference.md:172
msgid "bash"
msgstr ""

#: src/toolchain/katana/reference.md:173
msgid "elvish"
msgstr ""

#: src/toolchain/katana/reference.md:174
msgid "fish"
msgstr ""

#: src/toolchain/katana/reference.md:175
msgid "powershell"
msgstr ""

#: src/toolchain/katana/reference.md:176
msgid "zsh"
msgstr ""

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr "`bash` 用のシェル補完スクリプトを生成し、`.bashrc` ファイルに追加する:"

#: src/toolchain/katana/reference.md:188
#, fuzzy
msgid "Create 15 dev accounts and disable transaction fee mechanism"
msgstr "15個の開発者アカウントを作成し、取引手数料の仕組みを無効にします"

#: src/toolchain/katana/reference.md:194
#, fuzzy
msgid "Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr "チェーンIDを`SN_GOERLI`に設定し、ポート8545でサーバーを実行します"

#: src/toolchain/katana/reference.md:200
#, fuzzy
msgid ""
"Load previously stored state and dump the state of this session to a file on "
"shutdown"
msgstr ""
"シャットダウン時に、以前に保存した状態をロードし、このセッションの状態をファ"
"イルにダンプ"

#: src/toolchain/torii/overview.md:1
msgid "Torii - Networking & Indexing"
msgstr ""

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""
"Toriiは、Dojoワールドのための自動インデクサーです。驚異的な速さと卓越したス"
"ケーラビリティを実現するために、Rustで構築されています。"

#: src/toolchain/torii/overview.md:5
#, fuzzy
msgid "Dojo indexer"
msgstr "Dojo indexer"

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""
"Torii はあなたの dojo ワールドにインデックスを作成し、それらをクエリするため"
"の GraphQL API を公開します。実行するだけです："

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr "で、GraphQL APIが `http://localhost:8080` で実行されていることになる！"

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/"
"quick-start.md), our dedicated installation package manager."
msgstr ""
"バイナリ `torii` は専用のインストールパッケージマネージャである [`dojoup`]"
"(../../getting-started/quick-start.md) からインストールすることができます。"

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "ソースコードからインストールしたい場合:"

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr ""
"これにより、Toriiと必要な依存関係がローカルシステムにインストールされます。"

#: src/toolchain/torii/overview.md:30
#, fuzzy
msgid "See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""
"完全なリファレンスは[`torii` Reference](./reference.md)を参照してください。"

#: src/toolchain/torii/reference.md:1
#, fuzzy
msgid "torii reference"
msgstr "torii リファレンス"

#: src/toolchain/torii/reference.md:3
msgid "Name"
msgstr ""

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr ""
"torii - Worldコントラクトのための自動インデクサーとネットワーキングレイヤー。"

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""
"`torii`はインデクサーを起動し、GraphQL/gRPC APIエンドポイントを公開する。イン"
"デクサーは指定されたStarknet RPCエンドポイントにトランザクションブロックを問"
"い合わせ、Worldコントラクトに関連するトランザクションをリッスンする。これらの"
"トランザクションには、コンポーネント/システムの登録、エンティティの状態更新、"
"システムコール、イベントなどが含まれる。解析されたデータは、ローカルのSQLite"
"データベースに格納されます。"

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""
"GraphQL および gRPC API エンドポイントは、インデクサーと連動して実行され、ク"
"ライアントアプリケーションにワールドコントラクトに特化したカスタムクエリを提"
"供する。"

#: src/toolchain/torii/reference.md:19
msgid "Database URL"
msgstr ""

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""
"`torii` はインデックス付きデータを格納するために sqlite データベースを使用す"
"る。データベースはインメモリまたはファイルシステムに永続的に保存することがで"
"きる。"

#: src/toolchain/torii/reference.md:23
#, fuzzy
msgid ""
"The in-memory database is ephermal and only lasts as long as the indexer is "
"running. This is a fast and simple option to start the indexer for "
"development/testing."
msgstr ""
"インメモリデータベースは熱的であり、インデクサが実行されている間だけ持続す"
"る。これは、開発/テスト用にインデクサを起動するための、高速でシンプルなオプ"
"ションです。"

#: src/toolchain/torii/reference.md:24
msgid ""
"Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""
"本番環境では、Presistent Storageを使用すべきである。ストレージはローカルの"
"ファイルシステムに依存します。"

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""
"注: メモリ内データベースを使用している場合、一定期間使用されないとメモリがガ"
"ベージコレクションされ、クエリがエラーになる。回避策としては、`—block-time` "
"オプションを指定して `katana` を起動するか、永続データベースを使用することで"
"ある。"

#: src/toolchain/torii/reference.md:37
#, fuzzy
msgid "`-w, --world`      Address of the world contract to index"
msgstr "`-w, —world`      インデックスを作成するWorldコントラクトのアドレス"

#: src/toolchain/torii/reference.md:40
#, fuzzy
msgid ""
"`--rpc`      Starknet RPC endpoing to use \\[default: http//localhost:5050\\]"
msgstr ""
"`—rpc`      Starknet RPC endpoing to use \\[default: http//localhost:5050\\]"

#: src/toolchain/torii/reference.md:43
#, fuzzy
msgid ""
"`-m, --manifest <MANIFEST>`      Specify a local manifest to initialize from"
msgstr ""
"`-m, —manifest <MANIFEST>`      初期化するローカル・マニフェストを指定します"

#: src/toolchain/torii/reference.md:46
#, fuzzy
msgid ""
"`-d, --database-url <DATABASE_URL>`      Database URL (read more above) "
"\\[default: sqlite::memory:\\]"
msgstr ""
"`-d, —database-url <DATABASE_URL>`      データベースのURL（詳しくは上記を参"
"照） \\[default: sqlite::memory:\\]"

#: src/toolchain/torii/reference.md:49
#, fuzzy
msgid ""
"`-s, --start-block <START_BLOCK>`      Specify a block to start indexing "
"from, ignored if stored head exists \\[default: 0\\]"
msgstr ""
"`-s, —start-block <START_BLOCK>`      インデックス作成を開始するブロックを指"
"定します \\[default: 0\\]"

#: src/toolchain/torii/reference.md:52
msgid "`-h, --help`      Print help"
msgstr "`-h, —help`      Printの表示"

#: src/toolchain/torii/reference.md:55
#, fuzzy
msgid "`-V, --version`      Print version"
msgstr "`-h, —help`      Printの表示"

#: src/deployment/locally.md:1
#, fuzzy
msgid "Deploying Locally"
msgstr "ローカルでのデプロイ"

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""
"Dojoは迅速な開発のために設計されており、[Katana](./toolchain/katana/overview."
"md)という光速のローカル開発環境を誇ります。Katanaはデバイス上のStarknetブロッ"
"クチェーンとして機能し、リモートテストネットに移行する前にスマートコントラク"
"トを厳密にテストすることができます。"

#: src/deployment/locally.md:5
#, fuzzy
msgid "Katana Deployments"
msgstr "Katanaのデプロイ"

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr "Katanaへのデプロイはこれ以上ないほど簡単です。"

#: src/deployment/locally.md:9
#, fuzzy
msgid ""
"This assumes you have followed the [Quick Start](./getting-started/quick-"
"start.md) guide and have a project initialized."
msgstr ""
"これは、[クイック・スタート](./getting-started/quick-start.md)ガイドに従い、"
"プロジェクトを初期化していることを前提としています。"

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr "プロジェクト・ディレクトリから実行します:"

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr "これでローカルのKatanaが開始され、デプロイできるようになりました!"

#: src/deployment/locally.md:19
#, fuzzy
msgid "Deploying to Katana"
msgstr "Katanaへのデプロイ"

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr "プロジェクトをKatanaにデプロイするには、以下を実行します:"

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""
"注意 - これは、コントラクトをコンパイルしている場合にのみ機能します。コンパイ"
"ルしていない場合は:"

#: src/deployment/remote.md:1
#, fuzzy
msgid "Deployment to Remote Network"
msgstr "リモートネットワークへのデプロイ"

#: src/deployment/remote.md:3
#, fuzzy
msgid "_IMPORTANT: Dojo is unaudited. Use at your own risk._"
msgstr ""
"_重要：Dojoはソースコードがまだ未監査です。自己責任で使用してください._"

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""
"Dojoでは、有効なアカウントとネットワークエンドポイントがあれば、リモートネッ"
"トワークに簡単に配備できます。"

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr "Scarb.toml"

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"“0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0”\n"
"# private_key = "
"“0x0300001800000000300000180000000000030000000000003006001800006600”\n"
"\n"
"#Madara\n"
"rpc_url = “https://api.cartridge.gg/x/shinai/madara”\n"
"account_address = “0x2”\n"
"private_key = "
"“0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d”\n"
"#world_address = "
"“0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201”\n"
"```"

#: src/deployment/remote.md:33
msgid "Remote Katana"
msgstr ""

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""
"Katanaはリモート・テストネットとしてホスティングして実行することができます"
"が、本番環境での使用はお勧めできません。"

#: src/deployment/remote.md:37
#, fuzzy
msgid "**todo**: add instructions for deploying to remote katana"
msgstr "**todo**: リモートのKatanaにデプロイする手順を追加"

#: src/deployment/remote.md:40
msgid "Madara"
msgstr ""

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara)は、非常に高速な"
"Starknetシーケンサーです。堅牢なSubstrateフレームワーク上に構築され、Rust 🦀"
"のおかげで高速に動作するMadaraは、StarknetベースのValidity Rollupチェーンに比"
"類ないパフォーマンスとスケーラビリティを提供します。"

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr "マダラのテストネットが公開されている:"

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr "**テストネットRPC:** https://api.cartridge.gg/x/shinai/madara"

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr "デプロイには以下のアカウントを使用できます:"

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""
"```toml\n"
"# …rest of Scarb.toml\n"
"\n"
"rpc_url = “https://api.cartridge.gg/x/shinai/madara”\n"
"account_address = “0x2”\n"
"private_key = "
"“0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d”\n"
"```"

#: src/deployment/remote.md:59
#, fuzzy
msgid "Starknet"
msgstr "Starknet Options"

#: src/deployment/remote.md:61
#, fuzzy
msgid "**todo**: add instructions for deploying to remote Starknet"
msgstr "**todo**: リモートのStarknetへのデプロイ方法を追加"

#: src/tutorial/onchain-chess/index.md:1
#, fuzzy
msgid "Building a Chess Game"
msgstr "チェスゲームを作る"

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr "_”Dojo bookを読み終わりました。次は何をすればいいですか？_"

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""
"この質問に対する答えはいつも「何かを作ろう！」であり、その後にクールなプロ"
"ジェクトのリストが続くこともある。これはある人にとっては素晴らしい答えだが、"
"もう少し方向性を知りたい人もいるだろう。"

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""
"このガイドは、初心者向けチュートリアルとプロジェクト作業の間のギャップを埋め"
"ることを目的としています。ここでの第一の目標は、コードを書かせることです。第"
"二の目標は、ドキュメントを読んでもらうことです。"

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""
"もしまだDojo bookを読んでいないのであれば、このプロジェクトを始める前に読んで"
"おくことを強くお勧めします。"

#: src/tutorial/onchain-chess/index.md:11
#, fuzzy
msgid "What are we building?"
msgstr "何を作るのか？"

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""
"私たちは、新しいゲームを始めてチェスをすることができるオンチェーンチェスゲー"
"ム契約を構築しています。このガイドは、チェスゲームのすべてのルールをカバーし"
"ているわけではありません。以下のようにステップ・バイ・ステップで構築していき"
"ます："

#: src/tutorial/onchain-chess/index.md:15
msgid "A system to spawn all the chess pieces"
msgstr "すべてのチェスの駒を生み出すシステム"

#: src/tutorial/onchain-chess/index.md:16
msgid "A system to make pieces move"
msgstr "駒を動かすシステム"

#: src/tutorial/onchain-chess/index.md:17
msgid "Add some functions to check a legal move"
msgstr "合法的な手をチェックする関数を追加"

#: src/tutorial/onchain-chess/index.md:18
msgid "Play chess ♟♙ - integration test!"
msgstr "チェスをする♟♙ - 統合テスト！"

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/"
"rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""
"チュートリアルの全コードは[this repo](https://github.com/rkdud007/chess-dojo/"
"tree/tutorialv2)に基づいています。"

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""
"もしこれが難しすぎると感じても、心配しないでください！このガイドは初心者向け"
"です。CairoとDojoについての基本的な知識があれば大丈夫です。すべてのルールの"
"チェスゲームは作りません。シンプルにします。"

#: src/tutorial/onchain-chess/index.md:24
#, fuzzy
msgid "What after this guide?"
msgstr "このガイドの後は？"

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""
"フロントエンドのデザインに役立つ別のガイドを作っている。これで私たちのチェス"
"は完成する。"

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr "5つの章をすべて終えたら、フロントエンドのガイドに移ることができる。"

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-"
"dojo.md) chapter to gain a basic understanding of the Dojo game._"
msgstr ""
"_始める前に、[`hello-dojo`](../../cairo/hello-dojo.md)の章を読んで、Dojoゲー"
"ムの基本を理解することをお勧めします。_"

#: src/tutorial/onchain-chess/0-setup.md:5
#, fuzzy
msgid "Initializing the Project"
msgstr "プロジェクトの初期化"

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""
"新しいDojoプロジェクトフォルダを作成します。プロジェクトには好きな名前を付け"
"ることができます。"

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr "プロジェクトフォルダを開く。"

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr "そしてsozo initを使ってプロジェクトを初期化します。"

#: src/tutorial/onchain-chess/0-setup.md:25
#, fuzzy
msgid "Cleaning Up the Boilerplate"
msgstr "定型文の整理"

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""
"プロジェクトには多くの定型コードが付属しています。それをすべて取り除きます。"
"`components.cairo` と `systems.cairo` の両方のファイルが空であることを確認す"
"る。"

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr "プロジェクトをコンパイルする:"

#: src/tutorial/onchain-chess/0-setup.md:42
#, fuzzy
msgid "Basic components"
msgstr "コンポーネントの追加"

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""
"ECSモデルを使ってチェスゲームをデザインする方法はたくさんあるが、ここではこの"
"方法に従うことにする:"

#: src/tutorial/onchain-chess/0-setup.md:46
#, fuzzy
msgid ""
"Every square of the chess board (e.g., A1) will be treated as an entity. If "
"a piece exists on a square, the square entity will hold that piece."
msgstr ""
"チェス盤の各マス（例えばA1）は、エンティティとして扱われる。あるマスに駒が存"
"在すれば、そのマスのエンティティがその駒を保持する。"

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this [chapter]"
"(../../cairo/components.md)."
msgstr ""
"まず、この基本コンポーネントを `components.cairo` ファイルに追加する。Dojo エ"
"ンジンのコンポーネント構文に慣れていない場合は、この [章](../../cairo/"
"components.md) に戻ってください。"

#: src/tutorial/onchain-chess/0-setup.md:78
#, fuzzy
msgid "Basic systems"
msgstr "Cairo"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""
"次の章からは、`initiate`システムと`move`システムを各章で1つずつ実装することに"
"なる。モジュール性を良くするために、それぞれのシステムをそれぞれのファイルに"
"作成しよう。"

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""
"`src` に `systems` フォルダを作成しましょう。その中に `initiate.cairo` と "
"`move.cairo` という 2 つのファイルを作ります。それぞれのファイルには基本的な"
"システム構造を記述します。"

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr "例えば、`initiate.cairo`は次のようになります:"

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr "そして、`systems.cairo` で `initiate_system` を次のように使います:"

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr "他のシステムも同様にする。`systems.cairo`を更新します:"

#: src/tutorial/onchain-chess/0-setup.md:111
#, fuzzy
msgid "Compile your project"
msgstr "プロジェクトをコンパイルする"

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr "では、`sozo build`でビルドしてみてください。エラーに直面しましたか？"

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr "そのような場合は、deriveとして実装することができます:"

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr "素晴らしい！では、このエラーを解決しましょう。"

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""
"一つ確認しておかなければならないのは、`<Option<PieceType>>`は我々が作成した型"
"であるということだ。つまり、この型はSerdeLenのような基本的な特徴を実装してい"
"ない。自分で実装を定義する必要がある。"

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""
"その他の問題を上記のように修正し、`sozo build`コマンドが正常に実行できるよう"
"にする。"

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "Run test"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""
"次の章に進む前に、`sozo build`と`sozo test`はコードが正しいことを確認するため"
"の重要なステップであることを覚えておいてほしいです。"

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr "まずsozoテストを実行してください。エラーはありましたか？"

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""
"実装されていないエラーについては、PrintTraitを実装してsozoテストを正常に実行"
"してください。ドロップされないエラーに対しては、DropTraitを追加します。その他"
"のエラーについては、deriveを追加するか、ケースバイケースで実装してください。"

#: src/tutorial/onchain-chess/0-setup.md:189
#, fuzzy
msgid "Add more components"
msgstr "コンポーネントの追加"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""
"次に進む前に、次の章でシステムを作るときに使えるように、コンポーネントを追加"
"しておこう。"

#: src/tutorial/onchain-chess/0-setup.md:193
#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
#, fuzzy
msgid "Requirements"
msgstr "必要条件"

#: src/tutorial/onchain-chess/0-setup.md:195
#, fuzzy
msgid "`Color` enum enum with values White and Black"
msgstr "白と黒の値を持つ `Color` 列挙型 enum"

#: src/tutorial/onchain-chess/0-setup.md:196
#, fuzzy
msgid "`Game` component:"
msgstr "`GameTurn`コンポーネント:"

#: src/tutorial/onchain-chess/0-setup.md:205
#, fuzzy
msgid "`GameTurn` component:"
msgstr "`GameTurn`コンポーネント:"

#: src/tutorial/onchain-chess/0-setup.md:212
#, fuzzy
msgid ""
"We will later set game entity composed of the `Game` and `GameTurn` "
"components."
msgstr ""
"後ほど、`Game`コンポーネントと`GameTurn`コンポーネントからなるゲーム実体を設"
"定する。"

#: src/tutorial/onchain-chess/0-setup.md:213
msgid "Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""
"`sozo build` と `sozo test` を実行し、すべてのテストがパスすることを確認す"
"る。"

#: src/tutorial/onchain-chess/0-setup.md:215
msgid ""
"Try to solve on your own, and before you move on check the answer below."
msgstr "自力で解いてみて、次に進む前に下の答えを確認してください。"

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr ""
"おめでとうございます！オンチェ-ンチェスゲームを構築するための基本的なセット"
"アップが完了しました🎉"

#: src/tutorial/onchain-chess/1-initiate.md:1
#, fuzzy
msgid "1. Initiate System"
msgstr "`initiate_system`とは何か？"

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""
"この章では `initiate_system` の実装について述べます。またこのシステムはゲーム"
"と駒を含むマスを生成します。"

#: src/tutorial/onchain-chess/1-initiate.md:5
#, fuzzy
msgid "What is `initiate_system`?"
msgstr "`initiate_system`とは何か？"

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""
"チェスをするには、ゲームを開始し、駒をスポーンする必要がある。"
"`initiate_system`がゲーム実体を生成し、各駒を適切な位置に配置する。ゲームス"
"テータスが正しい駒の種類と一致し、正しい色の駒が盤上の指定された位置にあるこ"
"とを確認する。"

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"initiate.cairo` file._"
msgstr ""
"_以下のユニットテストをコピーして、`systems/initiate.cairo` ファイルの一番下"
"に貼り付ける_"

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input."
msgstr ""
"このworld contextとwhite addressとblack addressを入力とする `execute` 関数を"
"システムに書く。"

#: src/tutorial/onchain-chess/1-initiate.md:17
msgid ""
"Implement the game entity, comprised of the `Game` component and `GameTurn` "
"component we created in the previous step."
msgstr ""
"前のステップで作成した `Game` コンポーネントと `GameTurn` コンポーネントで構"
"成されるゲームエンティティを実装します。"

#: src/tutorial/onchain-chess/1-initiate.md:18
msgid ""
"Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`."
msgstr ""
"正しい `PieceType` を含む a1 から h8 までの `Square` コンポーネントによって正"
"方形の実体を実装します。"

#: src/tutorial/onchain-chess/1-initiate.md:19
msgid "Run `sozo test` and pass all the tests."
msgstr "`sozoテスト`を実行し、すべてのテストに合格する。"

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "Test Flow"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"Spawn the test world that imports the components and systems used in testing."
msgstr ""
"テストに使用するコンポーネントやシステムをインポートするテストワールドを生成"
"します。"

#: src/tutorial/onchain-chess/1-initiate.md:24
msgid ""
"Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs."
msgstr ""
"`initiate_system` をwhiteとblack playerのウォレットアドレスを入力して実行しま"
"す。"

#: src/tutorial/onchain-chess/1-initiate.md:25
msgid ""
"Retrieve the game entity and piece entity created during `initiate_system`."
msgstr ""
"`initiate_system`で作成したゲームエンティティと駒エンティティを取得する。"

#: src/tutorial/onchain-chess/1-initiate.md:26
msgid "Ensure the game has been correctly created."
msgstr "ゲームが正しく作成されていることを確認します。"

#: src/tutorial/onchain-chess/1-initiate.md:27
msgid "Verify that each `Piece` is located in the correct `Square`."
msgstr "それぞれの`Piece`が正しい`Square`に配置されていることを確認します。"

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
#, fuzzy
msgid "Unit Tests"
msgstr "ユニットテストを書く"

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
#, fuzzy
msgid "Need help?"
msgstr "お困りですか？"

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community]"
"(https://discord.gg/akd2yfuRS3)!"
msgstr ""
"もし行き詰まったら、遠慮なく[Dojo community](https://discord.gg/akd2yfuRS3)で"
"質問してください!"

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) for chapter 1 here."
msgstr ""
"第1章の[答え](https://github.com/rkdud007/chess-dojo/blob/tutorialv2/src/"
"systems/initiate.cairo)はこちら。"

#: src/tutorial/onchain-chess/2-move.md:1
msgid "2. Move System"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr "この章では、盤上の駒を再配置する `move_system` の実装を取り上げる。"

#: src/tutorial/onchain-chess/2-move.md:5
#, fuzzy
msgid "What is `move_system`?"
msgstr "`move_system`とは何か？"

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""
"チェスをするには、ボード上の駒を動かす必要がある。駒の位置を正方形のエンティ"
"ティで表現するので、`move_system`は現在の位置を(x,y)として取得する。また、次"
"の位置を(x,y)として取得し、現在の位置の正方形にある駒を次の位置に移動させる対"
"象として扱う。"

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"move.cairo` file._"
msgstr ""
"_以下のユニットテストをコピーして、`systems/move.cairo` ファイルの一番下に貼"
"り付ける。_"

#: src/tutorial/onchain-chess/2-move.md:13
#, fuzzy
msgid "Write an `execute` function in the system with the following inputs:"
msgstr "以下の入力を持つ `execute` 関数をシステムに書いてください:"

#: src/tutorial/onchain-chess/2-move.md:25
#, fuzzy
msgid ""
"Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece."
msgstr ""
"`next_position`を持つ正方形を更新して新しいピースを入れ、`curr_position`を持"
"つ正方形にピースが入らないようにする。"

#: src/tutorial/onchain-chess/2-move.md:27
msgid "Run `sozo test` and ensure all tests pass."
msgstr "`sozo test`を実行し、すべてのテストがパスすることを確認する。"

#: src/tutorial/onchain-chess/2-move.md:31
msgid "Follow the same logic as `test_initiate` from the previous chapter."
msgstr "前章の `test_initiate` と同じロジックに従う。"

#: src/tutorial/onchain-chess/2-move.md:32
msgid "Move the White Knight from (1,0) to (2,2) using the `move_system`."
msgstr "`move_system`を使ってWhite Knightを(1,0)から(2,2)に移動させる。"

#: src/tutorial/onchain-chess/2-move.md:33
msgid ""
"Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr "更新された位置を取得し、駒が新しい位置に正常に移動したことを確認する。"

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr "この章では、チェックするための関数を作る："

#: src/tutorial/onchain-chess/3-legal.md:5
msgid "If the next move goes outside the board."
msgstr "次の手がボードの外に出た場合。"

#: src/tutorial/onchain-chess/3-legal.md:6
msgid "If there's a piece that can be captured."
msgstr "捕獲できるピースがある場合。"

#: src/tutorial/onchain-chess/3-legal.md:7
msgid "If the next move is allowed for the type of piece."
msgstr "駒の種類によって次の手が許されている場合。"

#: src/tutorial/onchain-chess/3-legal.md:8
msgid "If the user can allow to make a action (based on the piece's color)."
msgstr ""
"ユーザーが（ピースの色に基づいて）アクションを起こすことを許可するかどうかの"
"場合。"

#: src/tutorial/onchain-chess/3-legal.md:9
msgid "... You can also add other custom check functions."
msgstr "… その他のカスタムチェック機能を追加することもできます。"

#: src/tutorial/onchain-chess/3-legal.md:11
#, fuzzy
msgid "Make Check Functions"
msgstr "チェック機能の作成"

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""
"`move_system`にいくつかのチェック関数を追加する必要がある。これらは次の手が許"
"可されていることを確認するのに役立つ。"

#: src/tutorial/onchain-chess/3-legal.md:15
#, fuzzy
msgid "See if the next spot is allowed for the type of piece moving."
msgstr "移動する駒の種類によって、次の場所が許可されているかどうかを確認する。"

#: src/tutorial/onchain-chess/3-legal.md:23
#, fuzzy
msgid "See if the next spot is still on the board."
msgstr "次のスポットがまだあるかどうかを確認する。"

#: src/tutorial/onchain-chess/3-legal.md:29
#, fuzzy
msgid ""
"See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""
"その動きを試している人が、正しいタイミングで、自分の駒の色でやっているかどう"
"かを確認する。"

#: src/tutorial/onchain-chess/3-legal.md:35
#, fuzzy
msgid ""
"You can also add other check functions to be extra sure the move is allowed."
msgstr ""
"また、他のチェック機能を追加して、移動が許可されているかどうかをさらに確認す"
"ることもできる。"

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""
"これらのチェック関数を作ったら、メインの `move_system` 関数の中で使うことがで"
"きる。どのように設定するか、どれを使うかは自分で決めることができる。例を挙げ"
"て説明しましょう:"

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:85
#, fuzzy
msgid "Testing Each Function"
msgstr "各機能のテスト"

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""
"さまざまなチェック関数があるので、それぞれをテストする必要がある。これを簡単"
"にするために、多くのテストに同じパーツを使いましょう。"

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""
"まず、`init_world_test`というヘルパー関数を作る。これは `IWorldDispatcher` を"
"返すもので、移動システムのテストで何度も使うことができる。"

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr "そうすれば、メインの `test_move` 関数はもっとシンプルになる。"

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""
"これで、許可されていない動きを試すとエラーを表示するテストを作ることができ"
"る。test_piecetype_illegal`関数を作ってみよう。これはムーブシステムで実装し"
"た `is_right_piece_move` 関数が正しく動作するかどうかをチェックする。"

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""
"最後にテストを行う。これらのテストは、間違った動きを見つけてエラーを返すはず"
"だ。"

#: src/tutorial/onchain-chess/4-test.md:1
#, fuzzy
msgid "4. Test Contract"
msgstr "World Contract"

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""
"この章では、これまで学んだことをすべて使って、チェスゲームのシナリオを実行す"
"る。"

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr "テストはこのようになります:"

#: src/tutorial/onchain-chess/4-test.md:7
msgid "Spawn `white_pawn_1` to (0,1)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:8
msgid "Move `white_pawn_1` to (0,3)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:9
msgid "Move `black_pawn_2` to (1,6)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:10
msgid "Move `white_pawn_1` to (0,4)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:11
msgid "Move `black_pawn_2` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:12
msgid "Move `white_pawn_1` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:13
msgid "Capture `black_pawn_2`"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""
"駒を配置するには `initiate_system` を使う。駒を移動させるには `move_system` "
"を使用する。move_system`を使用する際には、駒が捕獲可能かどうかをチェックする"
"ことを忘れないこと。"

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr "コードに入る前に、統合テストを次のようにセットアップする："

#: src/tutorial/onchain-chess/4-test.md:19
msgid "Copy the test below and add it to your `src/tests.cairo` file."
msgstr "以下のテストをコピーして `src/tests.cairo` ファイルに追加する。"

#: src/tutorial/onchain-chess/4-test.md:20
#, fuzzy
msgid ""
"Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""
"このsrc に `test.cairo` を作り、`mod tests;` 行を追加して `lib.cairo` を更新"
"する。"

#: src/tutorial/onchain-chess/4-test.md:22
msgid "Full Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:143
#, fuzzy
msgid "Diving into the Code"
msgstr "Diving into the Code"

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr "まず、選手とその色を設定する。"

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""
"コンポーネントとシステムの両方を、それぞれCLASS_HASHを要素とする配列でリスト"
"する必要がある。"

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr "次に、ゲームの世界を作ります。"

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""
"`initiate_system`を使ってボード上に正方形の駒を置く。それぞれの正方形には駒が"
"置かれている。システムの実行関数には入力が必要で、それをcalldataとして与え"
"る。"

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""
"白のポーンが(0,1)にいるかどうか調べてみよう。そのマスに存在する駒を取得するに"
"は、`Square`コンポーネントのキー（`game_id`, `x`, `y`）を使用する必要があるこ"
"とを覚えておこう。黒ポーンについても同様のチェックを行う。"

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""
"碁盤をセットアップしたら、`move_system` を使って手を打つ。現在のポジション、"
"次のポジション、プレイヤーのアドレス、ゲームIDを指定する。"

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr "駒を動かして、正しい位置にあるかどうかをチェックし続ける。"

#: src/tutorial/onchain-chess/4-test.md:212
#, fuzzy
msgid "Congratulations!"
msgstr "おめでとうございます！"

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""
"Dojoエンジンを使ってチェスゲームの基本的なコントラクトを作りました！この"
"チュートリアルは始まりにすぎません。部分的な最適化、チェックの追加、特殊な"
"ケースの検討など、ゲームをより良くする方法はたくさんあります。このチェスゲー"
"ムでもっといろいろなことをやってみたいなら、以下の課題に挑戦してみてくださ"
"い："

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient."
msgstr ""
"遅延 init を使用する `initiate_system` を作成する。もしlazy initについてよく"
"わからないなら、[read up on it](https://en.wikipedia.org/wiki/"
"Lazy_initialization)を読んでください。これはあなたのゲームアクションをより効"
"率的にするのに役立ちます。"

#: src/tutorial/onchain-chess/4-test.md:217
msgid ""
"Add a checkmate feature. Our game doesn't end now, so decide when it should!"
msgstr ""
"チェックメイト機能を追加します。私たちのゲームは今終わらないため、いつ終わる"
"べきかを決めるべきです！"

#: src/tutorial/onchain-chess/4-test.md:218
msgid ""
"Include special moves like castling, En Passant Capture, or Pawn Promotion."
msgstr "CastlingやEn Passant CaptureとPawn Promoのような特別な動きを含む。"

#: src/tutorial/onchain-chess/4-test.md:219
msgid ""
"Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""
"自分だけのチェスのルールを作ろう！[immortal game](https://immortal.game/)の自"
"分バージョンを作ることもできる。"

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo community](https://"
"discord.gg/akd2yfuRS3)!"
msgstr ""
"最後に、あなたのプロジェクトを[Dojoコミュニティ](https://discord.gg/"
"akd2yfuRS3)の他の人たちと共有しましょう！"

#: src/misc/contributors.md:1
#, fuzzy
msgid "Contributing to Dojo Book"
msgstr "Dojo bookへの貢献について"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""
"Dojo engineの進歩や発展に伴い、Dojo bookもその進歩に対応することが不可欠で"
"す。この本を更新し、改良することで、Dojo engineの最新の機能や性能を理解し、活"
"用することに興味がある人にとって、適切で価値のあるリソースであり続けることが"
"できます。どのような協力も歓迎します！"

#: src/misc/contributors.md:5
#, fuzzy
msgid "The purpose of the book"
msgstr "このBookの目的"

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""
"Dojo bookは、さまざまな経験レベルのユーザーに対応する包括的なリソースとなるよ"
"うに設計されています。Dojoとその付属パッケージの初心者向けの入門ガイドである"
"と同時に、経験豊富なユーザーがDojo engineの特徴や機能について理解を深めるため"
"のリファレンスとしても役立つことを目指しています。"

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "本書はいくつかの大きな章に分かれています:"

#: src/misc/contributors.md:11
msgid "Framework Theory"
msgstr "フレームワーク理論"

#: src/misc/contributors.md:13
msgid "Building a World"
msgstr "Worldの構築"

#: src/misc/contributors.md:15
#, fuzzy
msgid "Code of Conduct"
msgstr "コード規範"

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of Conduct](https://www.rust-lang.org/"
"policies/code-of-conduct)."
msgstr ""
"本書は [Rust Code of Conduct](https://www.rust-lang.org/policies/code-of-"
"conduct)に従っている。"

#: src/misc/contributors.md:19
#, fuzzy
msgid "Ways to contribute"
msgstr "貢献する方法"

#: src/misc/contributors.md:21
msgid "Issues"
msgstr ""

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""
"コンテンツが不足している、あるいは古いと思われる場合は、遠慮なく問題を提起し"
"てください。複数のコンテンツが不足していると思われる場合は、それぞれについて"
"別の問題を提起してください。"

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""
"そして、他の投稿者が興味のある仕事の塊をより簡単に見つけられるように、問題に"
"はラベルが付けられます。"

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""
"そのIssueには、何が欠けているのか、何を改善すればいいのか、必要だと思われる限"
"り詳細に記してください。"

#: src/misc/contributors.md:29
msgid "Pull requests"
msgstr ""

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr "文の修正、誤字の訂正、新しいセクションや章の追加など、何でも歓迎です。"

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""
"あなたのプルリクエストがオープンになると、他の貢献者がそれを見て変更を要求す"
"るかもしれません。がっかりしないでください！"

#: src/misc/contributors.md:35
msgid "Writing style"
msgstr ""

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr ""
"このセクションでは、このBookで使われているライティングの基準をいくつか紹介し"
"ます。"

#: src/misc/contributors.md:39
#, fuzzy
msgid "Chapters start with a second level heading"
msgstr "章は第2レベルの見出しで始まる"

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "私たちは以下を使っています:"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr "以下は使いません:"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --branch master\n"
#~ "dojoup --path path/to/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —branch master\n"
#~ "dojoup —path path/to/dojo\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "rustup override set stable && rustup update && cargo test\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "rustup override set stable && rustup update && cargo test\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "sozo init\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "sozo init\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "src\n"
#~ "  - components.cairo\n"
#~ "  - systems.cairo\n"
#~ "  - lib.cairo\n"
#~ "Scarb.toml\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "src\n"
#~ "  - components.cairo\n"
#~ "  - systems.cairo\n"
#~ "  - lib.cairo\n"
#~ "Scarb.toml\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Position {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "\n"
#~ "...rest of code\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Position {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "\n"
#~ "…rest of code\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                },\n"
#~ "                Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                },\n"
#~ "                Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context)\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context)\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Moves {\n"
#~ "            player: ctx.origin, remaining: 10\n"
#~ "            }, Position {\n"
#~ "            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Moves {\n"
#~ "            player: ctx.origin, remaining: 10\n"
#~ "            }, Position {\n"
#~ "            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sozo build\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo build\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "katana --disable-fee\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana —disable-fee\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sozo migrate --name test\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo migrate —name test\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Migration account: "
#~ "0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
#~ "\n"
#~ "[1] 🌎 Building World state....\n"
#~ "  > No remote World found\n"
#~ "[2] 🧰 Evaluating Worlds diff....\n"
#~ "  > Total diffs found: 7\n"
#~ "[3] 📦 Preparing for migration....\n"
#~ "  > Total items to be migrated (7): New 7 Update 0\n"
#~ "  \n"
#~ "# Executor\n"
#~ "  > Contract address: "
#~ "0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
#~ "# World\n"
#~ "  > Contract address: "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "# Components (2)\n"
#~ "Moves\n"
#~ "  > class hash: "
#~ "0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
#~ "Position\n"
#~ "  > class hash: "
#~ "0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
#~ "# Systems (3)\n"
#~ "spawn\n"
#~ "  > class hash: "
#~ "0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
#~ "move\n"
#~ "  > class hash: "
#~ "0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
#~ "library_call\n"
#~ "  > class hash: "
#~ "0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
#~ "\n"
#~ "🎉 Successfully migrated World on block #4 at address "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Migration account: "
#~ "0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
#~ "\n"
#~ "[1] 🌎 Building World state....\n"
#~ "  > No remote World found\n"
#~ "[2] 🧰 Evaluating Worlds diff....\n"
#~ "  > Total diffs found: 7\n"
#~ "[3] 📦 Preparing for migration....\n"
#~ "  > Total items to be migrated (7): New 7 Update 0\n"
#~ "  \n"
#~ "# Executor\n"
#~ "  > Contract address: "
#~ "0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
#~ "# World\n"
#~ "  > Contract address: "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "# Components (2)\n"
#~ "Moves\n"
#~ "  > class hash: "
#~ "0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
#~ "Position\n"
#~ "  > class hash: "
#~ "0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
#~ "# Systems (3)\n"
#~ "spawn\n"
#~ "  > class hash: "
#~ "0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
#~ "move\n"
#~ "  > class hash: "
#~ "0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
#~ "library_call\n"
#~ "  > class hash: "
#~ "0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
#~ "\n"
#~ "🎉 Successfully migrated World on block #4 at address "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sozo execute spawn\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo execute spawn\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "torii\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "torii\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let game_id = ctx.world.uuid();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let game_id = ctx.world.uuid();\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Resource {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    #[key]\n"
#~ "    location: ContractAddress,\n"
#~ "    balance: u8,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Resource {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    #[key]\n"
#~ "    location: ContractAddress,\n"
#~ "    balance: u8,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Resource {\n"
#~ "            player: ctx.origin,\n"
#~ "            location: 12,\n"
#~ "            balance: 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Resource {\n"
#~ "            player: ctx.origin,\n"
#~ "            location: 12,\n"
#~ "            balance: 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "trait PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool;\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl PositionImpl of PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool {\n"
#~ "        if self.x - self.y == 0 {\n"
#~ "            return true;\n"
#~ "        }\n"
#~ "        false\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool {\n"
#~ "        self.x == b.x && self.y == b.y\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "trait PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool;\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl PositionImpl of PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool {\n"
#~ "        if self.x - self.y == 0 {\n"
#~ "            return true;\n"
#~ "        }\n"
#~ "        false\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool {\n"
#~ "        self.x == b.x && self.y == b.y\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```rust,ignore\n"
#~ "const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct GameSettings {\n"
#~ "    #[key]\n"
#~ "    game_settings_id: u32,\n"
#~ "    combat_cool_down: u32,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct GameSettings {\n"
#~ "    #[key]\n"
#~ "    game_settings_id: u32,\n"
#~ "    combat_cool_down: u32,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin, (\n"
#~ "                Moves { player: ctx.origin, remaining: 10 }\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin, (\n"
#~ "                Moves { player: ctx.origin, remaining: 10 }\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "sozo auth writer Moves Spawn \n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "sozo auth writer Moves Spawn \n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Health {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Health {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                    }, Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                    }, Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "sozo auth writer Moves spawn\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "sozo auth writer Moves spawn\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[component]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: Address,\n"
#~ "    remaining: u32,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[component]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: Address,\n"
#~ "    remaining: u32,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct StoreDelRecord {\n"
#~ "    table: felt252,\n"
#~ "    keys: Span<felt252>,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct StoreDelRecord {\n"
#~ "    table: felt252,\n"
#~ "    keys: Span<felt252>,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct WorldSpawned {\n"
#~ "    address: ContractAddress,\n"
#~ "    caller: ContractAddress\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct WorldSpawned {\n"
#~ "    address: ContractAddress,\n"
#~ "    caller: ContractAddress\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct ComponentRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct ComponentRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct SystemRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct SystemRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct Moved {\n"
#~ "    address: felt252,\n"
#~ "    direction: felt252,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct Moved {\n"
#~ "    address: felt252,\n"
#~ "    direction: felt252,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context, direction: Direction) {\n"
#~ "    let (mut position, mut moves) = get !(ctx.world, ctx.origin, "
#~ "(Position, Moves));\n"
#~ "    moves.remaining -= 1;\n"
#~ "\n"
#~ "    let next = next_position(position, direction);\n"
#~ "    \n"
#~ "    set !(ctx.world, (moves, next));\n"
#~ "    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "    return ();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context, direction: Direction) {\n"
#~ "    let (mut position, mut moves) = get !(ctx.world, ctx.origin, "
#~ "(Position, Moves));\n"
#~ "    moves.remaining -= 1;\n"
#~ "\n"
#~ "    let next = next_position(position, direction);\n"
#~ "    \n"
#~ "    set !(ctx.world, (moves, next));\n"
#~ "    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "    return ();\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "sozo test\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "sozo test\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "...rest of code\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use debug::PrintTrait;\n"
#~ "    use super::{Position, PositionTrait};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_zero() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), "
#~ "'not zero');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_equal() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        let position = Position { player, x: 420, y: 0 };\n"
#~ "        position.print();\n"
#~ "        assert(PositionTrait::is_equal(position, Position { player, x: "
#~ "420, y: 0 }), 'not equal');\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "...rest of code\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use debug::PrintTrait;\n"
#~ "    use super::{Position, PositionTrait};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_zero() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), "
#~ "'not zero');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_equal() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        let position = Position { player, x: 420, y: 0 };\n"
#~ "        position.print();\n"
#~ "        assert(PositionTrait::is_equal(position, Position { player, x: "
#~ "420, y: 0 }), ‘not equal’);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/core\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/core\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/react\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/react\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/create-burner\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/create-burner\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "```sh\n"
#~ "# Debian\n"
#~ "sudo apt-get install jq\n"
#~ "\n"
#~ "# Mac\n"
#~ "brew install jq\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "# Debian\n"
#~ "sudo apt-get install jq\n"
#~ "\n"
#~ "# Mac\n"
#~ "brew install jq\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --version nightly\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —version nightly\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --branch release/0.1.0\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —branch release/0.1.0\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --repo tarrencev/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —repo tarrencev/dojo\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --repo tarrencev/dojo --branch patch-10\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —repo tarrencev/dojo —branch patch-10\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --pr 1071\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —pr 1071\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup -C 94bfdb2\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup -C 94bfdb2\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --path ./git/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —path ./git/dojo\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo init\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo init\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo build\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo build\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo test\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo test\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo migrate [OPTIONS]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo migrate [OPTIONS]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "katana --accounts 15 --disable-fee\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana —accounts 15 —disable-fee\n"
#~ "```"

#, fuzzy
#~ msgid "Dojo"
#~ msgstr "なぜDojoなのか？"

#, fuzzy
#~ msgid "# What is Dojo?"
#~ msgstr "Dojoとは？"

#, fuzzy
#~ msgid "# FAQs"
#~ msgstr "よくあるご質問"

#, fuzzy
#~ msgid "## Quick Start"
#~ msgstr "クイックスタート"

#, fuzzy
#~ msgid "#### Prerequisites"
#~ msgstr "前提条件"

#, fuzzy
#~ msgid "# Development Setup"
#~ msgstr "開発セットアップ"

#, fuzzy
#~ msgid "## Get Started"
#~ msgstr "始めましょう"

#, fuzzy
#~ msgid "# Hello Dojo"
#~ msgstr "Hello Dojo"

#, fuzzy
#~ msgid "# Config"
#~ msgstr "Config"

#, fuzzy
#~ msgid "## Components"
#~ msgstr "Component Events"

#, fuzzy
#~ msgid "## Authorization"
#~ msgstr "認可の提供"

#, fuzzy
#~ msgid "Authorization Architecture"
#~ msgstr "認証アーキテクチャ"

#, fuzzy
#~ msgid "## Commands"
#~ msgstr "World Commands"

#, fuzzy
#~ msgid "## Events"
#~ msgstr "World Events"

#, fuzzy
#~ msgid ""
#~ "- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-"
#~ "react-app)\n"
#~ "- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
#~ msgstr ""
#~ "[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-"
#~ "app)"

#, fuzzy
#~ msgid "### @dojoengine/core"
#~ msgstr "@dojoengine/core"

#, fuzzy
#~ msgid "### Getting Started"
#~ msgstr "はじめに"

#, fuzzy
#~ msgid ""
#~ "_`NAME`_  \n"
#~ " &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
#~ msgstr ""
#~ "_`NAME`_  \n"
#~ "    コンポーネントの名前"

#, fuzzy
#~ msgid "### Features"
#~ msgstr "特徴"

#, fuzzy
#~ msgid "### Usage"
#~ msgstr "使用方法"

#, fuzzy
#~ msgid ""
#~ "`-V, --version`\n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Print version"
#~ msgstr "V, —version` Printバージョン"

#, fuzzy
#~ msgid "### Requirements"
#~ msgstr "必要条件"

#, fuzzy
#~ msgid ""
#~ "You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
#~ "tutoralv2/src/systems/move.cairo) for chapter 3 here."
#~ msgstr ""
#~ "第1章の[答え](https://github.com/rkdud007/chess-dojo/blob/tutorialv2/src/"
#~ "systems/initiate.cairo)はこちら。"
