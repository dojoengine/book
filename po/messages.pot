
msgid ""
msgstr ""
"Project-Id-Version: Dojo: The Provable Game Engine\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr ""

#: src/SUMMARY.md:4
msgid "What is Dojo?"
msgstr ""

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr ""

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr ""

#: src/SUMMARY.md:7
msgid "FAQs"
msgstr ""

#: src/SUMMARY.md:9
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:11
msgid "Quick Start"
msgstr ""

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr ""

#: src/SUMMARY.md:13
msgid "Development Setup"
msgstr ""

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr ""

#: src/SUMMARY.md:16
msgid "Community"
msgstr ""

#: src/SUMMARY.md:18
msgid "Get Started"
msgstr ""

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr ""

#: src/SUMMARY.md:22
msgid "Hello Dojo"
msgstr ""

#: src/SUMMARY.md:23
msgid "Config"
msgstr ""

#: src/SUMMARY.md:24
msgid "World"
msgstr ""

#: src/SUMMARY.md:25
msgid "Components"
msgstr ""

#: src/SUMMARY.md:26
msgid "Systems"
msgstr ""

#: src/SUMMARY.md:27
msgid "Entities"
msgstr ""

#: src/SUMMARY.md:28
msgid "Authorization"
msgstr ""

#: src/SUMMARY.md:29
msgid "Commands"
msgstr ""

#: src/SUMMARY.md:30
msgid "Events"
msgstr ""

#: src/SUMMARY.md:31
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:32
msgid "Dojo Modules"
msgstr ""

#: src/SUMMARY.md:33
msgid "ERC20"
msgstr ""

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr ""

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr ""

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr ""

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr ""

#: src/SUMMARY.md:40
msgid "Overview"
msgstr ""

#: src/SUMMARY.md:41
msgid "JS"
msgstr ""

#: src/SUMMARY.md:42
msgid "Core"
msgstr ""

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr ""

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr ""

#: src/SUMMARY.md:47
msgid "Sozo"
msgstr ""

#: src/SUMMARY.md:48
#: src/SUMMARY.md:60
#: src/SUMMARY.md:62
msgid "Reference"
msgstr ""

#: src/SUMMARY.md:49
msgid "init"
msgstr ""

#: src/SUMMARY.md:50
msgid "build"
msgstr ""

#: src/SUMMARY.md:51
msgid "test"
msgstr ""

#: src/SUMMARY.md:52
msgid "migrate"
msgstr ""

#: src/SUMMARY.md:53
msgid "execute"
msgstr ""

#: src/SUMMARY.md:54
msgid "register"
msgstr ""

#: src/SUMMARY.md:55
msgid "system"
msgstr ""

#: src/SUMMARY.md:56
msgid "component"
msgstr ""

#: src/SUMMARY.md:57
msgid "events"
msgstr ""

#: src/SUMMARY.md:58
msgid "auth"
msgstr ""

#: src/SUMMARY.md:59
msgid "Katana"
msgstr ""

#: src/SUMMARY.md:61
msgid "Torii"
msgstr ""

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr ""

#: src/SUMMARY.md:66
msgid "Locally"
msgstr ""

#: src/SUMMARY.md:67
msgid "Remote"
msgstr ""

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr ""

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr ""

#: src/SUMMARY.md:72
msgid "0. Setup"
msgstr ""

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr ""

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr ""

#: src/SUMMARY.md:75
msgid "3. Check Legal Move"
msgstr ""

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr ""

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr ""

#: src/index.md:1
msgid "Dojo"
msgstr ""

#: src/index.md:3
msgid ""
"> Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""

#: src/index.md:7
msgid "## Dojo: The Provable Game Engine"
msgstr ""

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the "
"[Theory](./theory/autonomous-worlds.md) elucidates this emergent concept of "
"autonomous worlds and Provable games."
msgstr ""

#: src/index.md:13
msgid ""
"- [Quickstart](./getting-started/quick-start.md)\n"
"- [What is Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""

#: src/index.md:18
msgid "### Explainer"
msgstr ""

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s "
"[Tarrence](https://twitter.com/tarrenceva) explaining how Dojo works at the "
"2023 [Autonomous Anonymous "
"Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""

#: src/index.md:22
msgid ""
"<video controls "
"poster=\"https://gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source "
"src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa.arweave.net/kW-uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" "
"type=\"video/mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"
msgstr ""

#: src/index.md:30
msgid "### Organizational Structure"
msgstr ""

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & "
"BibliothecaDAO](https://bibliothecadao.xyz/), "
"[briq](https://briq.construction/) and many more "
"[contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""

#: src/index.md:33
msgid "### How do I get involved?"
msgstr ""

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our "
"[Twitter](https://twitter.com/dojostarknet), "
"[Discord](https://discord.gg/vUN4Xq9Qv6) and [contribution "
"guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""

#: src/theory/what-is-dojo.md:1
msgid "# What is Dojo?"
msgstr ""

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building "
"[on-chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""

#: src/theory/what-is-dojo.md:9
msgid "## Stop building infrastructure; start building games"
msgstr ""

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building "
"on-chain games. It includes:"
msgstr ""

#: src/theory/what-is-dojo.md:13
msgid "### Entity Component System (ECS)"
msgstr ""

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr ""

#: src/theory/what-is-dojo.md:21
msgid "### [Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr ""

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build "
"on-chain games. It also eliminates the need to manually create indexers, "
"which can be a tedious and error-prone process."
msgstr ""

#: src/theory/what-is-dojo.md:27
msgid ""
"### [Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr ""

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""

#: src/theory/what-is-dojo.md:31
msgid "### [Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr ""

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""

#: src/theory/what-is-dojo.md:35
msgid "### What Dojo doesn't give you"
msgstr ""

#: src/theory/what-is-dojo.md:37
msgid ""
"1. Visual graphics - While Dojo provides networking and contracts, it "
"doesn't offer graphical engines. You can bring your graphics of choice! "
"Integrate your Dojo world with Unreal, Godot, or Unity."
msgstr ""

#: src/theory/what-is-dojo.md:39
msgid "## Understanding the Dojo Workflow: A Visual Guide"
msgstr ""

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""

#: src/theory/what-is-dojo.md:45
msgid "Dojo Sozo Workflow"
msgstr ""

#: src/theory/autonomous-worlds.md:1
msgid "## Autonomous Worlds"
msgstr ""

#: src/theory/autonomous-worlds.md:3
msgid ""
"> \"Autonomous worlds represent persistent, permissionless, and "
"decentralized open environments that users can freely interact with and "
"contribute to.\""
msgstr ""

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""

#: src/theory/autonomous-worlds.md:9
msgid ""
"1. Decentralized data availability layer: While the state execution may "
"reside on a centralized layer, it is crucial that the state can be "
"reconstructed if the execution layer ceases to exist. Rollups offer a "
"solution, providing increased capacity execution layers while ensuring data "
"is permanently settled on Ethereum. This guarantees the world's perpetual "
"persistence.\n"
"\n"
"2. Permissionless entry point for expanding the world: The World contract "
"must be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""

#: src/theory/autonomous-worlds.md:15
msgid "### Homework"
msgstr ""

#: src/theory/autonomous-worlds.md:16
msgid ""
"- [Wired - Autonomous Worlds "
"Primer](https://www.wired.com/story/autonomous-worlds-aim-to-free-online-games-from-corporate-control/)\n"
"- [0xParc - Autonomous Worlds (Part "
"1)](https://0xparc.org/blog/autonomous-worlds)\n"
"- [Gubsheep - The Strongest Crypto Gaming "
"Thesis](https://gubsheep.substack.com/p/the-strongest-crypto-gaming-thesis)\n"
"- [Lattice - MUD: An engine for Autonomous "
"Worlds](https://lattice.xyz/blog/mud-an-engine-for-autonomous-worlds)\n"
"- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - Composable "
"Engineering](https://www.guiltygyoza.xyz/2023/05/composable-engineering)\n"
"- [Jay Springett - Wind-up "
"Worlds](https://www.thejaymo.net/2022/05/06/wind-up-worlds/)\n"
"- [Are.na collection on Autonomous "
"Worlds](https://www.are.na/sylve-chevet/on-chain-realities-and-autonomous-worlds)"
msgstr ""

#: src/theory/cairo.md:1
msgid "# Provable games"
msgstr ""

#: src/theory/cairo.md:3
msgid ""
"Provable games demand "
"[zero-knowledge](https://ethereum.org/en/zero-knowledge-proofs/) properties "
"for efficient scaling and verification of computations. "
"[Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) addresses "
"this need by providing a generalized language, eliminating the complexity of "
"creating circuits to incorporate "
"[SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr ""

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual "
"Machine](https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) "
"(CVM), which is compatible with Starknet's Layer 2, Starknet appchains, and "
"even in-browser through WebAssembly (WASM)! Dojo aims to supply "
"straightforward ZK primitives to fuel your game development."
msgstr ""

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""

#: src/theory/cairo.md:11
msgid "## Cairo"
msgstr ""

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of "
"[commands](../cairo/commands.md). Commands are a design pattern that helps "
"to reduce boilerplate code, resulting in cleaner and more maintainable "
"applications. They achieve this by encapsulating specific actions or "
"operations within self-contained, reusable units."
msgstr ""

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""

#: src/theory/cairo.md:21
msgid "#### Essential Reading"
msgstr ""

#: src/theory/cairo.md:22
msgid ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"
msgstr ""

#: src/theory/cairo.md:26
msgid "### Starknet as an L2"
msgstr ""

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""

#: src/theory/cairo.md:32
msgid "### Starknet as an Appchain"
msgstr ""

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for "
"Zero-Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, "
"and appchains. Remarkably, you can also run it in WebAssembly (WASM) to "
"generate proofs on the client-side! The Dojo team is working closely with "
"the [Madara](https://github.com/keep-starknet-strange/madara) team to enable "
"Starknet appchains to seamlessly run Dojo worlds."
msgstr ""

#: src/theory/faqs.md:1
msgid "# FAQs"
msgstr ""

#: src/theory/faqs.md:3
msgid "#### Who owns Dojo?"
msgstr ""

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""

#: src/theory/faqs.md:7
msgid "#### Why Dojo?"
msgstr ""

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""

#: src/theory/faqs.md:11
msgid "#### What is the Dojo roadmap?"
msgstr ""

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo "
"Github](https://github.com/dojoengine/dojo/issues) and join the "
"[Discord](https://discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas "
"for the project, please open an issue."
msgstr ""

#: src/theory/faqs.md:15
msgid "#### What is an onchain game?"
msgstr ""

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""

#: src/theory/faqs.md:19
msgid "#### What is an autonomous world?"
msgstr ""

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous "
"Worlds](../theory/autonomous-worlds.md)."
msgstr ""

#: src/theory/faqs.md:23
msgid "#### What is Cairo?"
msgstr ""

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a "
"low-level language designed to compile to the Cairo Virtual Machine. Learn "
"more about it here: [Cairo](../theory/cairo.md)."
msgstr ""

#: src/theory/faqs.md:27
msgid "#### What is a provable game?"
msgstr ""

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach â€” and given the simple rules of "
"chess â€” if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""

#: src/getting-started/quick-start.md:1
msgid "## Quick Start"
msgstr ""

#: src/getting-started/quick-start.md:3
msgid ""
"> It is worth reading [theory](../theory/autonomous-worlds.md) to "
"familiarize yourself with the concept of Autonomous Worlds (AWs) and the "
"[Cairo ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""

#: src/getting-started/quick-start.md:6
msgid "### Install Dojoup"
msgstr ""

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup "
"[here](https://github.com/dojoengine/dojo/blob/master/dojoup/README.md)."
msgstr ""

#: src/getting-started/quick-start.md:10
#: src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""

#: src/getting-started/quick-start.md:14
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen,\n"
"which will make the `dojoup` command available in your CLI."
msgstr ""

#: src/getting-started/quick-start.md:17
#: src/toolchain/dojoup.md:15
msgid ""
"```sh\n"
"dojoup\n"
"```"
msgstr ""

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see "
"[Dojoup](../toolchain/dojoup.md)."
msgstr ""

#: src/getting-started/quick-start.md:23
msgid "### Next steps"
msgstr ""

#: src/getting-started/quick-start.md:25
msgid ""
"> Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""

#: src/getting-started/from-source.md:1
msgid "## Building from source"
msgstr ""

#: src/getting-started/from-source.md:3
msgid ""
"> If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""

#: src/getting-started/from-source.md:5
msgid "#### Prerequisites"
msgstr ""

#: src/getting-started/from-source.md:7
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager.\n"
"The easiest way to install both is with [`rustup.rs`](https://rustup.rs/)."
msgstr ""

#: src/getting-started/from-source.md:10
msgid ""
"On Windows, you will also need a recent version of [Visual "
"Studio](https://visualstudio.microsoft.com/downloads/),\n"
"installed with the \"Desktop Development With C++\" Workloads option."
msgstr ""

#: src/getting-started/from-source.md:13
msgid "#### Building"
msgstr ""

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr ""

#: src/getting-started/from-source.md:17
msgid ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"
msgstr ""

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr ""

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo "
"repository](https://github.com/dojoengine/dojo):"
msgstr ""

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""

#: src/getting-started/setup.md:1
msgid "# Development Setup"
msgstr ""

#: src/getting-started/setup.md:3
msgid ""
"> This article is a guide to setting up a development environment for Dojo. "
"It is not suggested to follow this guide if you are just wanting to play "
"with the toolchain. We strongly suggest following the [Quick "
"Start](../getting-started/quick-start.md) guide."
msgstr ""

#: src/getting-started/setup.md:5
msgid "### Prerequisites"
msgstr ""

#: src/getting-started/setup.md:7
msgid "- Rust\n- Cairo"
msgstr ""

#: src/getting-started/setup.md:12
msgid "## Guide"
msgstr ""

#: src/getting-started/setup.md:14
msgid "### Clone"
msgstr ""

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""

#: src/getting-started/setup.md:20
msgid "### Linux & Mac"
msgstr ""

#: src/getting-started/setup.md:22
msgid "#### 1. Install Rust and Dependencies"
msgstr ""

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr ""

#: src/getting-started/setup.md:26
msgid ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"
msgstr ""

#: src/getting-started/setup.md:30
msgid ""
"> Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""

#: src/getting-started/setup.md:32
msgid "#### 2. Install Scarb Package Manager"
msgstr ""

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf "
"https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""

#: src/getting-started/setup.md:40
msgid "#### 3. Add the Cairo 1.0 VSCode Extension"
msgstr ""

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo "
"1.0](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1) "
"extension for Visual Studio Code."
msgstr ""

#: src/getting-started/setup.md:45
msgid "### Windows"
msgstr ""

#: src/getting-started/setup.md:47
#: src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr ""

#: src/getting-started/setup.md:49
msgid "### Container"
msgstr ""

#: src/getting-started/contributing.md:1
msgid "# Contributing to the Core"
msgstr ""

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""

#: src/getting-started/contributing.md:5
msgid "## How to Contribute"
msgstr ""

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""

#: src/community/get-started.md:1
msgid "## Get Started"
msgstr ""

#: src/community/get-started.md:3
msgid ""
"-   [Community "
"Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""

#: src/cairo/hello-dojo.md:1
msgid "# Hello Dojo"
msgstr ""

#: src/cairo/hello-dojo.md:3
msgid ""
"> This section assumes that you have already installed the Dojo toolchain "
"and are familiar with Cairo. If not, please refer to the [Getting "
"Started](../getting-started/quick-start.md) section."
msgstr ""

#: src/cairo/hello-dojo.md:5
msgid "## Dojo in 15 Minutes"
msgstr ""

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""

#: src/cairo/hello-dojo.md:13
msgid ""
"```console\n"
"sozo init\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""

#: src/cairo/hello-dojo.md:19
msgid "#### Anatomy of a Dojo Project"
msgstr ""

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""

#: src/cairo/hello-dojo.md:23
msgid ""
"```bash\n"
"src\n"
"  - components.cairo\n"
"  - systems.cairo\n"
"  - lib.cairo\n"
"Scarb.toml\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr ""

#: src/cairo/hello-dojo.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"...rest of code\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:54
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we *must* include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr ""

#: src/cairo/hello-dojo.md:62
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                },\n"
"                Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr ""

#: src/cairo/hello-dojo.md:93
msgid ""
"```rust,ignore\n"
"#[system]\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""

#: src/cairo/hello-dojo.md:99
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context)\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:109
msgid ""
"```rust,ignore\n"
"let position = get!(ctx.world, ctx.origin, (Position));\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr ""

#: src/cairo/hello-dojo.md:125
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Moves {\n"
"            player: ctx.origin, remaining: 10\n"
"            }, Position {\n"
"            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr ""

#: src/cairo/hello-dojo.md:142
msgid ""
"-   Explained the anatomy of a Dojo project\n"
"-   Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute\n"
"-   Explained the `execute` function\n"
"-   Explained the `Context` struct\n"
"-   Touched on the `get!` and `set!` commands"
msgstr ""

#: src/cairo/hello-dojo.md:149
msgid "### Run it locally!"
msgstr ""

#: src/cairo/hello-dojo.md:151
msgid "Now that we have some theory out of the way, lets build the Dojo project!"
msgstr ""

#: src/cairo/hello-dojo.md:153
#: src/deployment/locally.md:29
msgid ""
"```bash\n"
"sozo build\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""

#: src/cairo/hello-dojo.md:161
#: src/deployment/locally.md:13
msgid ""
"```bash\n"
"katana --disable-fee\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""

#: src/cairo/hello-dojo.md:167
#: src/deployment/locally.md:23
msgid ""
"```bash\n"
"sozo migrate --name test\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""

#: src/cairo/hello-dojo.md:173
msgid ""
"```bash\n"
"Migration account: "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"\n"
"[1] ðŸŒŽ Building World state....\n"
"  > No remote World found\n"
"[2] ðŸ§° Evaluating Worlds diff....\n"
"  > Total diffs found: 7\n"
"[3] ðŸ“¦ Preparing for migration....\n"
"  > Total items to be migrated (7): New 7 Update 0\n"
"  \n"
"# Executor\n"
"  > Contract address: "
"0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
"# World\n"
"  > Contract address: "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"# Components (2)\n"
"Moves\n"
"  > class hash: "
"0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
"Position\n"
"  > class hash: "
"0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
"# Systems (3)\n"
"spawn\n"
"  > class hash: "
"0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
"move\n"
"  > class hash: "
"0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
"library_call\n"
"  > class hash: "
"0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
"\n"
"ðŸŽ‰ Successfully migrated World on block #4 at address "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:203
msgid ""
"Your ðŸŒŽ is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr ""

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""

#: src/cairo/hello-dojo.md:215
msgid ""
"```bash\n"
"sozo execute spawn\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""

#: src/cairo/hello-dojo.md:221
msgid "### Indexing"
msgstr ""

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""

#: src/cairo/hello-dojo.md:225
msgid ""
"```bash\n"
"torii\n"
"```"
msgstr ""

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr ""

#: src/cairo/hello-dojo.md:233
msgid ""
"-   Built a Dojo world\n"
"-   Deployed the project to Katana\n"
"-   Ran the spawn system locally\n"
"-   Indexed the world with Torii"
msgstr ""

#: src/cairo/hello-dojo.md:238
msgid "### Next Steps"
msgstr ""

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""

#: src/cairo/config.md:1
msgid "# Config"
msgstr ""

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a "
"[Scarb](https://docs.swmansion.com/scarb/) file which is an excellent Cairo "
"package manager and project manager."
msgstr ""

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr ""

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""

#: src/cairo/world.md:1
msgid "## World Contract"
msgstr ""

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""

#: src/cairo/world.md:8
msgid ""
"> **To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""

#: src/cairo/world.md:11
msgid "### Context"
msgstr ""

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""

#: src/cairo/world.md:25
msgid "### The `uuid()` command"
msgstr ""

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""

#: src/cairo/world.md:29
#: src/cairo/commands.md:20
#: src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr ""

#: src/cairo/world.md:31
msgid ""
"```rust,ignore\n"
"let game_id = ctx.world.uuid();\n"
"```"
msgstr ""

#: src/cairo/world.md:36
msgid "### Full World API"
msgstr ""

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:1
msgid "## Components"
msgstr ""

#: src/cairo/components.md:3
msgid "> Components = Data"
msgstr ""

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""

#: src/cairo/components.md:10
msgid "### Components are Structs"
msgstr ""

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""

#: src/cairo/components.md:14
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:23
msgid "#### The #[key] attribute"
msgstr ""

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""

#: src/cairo/components.md:27
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""

#: src/cairo/components.md:40
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Resource {\n"
"            player: ctx.origin,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""

#: src/cairo/components.md:53
msgid "#### Implementing Traits"
msgstr ""

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""

#: src/cairo/components.md:57
msgid ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:77
msgid "#### Custom Setting Components"
msgstr ""

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""

#: src/cairo/components.md:83
msgid ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "
msgstr ""

#: src/cairo/components.md:94
msgid "#### Types"
msgstr ""

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr ""

#: src/cairo/components.md:98
msgid ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`"
msgstr ""

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr ""

#: src/cairo/components.md:109
msgid "### In practice with modularity in mind"
msgstr ""

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr ""

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: "
"position.y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: "
"position.y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/components.md:218
msgid ""
"> A complete example can be found in the [Dojo "
"Starter](https://github.com/dojoengine/dojo-starter)"
msgstr ""

#: src/cairo/systems.md:1
msgid "## Systems"
msgstr ""

#: src/cairo/systems.md:3
msgid "> Systems = Logic"
msgstr ""

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr ""

#: src/cairo/systems.md:9
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod Spawn {\n"
"    use array::ArrayTrait;\n"
"    use traits::Into;\n"
"\n"
"    use dojo::world::Context;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        set !(\n"
"            ctx.world, ctx.origin, (\n"
"                Moves { player: ctx.origin, remaining: 10 }\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/systems.md:31
msgid "### The Execute function"
msgstr ""

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""

#: src/cairo/systems.md:35
msgid "### Other functions in a System"
msgstr ""

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""

#: src/cairo/systems.md:39
msgid "### Using View Functions"
msgstr ""

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr ""

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr ""

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr ""

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this "
"link](https://github.com/dojoengine/dojo-examples), illustrates how to "
"implement a view function:"
msgstr ""

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - "
"auction.start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr ""

#: src/cairo/systems.md:80
msgid ""
"- **Using Dojo Core**: If you are working within the [Dojo "
"Core](../client/npm/core.md), utilize the `call` function. \n"
"  \n"
"- **For Rust Users**: The [Starkli](https://book.starkli.rs/) library "
"provides a handy method to invoke view functions in Rust."
msgstr ""

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""

#: src/cairo/systems.md:86
msgid "### System Authentication"
msgstr ""

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""

#: src/cairo/systems.md:90
msgid ""
"```console\n"
"sozo auth writer Moves Spawn \n"
"```"
msgstr ""

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""

#: src/cairo/entities.md:1
msgid "## Entities"
msgstr ""

#: src/cairo/entities.md:3
msgid ""
"> Entities are the primary key value within the world, to which components "
"can be attached."
msgstr ""

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""

#: src/cairo/entities.md:9
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"
msgstr ""

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the "
"`ctx.origin` to reference the current entity."
msgstr ""

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr ""

#: src/cairo/entities.md:30
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/entities.md:58
msgid ""
"> ECS Theory: Plenty has been written on ECS systems, to go deeper read "
"[ECS-FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""

#: src/cairo/authorization.md:1
msgid "## Authorization"
msgstr ""

#: src/cairo/authorization.md:3
msgid ""
"> Authorization is crucial to a world, just like how authorization is "
"crucial to any smart contract."
msgstr ""

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""

#: src/cairo/authorization.md:7
msgid "### Auth Architecture"
msgstr ""

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""

#: src/cairo/authorization.md:11
msgid "Authorization Architecture"
msgstr ""

#: src/cairo/authorization.md:13
msgid "### Providing Authorization"
msgstr ""

#: src/cairo/authorization.md:15
msgid ""
"> The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr ""

#: src/cairo/authorization.md:19
msgid ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"
msgstr ""

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""

#: src/cairo/commands.md:1
msgid "## Commands"
msgstr ""

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""

#: src/cairo/commands.md:8
msgid "### Using commands"
msgstr ""

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""

#: src/cairo/commands.md:12
#: src/cairo/commands.md:22
msgid ""
"```rust,ignore\n"
"let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
"```"
msgstr ""

#: src/cairo/commands.md:16
msgid "### The `get!` command"
msgstr ""

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr ""

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""

#: src/cairo/commands.md:30
msgid "### The `set!` command"
msgstr ""

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr ""

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""

#: src/cairo/commands.md:52
msgid "### The `emit!` command"
msgstr ""

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr ""

#: src/cairo/commands.md:58
#: src/cairo/events.md:78
msgid ""
"```rust,ignore\n"
"emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"```"
msgstr ""

#: src/cairo/events.md:1
msgid "## Events"
msgstr ""

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to "
"[Torii](../toolchain/torii/overview.md), all these events are seamlessly "
"indexed, ensuring easy and efficient querying."
msgstr ""

#: src/cairo/events.md:6
msgid "### Component Events"
msgstr ""

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr ""

#: src/cairo/events.md:10
msgid ""
"```rust,ignore\n"
"#[component]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""

#: src/cairo/events.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:43
msgid "### World Events"
msgstr ""

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""

#: src/cairo/events.md:47
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:55
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:63
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""

#: src/cairo/events.md:74
msgid "### Custom Events"
msgstr ""

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr ""

#: src/cairo/events.md:84
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr ""

#: src/cairo/events.md:94
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(ctx.world, ctx.origin, (Position, "
"Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(ctx.world, (moves, next));\n"
"    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"    return ();\n"
"}\n"
"```"
msgstr ""

#: src/cairo/events.md:107
msgid ""
"> Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""

#: src/cairo/testing.md:1
msgid "## Testing"
msgstr ""

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr ""

#: src/cairo/testing.md:7
msgid ""
"```shell\n"
"sozo test\n"
"```"
msgstr ""

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr ""

#: src/cairo/testing.md:14
msgid "### Writing Unit Tests"
msgstr ""

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the "
"Component/System you are writing."
msgstr ""

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr ""

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr ""

#: src/cairo/testing.md:21
msgid ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not "
"zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, "
"y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""

#: src/cairo/testing.md:52
msgid "### Writing Integration Tests"
msgstr ""

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""

#: src/cairo/testing.md:56
msgid ""
"This is the example from the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr ""

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr ""

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, "
"dojo::SerdeLen::<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, "
"dojo::SerdeLen::<Position>::len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/cairo/testing.md:113
msgid "#### Useful Dojo Test Functions"
msgstr ""

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""

#: src/cairo/modules.md:1
msgid "## Dojo Modules"
msgstr ""

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""

#: src/cairo/modules.md:5
msgid "### Module Architecture"
msgstr ""

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""

#: src/cairo/modules/erc20.md:1
msgid "## ERC20"
msgstr ""

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""

#: src/cairo/modules/erc20.md:5
msgid "### Integration into Your World"
msgstr ""

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""

#: src/client/overview.md:1
msgid "# Overview"
msgstr ""

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr ""

#: src/client/overview.md:7
msgid "- [npm](./npm.md)"
msgstr ""

#: src/client/npm.md:1
msgid "# Javascript Libraries"
msgstr ""

#: src/client/npm.md:3
msgid ""
"> Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""

#: src/client/npm.md:5
msgid "### Examples using these:"
msgstr ""

#: src/client/npm.md:7
msgid ""
"- "
"[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""

#: src/client/npm.md:10
msgid "### @dojoengine/core"
msgstr ""

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr ""

#: src/client/npm.md:16
#: src/client/npm/core.md:12
msgid ""
"```console\n"
"yarn add @dojoengine/core\n"
"```"
msgstr ""

#: src/client/npm.md:20
msgid "### @dojoengine/react"
msgstr ""

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud "
"React](https://github.com/latticexyz/mud/tree/main/packages)"
msgstr ""

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr ""

#: src/client/npm.md:28
msgid ""
"```console\n"
"yarn add @dojoengine/react\n"
"```"
msgstr ""

#: src/client/npm.md:33
msgid "### @dojoengine/create-burner"
msgstr ""

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr ""

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr ""

#: src/client/npm.md:39
msgid ""
"```console\n"
"yarn add @dojoengine/create-burner\n"
"```"
msgstr ""

#: src/client/npm/core.md:1
msgid "## @dojoengine/core"
msgstr ""

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""

#: src/client/npm/core.md:5
msgid ""
"- World explorers\n"
"- World deployers\n"
"- Games\n"
"- Anaylitics"
msgstr ""

#: src/client/npm/core.md:10
msgid "### Getting Started"
msgstr ""

#: src/client/npm/core.md:16
msgid "### Example Usage"
msgstr ""

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React "
"App](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new "
"RPCProvider(import.meta.env.VITE_PUBLIC_WORLD_ADDRESS, "
"import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: "
"num.BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => "
"provider.entity(component, query),\n"
"        entities: async (component: string, partition: number) => "
"provider.entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new "
"GraphQLClient(import.meta.env.VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:1
msgid "# `dojoup`"
msgstr ""

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr ""

#: src/toolchain/dojoup.md:5
msgid "## Installing"
msgstr ""

#: src/toolchain/dojoup.md:11
msgid "## Usage"
msgstr ""

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr ""

#: src/toolchain/dojoup.md:18
msgid ""
"> Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""

#: src/toolchain/dojoup.md:20
msgid ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr ""

#: src/toolchain/dojoup.md:30
msgid ""
"```sh\n"
"dojoup --version nightly\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""

#: src/toolchain/dojoup.md:36
msgid ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""

#: src/toolchain/dojoup.md:42
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""

#: src/toolchain/dojoup.md:48
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr ""

#: src/toolchain/dojoup.md:54
msgid ""
"```sh\n"
"dojoup --pr 1071\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr ""

#: src/toolchain/dojoup.md:60
msgid ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at "
"`~/git/dojo`, assuming you're in the home directory)"
msgstr ""

#: src/toolchain/dojoup.md:66
msgid ""
"##### Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""

#: src/toolchain/dojoup.md:68
msgid ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"
msgstr ""

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""

#: src/toolchain/dojoup.md:78
msgid "### Precompiled binaries"
msgstr ""

#: src/toolchain/dojoup.md:80
msgid ""
"Precompiled binaries are available from the [GitHub releases "
"page](https://github.com/dojoengine/dojo/releases).\n"
"These are better managed by using [Dojoup](#using-dojoup)."
msgstr ""

#: src/toolchain/dojoup.md:84
msgid ""
"> â„¹ï¸ **Note**\n"
">\n"
"> If you're on Windows, you will need to install and use [Git "
"BASH](https://gitforwindows.org/) or "
"[WSL](https://learn.microsoft.com/en-us/windows/wsl/install),\n"
"> as your terminal, since Dojoup currently does not support Powershell or "
"Cmd."
msgstr ""

#: src/toolchain/sozo/overview.md:1
msgid "## Sozo"
msgstr ""

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of "
"World-building. In the future, it may include a GUI."
msgstr ""

#: src/toolchain/sozo/overview.md:5
msgid "## Features"
msgstr ""

#: src/toolchain/sozo/overview.md:7
msgid ""
"-   **Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""

#: src/toolchain/sozo/overview.md:9
#: src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
msgid "## Installation"
msgstr ""

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via "
"[`dojoup`](../../getting-started/quick-start.md), our dedicated installation "
"package manager."
msgstr ""

#: src/toolchain/sozo/overview.md:13
#: src/toolchain/torii/overview.md:18
msgid "### Installing from Source"
msgstr ""

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr ""

#: src/toolchain/sozo/overview.md:23
msgid ""
"> ðŸ“š **Reference**\n"
">\n"
"> See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""

#: src/toolchain/sozo/reference.md:1
msgid "## sozo reference"
msgstr ""

#: src/toolchain/sozo/reference.md:3
msgid "### Project Commands"
msgstr ""

#: src/toolchain/sozo/reference.md:5
msgid ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:10
msgid "### World Commands"
msgstr ""

#: src/toolchain/sozo/reference.md:12
msgid ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:1
msgid "## sozo init"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the "
"[dojo-starter](https://github.com/dojoengine/dojo-starter)."
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:5
#: src/tutorial/onchain-chess/0-setup.md:21
msgid ""
"```sh\n"
"sozo init\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:1
msgid "## sozo build"
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""

#: src/toolchain/sozo/project-commands/build.md:5
#: src/tutorial/onchain-chess/0-setup.md:38
msgid ""
"```sh\n"
"sozo build\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:1
msgid "## sozo test"
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""

#: src/toolchain/sozo/project-commands/test.md:5
msgid ""
"```sh\n"
"sozo test\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "## sozo migrate"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7
#: src/toolchain/torii/reference.md:7
msgid "### USAGE"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:9
msgid ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105
#: src/toolchain/torii/reference.md:33
msgid "### OPTIONS"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107
#: src/toolchain/torii/reference.md:35
msgid "#### General Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Name of the World. At the moment, the only usage for "
"this option is to be used as a salt when deploying the World contract to "
"avoid address conflicts. This option is **required** when performing the "
"initial migration of the World."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
msgid "#### World Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The address of the World contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
msgid "#### Starknet Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet RPC endpoint. [default: "
"http://localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
msgid "#### Account Options"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet account address.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
msgid "#### Signer Options - Raw"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The raw private key associated with the account "
"contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
msgid "#### Signer Options - Keystore"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
msgid ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Use the keystore in the given folder or file."
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The keystore password. Used with --keystore.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:186
msgid "### EXAMPLES"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "1. Deploying your World for the first time to a local Katana node"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "2. Updating a remote World after making some changes"
msgstr ""

#: src/toolchain/sozo/project-commands/migrate.md:63
msgid ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "## sozo execute"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:9
msgid ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The calldata to be passed to the system that you "
"want to execute.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420."
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:56
msgid ""
"1. Executing the _position_ system which takes two values (_x_: 0x77 and "
"_y_: 0x44)"
msgstr ""

#: src/toolchain/sozo/world-commands/execute.md:58
msgid ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:1
msgid "## sozo register"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:5
msgid ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/register.md:16
msgid ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:1
msgid "## sozo system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:7
msgid ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "### SUBCOMMANDS"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "#### `get`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:21
msgid ""
"```sh\n"
"sozo system get <NAME>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "##### Arguments"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid "_`NAME`_  \n&nbsp;&nbsp;&nbsp;&nbsp;The name of the system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:30
msgid "#### `dependency`"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:34
msgid ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:59
msgid "1. Get the class hash of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:61
msgid ""
"```sh\n"
"sozo system get spawn\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:65
msgid "2. Get the component dependencies of the _spawn_ system"
msgstr ""

#: src/toolchain/sozo/world-commands/system.md:67
msgid ""
"```sh\n"
"sozo system dependency spawn\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:1
msgid "## sozo component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:7
msgid ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:22
msgid ""
"```sh\n"
"sozo component get <NAME>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
msgid "_`NAME`_  \n&nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:31
msgid "#### `schema`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:35
msgid ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:44
msgid "#### `entity`"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:48
msgid ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:54
msgid "_`NAME`_  \n &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The keys of the entity that you want to query.  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:1
msgid "## sozo events"
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr ""

#: src/toolchain/sozo/world-commands/events.md:5
msgid ""
"```sh\n"
"sozo events\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "## sozo auth"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:5
msgid ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""

#: src/toolchain/sozo/world-commands/auth.md:15
msgid ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:1
msgid "## Katana"
msgstr ""

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""

#: src/toolchain/katana/overview.md:5
msgid "### Features"
msgstr ""

#: src/toolchain/katana/overview.md:7
msgid ""
"-   [Starknet JSON-RPC "
"v0.3.0](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) "
"support\n"
"-   Custom methods for manipulating the blockchain states"
msgstr ""

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via "
"[`dojoup`](../../getting-started/quick-start.md)."
msgstr ""

#: src/toolchain/katana/overview.md:14
msgid "### Installing from source"
msgstr ""

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:22
msgid "### Usage"
msgstr ""

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n"
"â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\n"
"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n"
"â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\n"
"â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\n"
"â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"ðŸš€ JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""

#: src/toolchain/katana/overview.md:60
msgid ""
"> ðŸ“š **Reference**\n"
">\n"
"> See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""

#: src/toolchain/katana/reference.md:1
msgid "## katana reference"
msgstr ""

#: src/toolchain/katana/reference.md:3
msgid "### NAME"
msgstr ""

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr ""

#: src/toolchain/katana/reference.md:9
msgid ""
"```sh\n"
"katana [OPTIONS]\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:13
#: src/toolchain/torii/reference.md:13
msgid "### DESCRIPTION"
msgstr ""

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""

#: src/toolchain/katana/reference.md:19
msgid "#### Mining Modes"
msgstr ""

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""

#: src/toolchain/katana/reference.md:25
msgid ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:30
msgid "#### Supported Transport Layers"
msgstr ""

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""

#: src/toolchain/katana/reference.md:34
msgid ""
"```sh\n"
"katana --port <PORT>\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:38
msgid "#### Starknet Feature Compatibility"
msgstr ""

#: src/toolchain/katana/reference.md:40
msgid "##### Supported Transaction Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"
msgstr ""

#: src/toolchain/katana/reference.md:48
msgid "#### Supported RPC Methods"
msgstr ""

#: src/toolchain/katana/reference.md:50
msgid "##### Starknet Methods"
msgstr ""

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on "
"[this](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) "
"reference."
msgstr ""

#: src/toolchain/katana/reference.md:54
msgid ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   `starknet_getClassAt`\n"
"\n"
"-   `starknet_syncing`\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:83
msgid "##### Custom Methods"
msgstr ""

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""

#: src/toolchain/katana/reference.md:90
msgid "`katana_nextBlockTimestamp`  \nGet the time for the next block."
msgstr ""

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""

#: src/toolchain/katana/reference.md:102
msgid "`katana_setStorageAt`  \nSet an exact value of a contract's storage slot."
msgstr ""

#: src/toolchain/katana/reference.md:109
msgid "`--silent`  \n&nbsp;&nbsp;&nbsp;&nbsp; Don't print anything on startup."
msgstr ""

#: src/toolchain/katana/reference.md:112
msgid ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable auto and interval mining, and mine on "
"demand instead."
msgstr ""

#: src/toolchain/katana/reference.md:115
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Block time in seconds for interval mining."
msgstr ""

#: src/toolchain/katana/reference.md:118
msgid ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dump the state of chain on exit to the given file.  "
"\n"
"&nbsp;&nbsp;&nbsp;&nbsp; If the value is a directory, the state will be "
"written to `<PATH>/state.bin`."
msgstr ""

#: src/toolchain/katana/reference.md:122
msgid ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Initialize the chain from a previously saved state "
"snapshot."
msgstr ""

#: src/toolchain/katana/reference.md:125
msgid ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help (see a summary with '-h')."
msgstr ""

#: src/toolchain/katana/reference.md:128
msgid "`-V, --version`  \n&nbsp;&nbsp;&nbsp;&nbsp; Print version information."
msgstr ""

#: src/toolchain/katana/reference.md:131
msgid "#### Server Options"
msgstr ""

#: src/toolchain/katana/reference.md:133
msgid ""
"`-p, --port <PORT>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Port number to listen on. [default: 5050]"
msgstr ""

#: src/toolchain/katana/reference.md:136
msgid ""
"`--host <HOST>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The IP address the server will listen on."
msgstr ""

#: src/toolchain/katana/reference.md:141
msgid ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify the seed for randomness of accounts to be "
"predeployed."
msgstr ""

#: src/toolchain/katana/reference.md:144
msgid ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Number of pre-funded accounts to generate. "
"[default: 10]"
msgstr ""

#: src/toolchain/katana/reference.md:147
msgid ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable charging fee for transactions."
msgstr ""

#: src/toolchain/katana/reference.md:150
msgid "#### Environment Options"
msgstr ""

#: src/toolchain/katana/reference.md:152
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The chain ID. [default: KATANA]"
msgstr ""

#: src/toolchain/katana/reference.md:155
msgid "`--gas-price <GAS_PRICE>`  \n&nbsp;&nbsp;&nbsp;&nbsp; The gas price."
msgstr ""

#: src/toolchain/katana/reference.md:158
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account validation logic."
msgstr ""

#: src/toolchain/katana/reference.md:161
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account execution logic."
msgstr ""

#: src/toolchain/katana/reference.md:164
msgid "### Shell Completions"
msgstr ""

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr ""

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr ""

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr ""

#: src/toolchain/katana/reference.md:172
msgid ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"
msgstr ""

#: src/toolchain/katana/reference.md:178
msgid "#### EXAMPLES"
msgstr ""

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr ""

#: src/toolchain/katana/reference.md:182
msgid ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:188
msgid "1. Create 15 dev accounts and disable transaction fee mechanism"
msgstr ""

#: src/toolchain/katana/reference.md:190
msgid ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:194
msgid "2. Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""

#: src/toolchain/katana/reference.md:196
msgid ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"
msgstr ""

#: src/toolchain/katana/reference.md:200
msgid ""
"3. Load previously stored state and dump the state of this session to a file "
"on shutdown"
msgstr ""

#: src/toolchain/katana/reference.md:202
msgid ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"
msgstr ""

#: src/toolchain/torii/overview.md:1
msgid "## Torii - Networking & Indexing"
msgstr ""

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""

#: src/toolchain/torii/overview.md:5
msgid "### Dojo indexer"
msgstr ""

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""

#: src/toolchain/torii/overview.md:9
msgid ""
"```sh\n"
"torii\n"
"```"
msgstr ""

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr ""

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via "
"[`dojoup`](../../getting-started/quick-start.md), our dedicated installation "
"package manager."
msgstr ""

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr ""

#: src/toolchain/torii/overview.md:22
msgid ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"
msgstr ""

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr ""

#: src/toolchain/torii/overview.md:28
msgid ""
"> ðŸ“š **Reference**\n"
">\n"
"> See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""

#: src/toolchain/torii/reference.md:1
msgid "## torii reference"
msgstr ""

#: src/toolchain/torii/reference.md:3
msgid "### Name"
msgstr ""

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr ""

#: src/toolchain/torii/reference.md:9
msgid ""
"```sh\n"
"torii [OPTIONS]\n"
"```"
msgstr ""

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""

#: src/toolchain/torii/reference.md:19
msgid "#### Database URL"
msgstr ""

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""

#: src/toolchain/torii/reference.md:23
msgid ""
"- The in-memory database is ephermal and only lasts as long as the indexer "
"is running. This is a fast and simple option to start the indexer for "
"development/testing.\n"
"- Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""

#: src/toolchain/torii/reference.md:28
msgid ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"
msgstr ""

#: src/toolchain/torii/reference.md:37
msgid ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Address of the world contract to index"
msgstr ""

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Starknet RPC endpoing to use [default: "
"http//localhost:5050]"
msgstr ""

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a local manifest to initialize from"
msgstr ""

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Database URL (read more above) [default: "
"sqlite::memory:]"
msgstr ""

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a block to start indexing from, ignored if "
"stored head exists [default: 0]"
msgstr ""

#: src/toolchain/torii/reference.md:52
msgid "`-h, --help`\n&nbsp;&nbsp;&nbsp;&nbsp; Print help"
msgstr ""

#: src/toolchain/torii/reference.md:55
msgid "`-V, --version`\n&nbsp;&nbsp;&nbsp;&nbsp; Print version"
msgstr ""

#: src/deployment/locally.md:1
msgid "## Deploying Locally"
msgstr ""

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""

#: src/deployment/locally.md:5
msgid "### Katana Deployments"
msgstr ""

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr ""

#: src/deployment/locally.md:9
msgid ""
"> This assumes you have followed the [Quick "
"Start](./getting-started/quick-start.md) guide and have a project "
"initialized."
msgstr ""

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr ""

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr ""

#: src/deployment/locally.md:19
msgid "### Deploying to Katana"
msgstr ""

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr ""

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""

#: src/deployment/remote.md:1
msgid "## Deployment to Remote Network"
msgstr ""

#: src/deployment/remote.md:3
msgid "> *IMPORTANT: Dojo is unaudited. Use at your own risk.*"
msgstr ""

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr ""

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:33
msgid "### Remote Katana"
msgstr ""

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""

#: src/deployment/remote.md:37
msgid "__todo__: add instructions for deploying to remote katana"
msgstr ""

#: src/deployment/remote.md:40
msgid "### Madara "
msgstr ""

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust ðŸ¦€, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr ""

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr ""

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr ""

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""

#: src/deployment/remote.md:59
msgid "### Starknet "
msgstr ""

#: src/deployment/remote.md:61
msgid "__todo__: add instructions for deploying to remote Starknet"
msgstr ""

#: src/tutorial/onchain-chess/index.md:1
msgid "# Building a Chess Game"
msgstr ""

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr ""

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""

#: src/tutorial/onchain-chess/index.md:11
msgid "## What are we building?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""

#: src/tutorial/onchain-chess/index.md:15
msgid ""
"1. A system to spawn all the chess pieces\n"
"2. A system to make pieces move\n"
"3. Add some functions to check a legal move\n"
"4. Play chess â™Ÿâ™™ - integration test!"
msgstr ""

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this "
"repo](https://github.com/rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""

#: src/tutorial/onchain-chess/index.md:24
msgid "## What after this guide?"
msgstr ""

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:1
msgid "# 0. Setup"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the "
"[`hello-dojo`](../../cairo/hello-dojo.md) chapter to gain a basic "
"understanding of the Dojo game._"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "## Initializing the Project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:9
msgid ""
"```sh\n"
"mkdir dojo-chess\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:15
msgid ""
"```sh\n"
"cd dojo-chess\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "## Cleaning Up the Boilerplate"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:31
msgid ""
"```rust,ignore\n"
"mod components;\n"
"mod systems;\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:42
msgid "## Basic components"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:46
msgid ""
"> Every square of the chess board (e.g., A1) will be treated as an entity. "
"If a piece exists on a square, the square entity will hold that piece."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this "
"[chapter](../../cairo/components.md)."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:50
msgid ""
"```rust,ignore\n"
"#[derive(Component)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:78
msgid "## Basic systems"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:86
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod initiate_system {\n"
"\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:95
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"\n"
"use initiate::initiate_system;\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:103
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"mod move;\n"
"\n"
"use initiate::initiate_system;\n"
"use move::move_system;\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:111
msgid "## Compile your project"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:115
#: src/tutorial/onchain-chess/0-setup.md:179
msgid ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:121
msgid ""
"```rust,ignore\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:153
msgid ""
"```sh\n"
"error: Trait has no implementation in context: "
"dojo::serde::SerdeLen::<core::option::Option::<dojo_chess::components::PieceType>>\n"
" --> Square:80:54\n"
"                dojo::SerdeLen::<Option<PieceType>>::len()\n"
"                                                     ^*^\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:162
msgid ""
"```rust,ignore\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "## Run test"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:183
msgid ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:189
msgid "## Add more components"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:193
msgid "### Requirements"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:195
msgid "- `Color` enum enum with values White and Black\n- `Game` component:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:198
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:205
msgid "- `GameTurn` component:"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:207
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:212
msgid ""
"- We will later set game entity composed of the `Game` and `GameTurn` "
"components.\n"
"- Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:215
msgid "Try to solve on your own, and before you move on check the answer below."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:217
msgid "<details>\n<summary>Click to see full `components.cairo` code</summary>"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:397
msgid "</details>"
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game ðŸŽ‰"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:1
msgid "# 1. Initiate System"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:5
msgid "## What is `initiate_system`?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:9
msgid ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" "
"height=\"auto\">"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
msgid "## Requirements"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your "
"`systems/initiate.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"1. Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input.\n"
"2. Implement the game entity, comprised of the `Game` component and "
"`GameTurn` component we created in the previous step.\n"
"3. Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`.\n"
"4. Run `sozo test` and pass all the tests."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "## Test Flow"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"- Spawn the test world that imports the components and systems used in "
"testing.\n"
"- Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs.\n"
"- Retrieve the game entity and piece entity created during "
"`initiate_system`.\n"
"- Ensure the game has been correctly created.\n"
"- Verify that each `Piece` is located in the correct `Square`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
msgid "## Unit Tests"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
msgid "## Need help?"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo "
"community](https://discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the "
"[answer](https://github.com/rkdud007/chess-dojo/blob/tutorialv2/src/systems/initiate.cairo) "
"for chapter 1 here."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:1
msgid "# 2. Move System"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:5
msgid "## What is `move_system`?"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your "
"`systems/move.cairo` file._"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:13
msgid "1. Write an `execute` function in the system with the following inputs:"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:15
msgid ""
"```rust,ignore\n"
" fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    )\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:25
msgid ""
"2. Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece.\n"
"\n"
"3. Run `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:31
msgid ""
"- Follow the same logic as `test_initiate` from the previous chapter.\n"
"- Move the White Knight from (1,0) to (2,2) using the `move_system`.\n"
"- Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:1
msgid "# 3. Check Legal Move"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:5
msgid ""
"- If the next move goes outside the board.\n"
"- If there's a piece that can be captured.\n"
"- If the next move is allowed for the type of piece.\n"
"- If the user can allow to make a action (based on the piece's color).\n"
"- ... You can also add other custom check functions."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:11
msgid "## Make Check Functions"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:15
msgid "1. See if the next spot is allowed for the type of piece moving."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:17
msgid ""
"```rust,ignore\n"
"  fn is_right_piece_move(\n"
"        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
"next_position: (u32, u32)\n"
"    ) -> bool {}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:23
msgid "2. See if the next spot is still on the board."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:25
msgid ""
"```rust,ignore\n"
"  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:29
msgid ""
"3. See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:31
msgid ""
"```rust,ignore\n"
" fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
"game_id: felt252) -> bool{}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:35
msgid ""
"4. You can also add other check functions to be extra sure the move is "
"allowed."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:85
msgid "## Testing Each Function"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:169
msgid ""
"You can find the "
"[answer](https://github.com/rkdud007/chess-dojo/blob/tutoralv2/src/systems/move.cairo) "
"for chapter 3 here."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:1
msgid "# 4. Test Contract"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:7
msgid ""
"1. Spawn `white_pawn_1` to (0,1)\n"
"2. Move `white_pawn_1` to (0,3)\n"
"3. Move `black_pawn_2` to (1,6)\n"
"4. Move `white_pawn_1` to (0,4)\n"
"5. Move `black_pawn_2` to (1,5)\n"
"6. Move `white_pawn_1` to (1,5)\n"
"7. Capture `black_pawn_2`"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:19
msgid ""
"- Copy the test below and add it to your `src/tests.cairo` file.\n"
"- Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:22
msgid "## Full Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
" in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:143
msgid "## Diving into the Code"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:147
msgid ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:169
msgid ""
"```rust,ignore\n"
"     let world = spawn_test_world(components, systems);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:212
msgid "## Congratulations!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"- Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient.\n"
"- Add a checkmate feature. Our game doesn't end now, so decide when it "
"should!\n"
"- Include special moves like castling, En Passant Capture, or Pawn "
"Promotion.\n"
"- Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo "
"community](https://discord.gg/akd2yfuRS3)!"
msgstr ""

#: src/misc/contributors.md:1
msgid "## Contributing to Dojo Book"
msgstr ""

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""

#: src/misc/contributors.md:5
msgid "### The purpose of the book"
msgstr ""

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr ""

#: src/misc/contributors.md:11
msgid ""
"- Framework Theory\n"
"- Getting Started\n"
"- Building a World"
msgstr ""

#: src/misc/contributors.md:15
msgid "### Code of Conduct"
msgstr ""

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of "
"Conduct](https://www.rust-lang.org/policies/code-of-conduct)."
msgstr ""

#: src/misc/contributors.md:19
msgid "### Ways to contribute"
msgstr ""

#: src/misc/contributors.md:21
msgid "#### Issues"
msgstr ""

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""

#: src/misc/contributors.md:29
msgid "#### Pull requests"
msgstr ""

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""

#: src/misc/contributors.md:35
msgid "### Writing style"
msgstr ""

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr ""

#: src/misc/contributors.md:39
msgid "#### Chapters start with a second level heading"
msgstr ""

#: src/misc/contributors.md:41
msgid "We use:"
msgstr ""

#: src/misc/contributors.md:43
msgid ""
"```md\n"
"## Some Page\n"
"```"
msgstr ""

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr ""

#: src/misc/contributors.md:49
msgid ""
"```md\n"
"# Some Page\n"
"```"
msgstr ""

