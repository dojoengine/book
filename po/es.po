msgid ""
msgstr ""
"Project-Id-Version: Building Autonomous Worlds with Dojo\n
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-09-27 07:01+0100\n"
"Last-Translator: dami <pinonesdamian@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "Introducción"

#: src/SUMMARY.md:4
msgid "What is Dojo?"
msgstr "## ¿Qué es Dojo?"
#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "Teoría AW"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "Ecosistema de Cairo"

#: src/SUMMARY.md:7
msgid "FAQs"
msgstr "Preguntas frecuentes"

#: src/SUMMARY.md:9
msgid "Getting Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:11
msgid "Quick Start"
msgstr "Inicio rápido"

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr "Manual de Instalación"

#: src/SUMMARY.md:13
msgid "Development Setup"
msgstr "Configuración del Desarrollo"

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr "Colaboradores"

#: src/SUMMARY.md:16
msgid "Community"
msgstr "Comunidad"

#: src/SUMMARY.md:18
msgid "Get Started"
msgstr "Primeros pasos"

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr "Arquitectura"

#: src/SUMMARY.md:22
msgid "Hello Dojo"
msgstr "Hola Dojo"

#: src/SUMMARY.md:23
msgid "Config"
msgstr "Configuración"

#: src/SUMMARY.md:24
msgid "World"
msgstr "Mundo"

#: src/SUMMARY.md:25
msgid "Components"
msgstr "Componentes"

#: src/SUMMARY.md:26
msgid "Systems"
msgstr "Sistemas"

#: src/SUMMARY.md:27
msgid "Entities"
msgstr "Entidades"

#: src/SUMMARY.md:28
msgid "Authorization"
msgstr "Autorización"

#: src/SUMMARY.md:29
msgid "Commands"
msgstr "Comandos"

#: src/SUMMARY.md:30
msgid "Events"
msgstr "Eventos"

#: src/SUMMARY.md:31
msgid "Testing"
msgstr "Pruebas"

#: src/SUMMARY.md:32
msgid "Dojo Modules"
msgstr "Módulos Dojo"

#: src/SUMMARY.md:33
msgid "ERC20"
msgstr "ERC20"

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr "ERC721"

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr "ERC1155"

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr "DeFi"

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr "Client SDKs"

#: src/SUMMARY.md:40
msgid "Overview"
msgstr "Visión general"

#: src/SUMMARY.md:41
msgid "JS"
msgstr "JS"

#: src/SUMMARY.md:42
msgid "Core"
msgstr "Core"

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr "Herramientas"

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr "Dojoup"

#: src/SUMMARY.md:47
msgid "Sozo"
msgstr "Sozo"

#: src/SUMMARY.md:48 src/SUMMARY.md:60 src/SUMMARY.md:62
msgid "Reference"
msgstr "Referencias"

#: src/SUMMARY.md:49
msgid "init"
msgstr "init"

#: src/SUMMARY.md:50
msgid "build"
msgstr "build"

#: src/SUMMARY.md:51
msgid "test"
msgstr "test"

#: src/SUMMARY.md:52
msgid "migrate"
msgstr "migrate"

#: src/SUMMARY.md:53
msgid "execute"
msgstr "execute"

#: src/SUMMARY.md:54
msgid "register"
msgstr "register"

#: src/SUMMARY.md:55
msgid "system"
msgstr "system"

#: src/SUMMARY.md:56
msgid "component"
msgstr "component"

#: src/SUMMARY.md:57
msgid "events"
msgstr "events"

#: src/SUMMARY.md:58
msgid "auth"
msgstr "auth"

#: src/SUMMARY.md:59
msgid "Katana"
msgstr "Katana"

#: src/SUMMARY.md:61
msgid "Torii"
msgstr "Torii"

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr "Desplegando"

#: src/SUMMARY.md:66
msgid "Locally"
msgstr "Localmente"

#: src/SUMMARY.md:67
msgid "Remote"
msgstr "Remoto"

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr "Tutorial"

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr "Onchain Chess"

#: src/SUMMARY.md:72
msgid "0. Setup"
msgstr "0. Configuración"

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr "1. Iniciar"

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr "2. Mover"

#: src/SUMMARY.md:75
msgid "3. Check Legal Move"
msgstr "3. Comprobar Movimiento Legal"

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr "4. Test Chess"

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr "Colaboradores"

#: src/index.md:1
msgid "Dojo"
msgstr "Dojo"

#: src/index.md:3
#, fuzzy
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo es un proyecto de código abierto, actualmente en su fase inicial de "
"desarrollo, y da una cálida bienvenida a los colaboradores. Para obtener "
"recursos adicionales, encuentra el libro en [Github](https://github.com/"
"dojoengine/book)."

#: src/index.md:7
#, fuzzy
msgid "Dojo: The Provable Game Engine"
msgstr "## Dojo: El motor de juegos demostrables"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""

#: src/index.md:11
#, fuzzy
msgid ""
"> Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo es un proyecto de código abierto que se encuentra en su fase inicial "
"de desarrollo. Para más información, únete a la comunidad en [Discord]"
"(https://discord.gg/vUN4Xq9Qv6) y consulta la [guía de contribución](./misc/"
"contributors.md)."

#: src/index.md:7
msgid "## Dojo: The Provable Game Engine"
msgstr "## Dojo: El motor de Juegos Demostrables"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""
"Dojo emplea [Cairo](https://github.com/starkware-libs/cairo) para ofrecer "
"una arquitectura robusta y un conjunto de herramientas para diseñar mundos "
"autónomos y juegos onchain. Cuenta con un sistema integrado de componentes "
"de entidad (ECS) e incluye un indexador nativo, una red de pruebas RPC y un "
"completo conjunto de herramientas de gestión CLI."

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the [Theory](./theory/"
"autonomous-worlds.md) elucidates this emergent concept of autonomous worlds "
"and Provable games."
msgstr ""
"Este libro está dedicado a familiarizarte con el motor Dojo y el potencial "
"de los juegos Provable. Una sección especial sobre la [Teoría](./theory/"
"autonomous-worlds.md) elucida este concepto emergente de mundos autónomos y "
"juegos Provable."

#: src/index.md:13
msgid ""
"- [Quickstart](./getting-started/quick-start.md)\n"
"- [What is Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""
"- [Inicio rápido](./getting-started/quick-start.md)\n"
"- [¿Qué es Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explorar la arquitectura](./cairo/hello-dojo.md)"

#: src/index.md:18
msgid "### Explainer"
msgstr "### Explicación"

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://"
"twitter.com/tarrenceva) explaining how Dojo works at the 2023 [Autonomous "
"Anonymous Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""
"Aquí tienes un video de [Cartridge](https://cartridge.gg/) donde [Tarrence]"
"(https://twitter.com/tarrenceva) explica cómo funciona Dojo en la "
"[Autonomous Anonymous Summit 2023](https://twitter.com/pet3rpan_/"
"status/1666764726427353091):"

#: src/index.md:22
msgid ""
"<video controls poster=\"https://"
"gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa."
"arweave.net/kW-uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/"
"mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"
msgstr ""
"<video controls poster=\"https://"
"gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa."
"arweave.net/kW-uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/"
"mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"

#: src/index.md:30
msgid "### Organizational Structure"
msgstr "### Estructura Organizativa"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO]"
"(https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many "
"more [contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojo es una iniciativa de código abierto, con licencia MIT, dedicada a "
"promover y avanzar en el concepto de Mundos Autónomos (AWs). Es liderado por "
"[Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO](https://"
"bibliothecadao.xyz/), [briq](https://briq.construction/) y muchos otros "
"[colaboradores](https://github.com/orgs/dojoengine/people)."

#: src/index.md:33
msgid "### How do I get involved?"
msgstr "### ¿Cómo puedo involucrarme?"

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) and "
"[contribution guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""
"Consulte nuestro [Github](https://github.com/dojoengine), nuestro [Twitter]"
"(https://twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) "
"y [guía de contribución](https://book.dojoengine.org/misc/contributors.html)."

#: src/theory/what-is-dojo.md:1
msgid "# What is Dojo?"
msgstr "## ¿Qué es Dojo?"

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [on-"
"chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""
"Dojo es la culminación de las lecciones aprendidas en los intentos de crear "
"[juegos on-chain](https://naavik.co/digest/primer-fully-on-chain-gaming), un "
"sector emergente en la industria del juego. Cualquier desarrollador que haya "
"intentado crear un juego en la cadena reconoce los obstáculos inherentes a "
"la ingeniería, algo que nos impulsó a crear Dojo. Del mismo modo que no "
"recrearías Unity cada vez que desarrollas un nuevo juego, aquí se aplica el "
"mismo principio. Dojo está diseñado para manejar la compleja "
"infraestructura, permitiendo a los desarrolladores centrarse en los aspectos "
"únicos de sus juegos."

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""
"Dojo aspira a convertirse en la herramienta de referencia para crear juegos "
"demostrables. Es radicalmente de código abierto, y todas las contribuciones "
"son bienvenidas."

#: src/theory/what-is-dojo.md:9
msgid "## Stop building infrastructure; start building games"
msgstr "## Deja de construir infraestructuras; empieza a construir juegos"

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-"
"chain games. It includes:"
msgstr ""
"El conjunto de herramientas de Dojo elimina la complejidad de la "
"infraestructura para crear juegos en la cadena. Incluye:"

#: src/theory/what-is-dojo.md:13
msgid "### Entity Component System (ECS)"
msgstr "### Sistema de Componentes de Entidad (ECS)"

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""
"Dojo ofrece un enfoque estandarizado para construir juegos sobre contratos "
"inteligentes. Reconociendo las complejidades del diseño de juegos, Dojo "
"simplifica el proceso de desarrollo, permitiendo a los creadores centrarse "
"en la lógica del juego. Esta estandarización allana el camino para una red "
"interconectada de mundos, agilizando la experiencia de los desarrolladores y "
"promoviendo la integración de los juegos."

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""
"Utilizando el ECS (Entity Component System) como arquitectura central, Dojo "
"gestiona eficazmente el estado y el comportamiento de los Mundos Autónomos "
"(MEA). Este modelo gira en torno a sistemas que actúan sobre entidades, que "
"son colecciones de componentes de datos puros. Los sistemas determinan "
"eficientemente qué entidades procesar basándose en consultas persistentes "
"sobre estos componentes."

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr "Lea información detallada sobre el [Dojo ECS](../cairo/overview.md)."

#: src/theory/what-is-dojo.md:21
msgid "### [Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr "### [Torii](/crates/torii/README.md) - Indexador Starknet"

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""
"Construir juegos en la cadena a menudo implica enfrentarse al reto de "
"indexar el estado en la cadena. Sin embargo, Dojo estandariza los estados de "
"los contratos para reflejar las bases de datos relacionales tradicionales. "
"Esta configuración permite al [Torii Indexer](../toolchain/torii/overview."
"md) indexar automáticamente todos los estados del contrato, garantizando "
"consultas eficientes y racionalizadas. Torii luego expone estos estados a "
"través de una API GraphQL o gRPC (próximamente), permitiendo a los "
"desarrolladores consultar y recuperar datos fácilmente."

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-"
"chain games. It also eliminates the need to manually create indexers, which "
"can be a tedious and error-prone process."
msgstr ""
"El uso de Torii reduce drásticamente el tiempo y el esfuerzo necesarios para "
"crear juegos en la cadena. También elimina la necesidad de crear manualmente "
"indexadores, que puede ser un proceso tedioso y propenso a errores."

#: src/theory/what-is-dojo.md:27
msgid ""
"### [Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr "### [Katana](/crates/katana/README.md) - Red de desarrollo rapidísima"

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""
"Katana es una red de desarrollo Starknet personalizable. Es rapidísima y te "
"permite iterar sobre la lógica de tu juego con rapidez."

#: src/theory/what-is-dojo.md:31
msgid "### [Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr "### [Sozo CLI](/crates/sozo/README.md) - Herramienta de Gestión CLI"

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""
"Los mundos Dojo están a punto de convertirse en algunos de los mayores "
"contratos. Sozo es una herramienta CLI que te ayuda a gestionar tus mundos. "
"Te permite crear, construir, probar y desplegar tus mundos. Además, puedes "
"crear nuevos componentes y sistemas y registrarlos en tu mundo."

#: src/theory/what-is-dojo.md:35
msgid "### What Dojo doesn't give you"
msgstr "### Que no te ofrece Dojo"

#: src/theory/what-is-dojo.md:37
msgid ""
"1. Visual graphics - While Dojo provides networking and contracts, it "
"doesn't offer graphical engines. You can bring your graphics of choice! "
"Integrate your Dojo world with Unreal, Godot, or Unity."
msgstr ""
"1. Gráficos visuales - Aunque Dojo proporciona redes y contratos, no ofrece "
"motores gráficos. ¡Puedes traer los gráficos de tu elección! Integra tu "
"mundo Dojo con Unreal, Godot o Unity."

#: src/theory/what-is-dojo.md:39
msgid "## Understanding the Dojo Workflow: A Visual Guide"
msgstr "## Entendiendo el Workflow de Dojo: Una Guía Visual"

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""
"Para ayudarle a entender cómo funciona `Sozo`, hemos creado una guía visual "
"que describe el flujo de ejecución utilizando la potente herramienta sozo y "
"la red de desarrollo katana."

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""
"Esta representación visual le ayudará a comprender los pasos fundamentales "
"del trabajo con Dojo, guiándole a través del proceso de creación y gestión "
"de sus juegos on-chain."

#: src/theory/what-is-dojo.md:45
msgid "Dojo Sozo Workflow"
msgstr "Dojo Sozo Workflow"

#: src/theory/autonomous-worlds.md:1
#, fuzzy
msgid "Autonomous Worlds"
msgstr "## Mundos Autónomos"

#: src/theory/autonomous-worlds.md:3
#, fuzzy
msgid ""
"\"Autonomous worlds represent persistent, permissionless, and decentralized "
"open environments that users can freely interact with and contribute to.\""
msgstr ""
"> \"Los mundos autónomos representan entornos abiertos, persistentes, sin "
"permisos y descentralizados, en los que los usuarios pueden interactuar y "
"contribuir libremente.\""

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""
"La definición precisa de los Mundos Autónomos (AWs, por sus siglas en "
"inglés) sigue siendo algo escurridiza, ya que es más bien un concepto "
"abstracto que aún no se ha cristalizado completamente. Lattice [introdujo]"
"(https://0xparc.org/blog/autonomous-worlds)  por primera vez el término en "
"2022, pero la noción de mundos abiertos que operan en la cadena de bloques "
"ha existido durante un tiempo. La abstracción presentada por MUD sirvió como "
"un catalizador para que el mercado reconociera el potencial de estos mundos."

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""
"Los Mundos Autónomos comparten similitudes destacadas con las cadenas de "
"bloques en su naturaleza fundamental. Una vez establecidos, persisten y "
"mantienen su estado a lo largo de la vida útil de la cadena. Los jugadores "
"pueden unirse o salir, y los desarrolladores pueden ampliar estos mundos "
"desplegando características de manera sin permisos, de manera similar a cómo "
"se añaden contratos a una cadena. Aunque no existe una definición "
"universalmente aceptada para un Mundo Autónomo, creemos que un juego debe "
"poseer al menos las siguientes dos características esenciales para ser "
"considerado como tal:"

#: src/theory/autonomous-worlds.md:9
#, fuzzy
msgid ""
"Decentralized data availability layer: While the state execution may reside "
"on a centralized layer, it is crucial that the state can be reconstructed if "
"the execution layer ceases to exist. Rollups offer a solution, providing "
"increased capacity execution layers while ensuring data is permanently "
"settled on Ethereum. This guarantees the world's perpetual persistence."
msgstr ""
"1. Capa de disponibilidad de datos descentralizada: Si bien la ejecución del "
"estado puede residir en una capa centralizada, es crucial que el estado "
"pueda reconstruirse si la capa de ejecución deja de existir. Los Rollups "
"ofrecen una solución al proporcionar capas de ejecución con mayor capacidad "
"mientras aseguran que los datos se asienten permanentemente en Ethereum. "
"Esto garantiza la persistencia perpetua del mundo.\n"
"\n"
"2. Punto de entrada sin permisos para expandir el mundo: El contrato del "
"Mundo debe ser capaz de aceptar nuevos sistemas y componentes sin requerir "
"permiso. Si bien esto no implica que cada componente y sistema se utilizará, "
"deben adherirse a este patrón, garantizando un acceso abierto e irrestricto "
"para posibles mejoras."

#: src/theory/autonomous-worlds.md:11
#, fuzzy
msgid ""
"Permissionless entry point for expanding the world: The World contract must "
"be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""
"1. Capa de disponibilidad de datos descentralizada: Si bien la ejecución del "
"estado puede residir en una capa centralizada, es crucial que el estado "
"pueda reconstruirse si la capa de ejecución deja de existir. Los Rollups "
"ofrecen una solución al proporcionar capas de ejecución con mayor capacidad "
"mientras aseguran que los datos se asienten permanentemente en Ethereum. "
"Esto garantiza la persistencia perpetua del mundo.\n"
"\n"
"2. Punto de entrada sin permisos para expandir el mundo: El contrato del "
"Mundo debe ser capaz de aceptar nuevos sistemas y componentes sin requerir "
"permiso. Si bien esto no implica que cada componente y sistema se utilizará, "
"deben adherirse a este patrón, garantizando un acceso abierto e irrestricto "
"para posibles mejoras."

#: src/theory/autonomous-worlds.md:13
#, fuzzy
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""
"Creemos firmemente en el potencial de los Mundos Autónomos para catalizar la "
"exploración de formas novedosas en el medio proporcionado por las pruebas zk "
"y la tecnología blockchain. No se trata solo de juegos, sino también de "
"nuevas formas de trabajo artístico, coordinación y diversión, que surgen del "
"jugueteo y la innovación radical y acaban cuestionando la propia noción de "
"\"juego\" en este nuevo mundo valiente, descentralizado y sin confianza."

#: src/theory/autonomous-worlds.md:15
#, fuzzy
msgid "Homework"
msgstr "### Tarea"

#: src/theory/autonomous-worlds.md:16
msgid ""
"[Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)"
msgstr ""
"- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)\n"
"- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)\n"
"- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)\n"
"- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)\n"
"- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)\n"
"- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-"
"up-worlds/)\n"
"- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/"
"on-chain-realities-and-autonomous-worlds)"

#: src/theory/cairo.md:1
msgid "# Provable games"
msgstr "# Juegos probables"

#: src/theory/autonomous-worlds.md:18
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-"
"knowledge-proofs/) properties for efficient scaling and verification of "
"computations. [Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) "
"addresses this need by providing a generalized language, eliminating the "
"complexity of creating circuits to incorporate [SNARKs](https://consensys."
"net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""
"Los juegos demostrables requieren propiedades de [conocimiento cero](https://"
"ethereum.org/en/zero-knowledge-proofs/)(ZK) para una escalabilidad eficiente "
"y verificación de cálculos. [Cairo](https://book.starknet.io/chapter_1/"
"what_is_cairo.html) aborda esta necesidad proporcionando un lenguaje "
"generalizado, eliminando la complejidad de crear circuitos para incorporar "
"[SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/). "

#: src/theory/cairo.md:15
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr ""
"**Puedes simplemente programar en Cairo y tus aplicaciones se vuelven "
"automáticamente demostrables**. "

#: src/theory/cairo.md:17
#, fuzzy
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), "
"which is compatible with Starknet's Layer 2, Starknet appchains, and even in-"
"browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK "
"primitives to fuel your game development."
msgstr ""
"Además, puedes implementar tus programas en la [Máquina Virtual Cairo]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), que "
"es compatible con la Capa 2 de Starknet, las appchains de Starknet e incluso "
"en el navegador a través de WebAssembly (WASM). Dojo tiene como objetivo "
"proporcionar primitivas de conocimiento cero sencillas(ZK) para impulsar el "
"desarrollo de tus juegos."

#: src/theory/cairo.md:19
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""
"Para obtener más información sobre Starknet, Cairo y su stack tecnológico, "
"visita el [libreo de Starknet y Cairo](https://book.starknet.io/)."

#: src/theory/cairo.md:11
msgid "## Cairo"
msgstr "## Cairo"

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""
"Cairo es un lenguaje de contratos inteligentes de código abierto y Turing "
"completo, desarrollado por Starkware, diseñado para impulsar el Validity "
"Rollup Starknet. El lenguaje permite una computación altamente expresiva y "
"verificable, lo que lo hace adecuado para construir aplicaciones escalables "
"y seguras, incluidos proyectos de finanzas descentralizadas (DeFi)"

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""
"Dojo se basa en Cairo al crear un framework para desarrollar Mundos "
"Autonomos (AWs). Al aprovechar las capacidades de Cairo, Dojo tiene como "
"objetivo agilizar el proceso de desarrollo, mejorar la mantenibilidad y "
"mejorar el rendimiento de AWs."

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/"
"commands.md). Commands are a design pattern that helps to reduce boilerplate "
"code, resulting in cleaner and more maintainable applications. They achieve "
"this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Una característica clave del framework Dojo es el uso de [comandos](../cairo/"
"commands.md). Los comandos son un patrón de diseño que ayuda a reducir el "
"código repetitivo, dando lugar a aplicaciones más limpias y fáciles de "
"mantener. Esto se consigue encapsulando acciones u operaciones específicas "
"en unidades autocontenidas y reutilizables."

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""
"Los desarrolladores pueden escribir comandos libremente dentro de los "
"Sistemas, y el compilador de Cairo se encarga de enlazar las funciones "
"apropiadas. "

#: src/theory/cairo.md:21
msgid "#### Essential Reading"
msgstr "#### Lectura Esencial"

#: src/theory/cairo.md:22
msgid ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"
msgstr ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"

#: src/theory/cairo.md:26
msgid "### Starknet as an L2"
msgstr "### Starknet como una L2"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknet es una solución de Capa 2 (L2) de Validity Rollup diseñada para "
"escalar Ethereum. Opera ofreciendo una alta capacidad de transacciones y "
"bajos costos de gas, manteniendo el mismo nivel de seguridad que Ethereum "
"Capa 1 (L1). La estrategia que utiliza es similar a resolver un rompecabezas "
"Sudoku: verificar una solución es más fácil que encontrar la solución desde "
"cero. De manera similar, Starknet reemplaza la computación pesada y costosa "
"en L1 con una verificación más económica en L1 mediante el uso de pruebas "
"STARK calculadas fuera de la cadena."

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""
"En términos más técnicos, Starknet es un Validity-Rollup sin permisos "
"(también conocido como \"ZK-Rollup\") que admite computación general y "
"actualmente funciona como una red L2 sobre Ethereum. La seguridad de la red "
"L1 está garantizada por su utilización del sistema de prueba criptográfica "
"STARK, que se considera uno de los más seguros y escalables."

msgid "### Starknet as an Appchain"
msgstr "### Starknet como una Appchain"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-"
"Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, and "
"appchains. Remarkably, you can also run it in WebAssembly (WASM) to generate "
"proofs on the client-side! The Dojo team is working closely with the [Madara]"
"(https://github.com/keep-starknet-strange/madara) team to enable Starknet "
"appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairo es un lenguaje isomórfico de propósito general, optimizado para "
"pruebas de conocimiento cero (ZK). Es la fuerza impulsora detrás de "
"Starknet, Starkex y las appchains. Sorprendentemente, también se puede "
"ejecutar en WebAssembly (WASM) para generar pruebas en el lado del cliente! "
"El equipo de Dojo está trabajando en estrecha colaboración con el equipo de "
"[Madara](https://github.com/keep-starknet-strange/madara) para permitir que "
"las appchains de Starknet ejecuten sin problemas los mundos de Dojo."

#: src/theory/faqs.md:1
msgid "# FAQs"
msgstr "# Preguntas frecuentes"

#: src/theory/faqs.md:3
msgid "#### Who owns Dojo?"
msgstr "#### ¿Quién es el propietario de Dojo?"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""
"Dojo es estrictamente open-source y utiliza la licencia Apache 2.0. "
"Cualquiera puede utilizar Dojo de forma gratuita, y cualquiera puede "
"contribuir al proyecto."

#: src/theory/faqs.md:7
msgid "#### Why Dojo?"
msgstr "### ¿Por qué Dojo?"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""
"Dojo se creó para resolver los problemas a los que se enfrentaban sus "
"fundadores a la hora de crear juegos on-chain. Estandariza el proceso de "
"creación de este tipo de juegos y ofrece un conjunto de herramientas para "
"facilitarlo."

#: src/theory/faqs.md:11
msgid "#### What is the Dojo roadmap?"
msgstr "#### ¿Cuál es el roadmap de Dojo?"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) and join the [Discord](https://"
"discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas for the project, "
"please open an issue."
msgstr ""
"Dojo evoluciona rápidamente. Puedes encontrar temas abiertos en [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) y unirte a [Discord](https://"
"discord.gg/vUN4Xq9Qv6) para participar. Si tienes ideas para el proyecto, "
"abre una incidencia."

#: src/theory/faqs.md:15
msgid "#### What is an onchain game?"
msgstr "#### ¿Qué es un juego onchain?"

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""
"Los juegos onchain son juegos que existen enteramente en una red pública "
"blockchain; todos los estados y la lógica son onchain. Los clientes (como "
"los navegadores web) no existen en la cadena, sino únicamente para "
"interactuar con el estado onchain e interpretarlo."

#: src/theory/faqs.md:19
msgid "#### What is an autonomous world?"
msgstr "#### ¿Qué es un mundo autónomo?"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous Worlds](../theory/"
"autonomous-worlds.md)."
msgstr ""
"Un mundo autónomo es aquel que existe completamente en cadena. No está "
"controlado por ninguna entidad, sino que se rige por las normas establecidas "
"dentro de ese mundo. Profundiza en el tema aquí: [Mundos autónomos](../"
"theory/autonomous-worlds.md)."

#: src/theory/faqs.md:23
msgid "#### What is Cairo?"
msgstr "#### ¿Qué es Cairo?"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a low-"
"level language designed to compile to the Cairo Virtual Machine. Learn more "
"about it here: [Cairo](../theory/cairo.md)."
msgstr ""
"Cairo es un lenguaje de programación de código abierto inventado por "
"Starkware. Es un lenguaje Turing-completo pensado para computación de "
"propósito general. Es un lenguaje de bajo nivel diseñado para compilar en la "
"máquina virtual Cairo. Más información aquí: [Cairo](../theory/cairo.md)."

#: src/theory/faqs.md:27
msgid "#### What is a provable game?"
msgstr "#### ¿Qué es un juego demostrable?"

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""
"Gracias a la magia de las zero-knowledge proofs, podemos asegurarnos de que "
"un juego es justo verificando una prueba zk creada fuera de la cadena. Pero, "
"¿qué implica eso? Pensemos en una partida de ajedrez. Nuestro objetivo es "
"que los jugadores confíen en las jugadas de los demás. En un enfoque directo "
"— y dadas las sencillas reglas del ajedrez — si esto fuera en un entorno de "
"cadena de bloques, cada jugada sería una transacción en la cadena de "
"bloques. Esto es costoso. Sólo queremos saber quién es el ganador, no cada "
"jugada."

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""
"Con las pruebas zk y las comunicaciones cliente, los jugadores pueden "
"establecer un canal de estado, compartiendo movimientos fuera de la cadena y "
"garantizando su validez. Al final, se puede enviar una prueba zk a la cadena "
"de bloques para confirmar la equidad del juego. Esto constituye un juego "
"demostrable."

#: src/getting-started/quick-start.md:1
msgid "## Quick Start"
msgstr "## Inicio Rápido"

#: src/getting-started/quick-start.md:3
msgid ""
"> It is worth reading [theory](../theory/autonomous-worlds.md) to "
"familiarize yourself with the concept of Autonomous Worlds (AWs) and the "
"[Cairo ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""
"> Merece la pena leer [teoría](../theory/autonomous-worlds.md) para "
"familiarizarse con el concepto de Mundos Autónomos (MA) y el [ecosistema de "
"Cairo](../theory/cairo.md) antes de sumergirse en el código."

#: src/getting-started/quick-start.md:6
msgid "### Install Dojoup"
msgstr "### Instalando Dojoup"

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup [here](https://github.com/dojoengine/dojo/blob/master/dojoup/README."
"md)."
msgstr ""
"Dojo está construido alrededor de un conjunto de herramientas de desarrollo "
"- Katana, Torii y Sozo. Instálalas todas fácilmente con Dojoup. Puedes "
"encontrar información detallada sobre Dojoup [aquí](https://github.com/"
"dojoengine/dojo/blob/master/dojoup/README.md)."

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"

#: src/getting-started/quick-start.md:14
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen, "
"which will make the `dojoup` command available in your CLI."
msgstr ""
"Esto instalará Dojoup, luego simplemente sigue las instrucciones que "
"aparecen en pantalla,\n"
"lo que hará que el comando `dojoup` esté disponible en tu línea de comandos "
"(CLI)."

#: src/getting-started/quick-start.md:17 src/toolchain/dojoup.md:15
msgid ""
"```sh\n"
"dojoup\n"
"```"
msgstr ""
"```sh\n"
"dojoup\n"
"```"

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup."
"md)."
msgstr ""
"Para una referencia completa y depuración de `dojoup` ver [Dojoup](../"
"toolchain/dojoup.md)."

#: src/getting-started/quick-start.md:23
msgid "### Next steps"
msgstr "### Próximos pasos"

#: src/getting-started/quick-start.md:25
msgid ""
"> Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""
"> Dirígete a [Hello Dojo](../cairo/hello-dojo.md) para crear tu primer mundo "
"Dojo."

#: src/getting-started/from-source.md:1
msgid "## Building from source"
msgstr "## Construyendo desde el origen"

#: src/getting-started/from-source.md:3
msgid ""
"> If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""
"> Si sólo quieres jugar con la cadena de herramientas, te recomendamos "
"encarecidamente que sigas la guía [Quick Start](./quick-start.md)."

#: src/getting-started/from-source.md:5
msgid "#### Prerequisites"
msgstr "#### Requisitos previos"

#: src/getting-started/from-source.md:7
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager. The easiest way to install both is with [`rustup.rs`]"
"(https://rustup.rs/)."
msgstr ""
"Necesitarás el compilador de [Rust](https://rust-lang.org) y Cargo, el "
"gestor de paquetes de Rust.\n"
"La forma más sencilla de instalar ambos es utilizando [`rustup.rs`](https://"
"rustup.rs/)."

#: src/getting-started/from-source.md:10
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://"
"visualstudio.microsoft.com/downloads/), installed with the \"Desktop "
"Development With C++\" Workloads option."
msgstr ""
"En Windows, también necesitarás una versión reciente de [Visual Studio]"
"(https://visualstudio.microsoft.com/downloads/),\n"
"instalada con la opción \"Desarrollo de escritorio con C++\" en las cargas "
"de trabajo."

#: src/getting-started/from-source.md:13
msgid "#### Building"
msgstr "#### Compilando"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "Puedes utilizar las diferentes opciones de [Dojoup](#using-dojoup):"

#: src/getting-started/from-source.md:17
msgid ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "O bien, utilizando un solo comando de Cargo:"

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://"
"github.com/dojoengine/dojo):"
msgstr ""
"O bien, construyendo manualmente desde una copia local del [repositorio de "
"Dojo](https://github.com/dojoengine/dojo):"

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"

#: src/getting-started/setup.md:1
msgid "# Development Setup"
msgstr "# Configuración de desarrollo"

#: src/getting-started/setup.md:3
msgid ""
"> This article is a guide to setting up a development environment for Dojo. "
"It is not suggested to follow this guide if you are just wanting to play "
"with the toolchain. We strongly suggest following the [Quick Start](../"
"getting-started/quick-start.md) guide."
msgstr ""
"> Este artículo es una guía para configurar un entorno de desarrollo para "
"Dojo. No se sugiere seguir esta guía si sólo quieres jugar con la cadena de "
"herramientas. Sugerimos encarecidamente seguir la guía [Quick Start](../"
"getting-started/quick-start.md)."

#: src/getting-started/setup.md:5
msgid "### Prerequisites"
msgstr "#### Requisitos previos"

#: src/getting-started/setup.md:7
msgid ""
"- Rust\n"
"- Cairo"
msgstr ""
"- Rust\n"
"- Cairo"

msgid "## Guide"
msgstr "## Guía"

#: src/getting-started/setup.md:14
msgid "### Clone"
msgstr "### Clonar"

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"

#: src/getting-started/setup.md:20
msgid "### Linux & Mac"
msgstr "### Linux & Mac"

#: src/getting-started/setup.md:22
msgid "#### 1. Install Rust and Dependencies"
msgstr "#### 1. Instalar Rust y Dependencias"

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr ""
"Comienza instalando Rust y ejecutando el conjunto de pruebas para confirmar "
"la configuración:"

#: src/getting-started/setup.md:26
msgid ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"
msgstr ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"

#: src/getting-started/setup.md:30
msgid ""
"Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""
"> Nota: Dependiendo de la distribución de Linux que estés usando, es posible "
"que necesites instalar dependencias adicionales. Asegúrate de instalar todas "
"las dependencias sugeridas o faltantes que surjan durante el proceso de "
"configuración."

#: src/getting-started/setup.md:32
msgid "#### 2. Install Scarb Package Manager"
msgstr "#### 2. Instalar el administrador de paquetes Scarb"

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""
"Luego, instala el gestor de paquetes [Scarb](https://docs.swmansion.com/"
"scarb) ejecutando el siguiente comando:"

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"

#: src/getting-started/setup.md:40
msgid "#### 3. Add the Cairo 1.0 VSCode Extension"
msgstr "#### 3. Configura la extensión de Cairo para VSCode"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) extension for Visual Studio Code."
msgstr ""
"Instale la extensión [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) para Visual Studio Code."

#: src/getting-started/setup.md:45
msgid "### Windows"
msgstr "### Windows"

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "_Próximamente_"

#: src/getting-started/setup.md:49
msgid "### Container"
msgstr "### Contenedor"

#: src/getting-started/contributing.md:1
msgid "# Contributing to the Core"
msgstr "# Contribuyendo al Core"

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""
"Dojo es un proyecto de open-source, actualmente en su fase inicial de "
"desarrollo, y da una calurosa bienvenida a los colaboradores."

#: src/getting-started/contributing.md:5
msgid "## How to Contribute"
msgstr "### Formas de Contribuir"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""
"Dirígete a [Github](https://github.com/dojoengine/dojo/issues) para ver las "
"incidencias abiertas, si ves una incidencia que no está asignada, por favor "
"solicita en los comentarios que te la asignen. Si tienes una idea para una "
"nueva funcionalidad, crea una incidencia con la etiqueta `enhancement`."

#: src/community/get-started.md:1
msgid "## Get Started"
msgstr "## Primeros pasos"

#: src/community/get-started.md:3
msgid ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"

#: src/cairo/hello-dojo.md:1
msgid "# Hello Dojo"
msgstr "# Hola Dojo"

#: src/cairo/hello-dojo.md:3
msgid ""
"> This section assumes that you have already installed the Dojo toolchain "
"and are familiar with Cairo. If not, please refer to the [Getting Started]"
"(../getting-started/quick-start.md) section."
msgstr ""
"> Esta sección asume que ya has instalado la cadena de herramientas Dojo y "
"estás familiarizado con Cairo. Si no es así, por favor consulta la sección "
"[Primeros pasos](../getting-started/quick-start.md)."

#: src/cairo/hello-dojo.md:5
msgid "## Dojo in 15 Minutes"
msgstr "## Dojo en 15 minutos"

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""
"Piensa en Dojo como una abstracción sobre Cairo, similar a lo que React es "
"para JavaScript. Te permite escribir comandos abreviados que se expanden en "
"consultas complejas durante el tiempo de compilación. Dojo se basa en la "
"conocida arquitectura Entity Component System (ECS)."

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""
"En Dojo, diseñas tus mundos utilizando Sistemas y Componentes. Los sistemas "
"describen la lógica de tu mundo, mientras que los componentes representan el "
"estado. Este poderoso patrón te permite estructurar tu lógica de una manera "
"altamente modular. Si aún no entiendes esto, no te preocupes; "
"profundizaremos en ello más adelante."

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""
"Para empezar, vamos a configurar un proyecto para ejecutarlo localmente en "
"tu máquina. Desde un directorio vacío, ejecuta:"

#: src/cairo/hello-dojo.md:13
msgid ""
"```console\n"
"sozo init\n"
"```"
msgstr ""
"```console\n"
"sozo init\n"
"```"

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""
"¡Enhorabuena! Ahora tienes un proyecto Dojo local. Este comando crea un "
"proyecto `dojo-starter` en tu directorio actual. Es el punto de partida "
"ideal para un nuevo proyecto y te equipa con todo lo que necesitas para "
"empezar."

#: src/cairo/hello-dojo.md:19
msgid "#### Anatomy of a Dojo Project"
msgstr "#### Anatomía de un proyecto Dojo"

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""
"Inspecciona el contenido del proyecto `dojo-starter`, y verás la siguiente "
"estructura (excluyendo los archivos que no son de CAIRO):"

#: src/cairo/hello-dojo.md:23
msgid ""
"```bash\n"
"src\n"
"  - components.cairo\n"
"  - systems.cairo\n"
"  - lib.cairo\n"
"Scarb.toml\n"
"```"
msgstr ""
"```bash\n"
"src\n"
"  - components.cairo\n"
"  - systems.cairo\n"
"  - lib.cairo\n"
"Scarb.toml\n"
"```"

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr "Abra el archivo `src/components.cairo` para continuar."

#: src/cairo/hello-dojo.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"...rest of code\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"...rest of code\n"
"```"

#: src/cairo/hello-dojo.md:54
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we *must* include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""
"Observe los atributos `#[derive(Component, Copy, Drop, Serde, SerdeLen)]`. "
"Para que un componente sea reconocido, *debemos* incluir `Component`. Esto "
"indica al compilador de Dojo que esta estructura debe ser tratada como un "
"componente."

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""
"Nuestro componente `Moves` alberga un valor `remaining` en su estado. El "
"atributo `#[key]` informa a Dojo que este componente está indexado por el "
"campo `player`. Si esto no te resulta familiar, aclararemos su importancia "
"más adelante en el capítulo. Esencialmente, implica que puedes consultar "
"este componente usando el campo `player`."

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""
"De forma similar, poseemos un componente `Position` que contiene los valores "
"`x` e `y`. Una vez más, este componente está indexado por el campo `jugador´."

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr "Ahora, examinemos el archivo `src/systems.cairo`:"

#: src/cairo/hello-dojo.md:62
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                },\n"
"                Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                },\n"
"                Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr "Vamos a desglosarlo:"

#: src/cairo/hello-dojo.md:93
msgid ""
"```rust,ignore\n"
"#[system]\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"```"

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""
"Al igual que usamos el atributo `#[derive(Component)]`, el atributo "
"`#[system]` informa al compilador de Dojo que esta estructura es un sistema, "
"ordenándole que compile en consecuencia."

#: src/cairo/hello-dojo.md:99
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context)\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn execute(ctx: Context)\n"
"```"

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""
"Observarás que el sistema tiene una función `execute`. Es crucial tener en "
"cuenta que todos los sistemas Dojo necesitan una función `execute`. Esta "
"función acepta un `Context` como parámetro. El `Context` es una estructura "
"distinta que proporciona información sobre el mundo y la persona que llama."

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""
"Vale la pena mencionar que un sistema puede contener más que la función "
"`execute`. Usted es libre de incluir numerosas funciones según sea "
"necesario. Sin embargo, la función `execute` es obligatoria, ya que se "
"invoca cuando se ejecuta el sistema."

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr "Ahora veamos la siguiente línea:"

#: src/cairo/hello-dojo.md:109
msgid ""
"```rust,ignore\n"
"let position = get!(ctx.world, ctx.origin, (Position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"let position = get!(ctx.world, ctx.origin, (Position));\n"
"```"

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""
"Aquí usamos `get!` [command](./commands.md) para recuperar el componente "
"`Position` para la entidad `ctx.origin`. `ctx.origin` es la dirección de la "
"entidad que realiza la llamada. Cuando se llame por primera vez, devolverá:"

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr "Ahora la siguiente línea:"

#: src/cairo/hello-dojo.md:125
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Moves {\n"
"            player: ctx.origin, remaining: 10\n"
"            }, Position {\n"
"            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Moves {\n"
"            player: ctx.origin, remaining: 10\n"
"            }, Position {\n"
"            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""
"Aquí usamos el comando `set!`(./commands.md) para establecer los componentes "
"`Moves` y `Position` para la entidad `ctx.origin`."

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr "Hemos hablado mucho en poco tiempo. Recapitulemos:"

#: src/cairo/hello-dojo.md:142
msgid ""
"-   Explained the anatomy of a Dojo project\n"
"-   Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute\n"
"-   Explained the `execute` function\n"
"-   Explained the `Context` struct\n"
"-   Touched on the `get!` and `set!` commands"
msgstr ""
"- Explicación de la anatomía de un proyecto Dojo\n"
"- Explicación de la importancia de los atributos `#[derive(Component)]` y "
"`#[system]`.\n"
"- Explicación de la función `execute`\n"
"- Explicación de la estructura `Context`\n"
"- Los comandos `get!` y `set!`"

#: src/cairo/hello-dojo.md:149
msgid "### Run it locally!"
msgstr "### ¡Ejecútalo localmente!"

#: src/cairo/hello-dojo.md:151
msgid ""
"Now that we have some theory out of the way, lets build the Dojo project!"
msgstr "Una vez aclarada la teoría, ¡vamos a construir el proyecto Dojo!"

#: src/cairo/hello-dojo.md:153 src/deployment/locally.md:29
msgid ""
"```bash\n"
"sozo build\n"
"```"
msgstr ""
"```bash\n"
"sozo build\n"
"```"

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""
"¡Eso compiló los componentes y el sistema en un artefacto que puede ser "
"desplegado! ¡Así de sencillo!"

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""
"¡Ahora vamos a desplegarlo en [Katana](../toolchain/katana/overview.md)! "
"Primero tenemos que hacer que Katana funcione:"

#: src/cairo/hello-dojo.md:161 src/deployment/locally.md:13
msgid ""
"```bash\n"
"katana --disable-fee\n"
"```"
msgstr ""
"```bash\n"
"katana --disable-fee\n"
"```"

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""
"¡Éxito! [Katana](../toolchain/katana/overview.md) debería estar ejecutándose "
"localmente en tu máquina. ¡Ahora vamos a desplegar!"

#: src/cairo/hello-dojo.md:167 src/deployment/locally.md:23
msgid ""
"```bash\n"
"sozo migrate --name test\n"
"```"
msgstr ""
"```bash\n"
"sozo migrate --name test\n"
"```"

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""
"Esto desplegará el artefacto en [Katana](../toolchain/katana/overview.md). "
"Debería ver una salida de terminal similar a esta:"

#: src/cairo/hello-dojo.md:173
msgid ""
"```bash\n"
"Migration account: "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 7\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (7): New 7 Update 0\n"
"  \n"
"# Executor\n"
"  > Contract address: "
"0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
"# World\n"
"  > Contract address: "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"# Components (2)\n"
"Moves\n"
"  > class hash: "
"0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
"Position\n"
"  > class hash: "
"0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
"# Systems (3)\n"
"spawn\n"
"  > class hash: "
"0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
"move\n"
"  > class hash: "
"0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
"library_call\n"
"  > class hash: "
"0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
"\n"
"🎉 Successfully migrated World on block #4 at address "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"```"
msgstr ""
"```bash\n"
"Migration account: "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 7\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (7): New 7 Update 0\n"
"  \n"
"# Executor\n"
"  > Contract address: "
"0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
"# World\n"
"  > Contract address: "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"# Components (2)\n"
"Moves\n"
"  > class hash: "
"0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
"Position\n"
"  > class hash: "
"0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
"# Systems (3)\n"
"spawn\n"
"  > class hash: "
"0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
"move\n"
"  > class hash: "
"0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
"library_call\n"
"  > class hash: "
"0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
"\n"
"🎉 Successfully migrated World on block #4 at address "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"```"

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""
"¡Tu 🌎 ya está desplegado en "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""
"Vamos a discutir el archivo `Scarb.toml` en el proyecto. Este archivo "
"contiene variables de entorno que hacen que la ejecución de comandos CLI en "
"su proyecto sea una brisa. (Lee más sobre esto [aquí](./config.md))."

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr "Añade la dirección mundial al final del archivo:"

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""
"Esto establece la dirección del mundo para su proyecto. A continuación, "
"puede ejecutar comandos como:"

#: src/cairo/hello-dojo.md:215
msgid ""
"```bash\n"
"sozo execute spawn\n"
"```"
msgstr ""
"```bash\n"
"sozo execute spawn\n"
"```"

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""
"Al hacerlo, acabas de activar el sistema de spawn. Ahora tienes un mundo "
"local con el que puedes interactuar."

#: src/cairo/hello-dojo.md:221
msgid "### Indexing"
msgstr "### Indexación"

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""
"Con tu mundo local configurado, vamos a profundizar en la indexación. Puedes "
"indexar el mundo entero con este simple comando:"

#: src/cairo/hello-dojo.md:225
msgid ""
"```bash\n"
"torii\n"
"```"
msgstr ""
"```bash\n"
"torii\n"
"```"

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""
"Ejecutando lo anterior se activa un servidor torii local usando SQLite como "
"base de datos, que se expone en `http://0.0.0.0:8080`. Indexará "
"automáticamente tu mundo en tablas, permitiéndote consultarlas usando "
"GraphQL."

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr "Hemos hablado de muchas cosas. He aquí un resumen:"

#: src/cairo/hello-dojo.md:233
msgid ""
"-   Built a Dojo world\n"
"-   Deployed the project to Katana\n"
"-   Ran the spawn system locally\n"
"-   Indexed the world with Torii"
msgstr ""
"- Construir un mundo Dojo\n"
"- Despliegue del proyecto en Katana\n"
"- Ejecutar el sistema de spawn localmente\n"
"- Indexado el mundo con Torii"

#: src/cairo/hello-dojo.md:238
msgid "### Next Steps"
msgstr "### Próximos Pasos"

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""
"Esta visión general proporciona un rápido vistazo de principio a fin de "
"Dojo. Sin embargo, ¡el potencial de estos mundos es enorme! Diseñado para "
"gestionar cientos de sistemas y componentes, Dojo está equipado para la "
"creatividad expansiva. ¿Qué es lo próximo que vas a crear?"

#: src/cairo/config.md:1
msgid "# Config"
msgstr "# Configuración"

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a [Scarb]"
"(https://docs.swmansion.com/scarb/) file which is an excellent Cairo package "
"manager and project manager."
msgstr ""
"Los mundos Dojo se definen en sus archivos Scarb.toml. Esto no es más que un "
"archivo [Scarb](https://docs.swmansion.com/scarb/) que es un excelente "
"gestor de paquetes y proyectos de Cairo."

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr "Ejemplo completo de un archivo Scarb.toml:"

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"

#: src/cairo/world.md:1
msgid "## World Contract"
msgstr "## Contrato del Mundo"

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""
"El contrato de mundo funciona como un núcleo central del sistema, sirviendo "
"de base para iniciar y resolver todas las interacciones. Dentro de este "
"núcleo, los contratos se despliegan, registran y ejecutan, agilizando el "
"proceso para los sistemas posteriores al permitir a los clientes interactuar "
"con un único contrato en lugar de con cientos."

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""
"El núcleo de Dojo abstrae este contrato del desarrollador, como "
"desarrollador no lo escribes y no está pensado para ser alterado cuando se "
"construye un mundo. Sin embargo, es importante entender cómo funciona y cómo "
"interactúa con el resto del sistema."

#: src/cairo/world.md:8
msgid ""
"> **To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""
"> **Para tener en cuenta:** Considera los Mundos Autónomos como blockchains "
"soberanas que residen dentro de otra blockchain, una blockchain anidada, por "
"así decirlo. Así como puedes desplegar contratos en Ethereum para mejorar su "
"funcionalidad, de manera similar puedes introducir sistemas en el contrato "
"del Mundo para enriquecer sus características. Si bien cualquiera puede "
"contribuir al Mundo, al igual que en Ethereum, se requiere autorización para "
"interactuar con el estado de los componentes. Existe un tema dedicado a la "
"Autorización."

#: src/cairo/world.md:11
msgid "### Context"
msgstr "### Context"

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""
"Verás que todos los sistemas aceptan una estructura `Context` como primer "
"parámetro. Esta es una estructura especial que contiene información sobre el "
"mundo y la persona que llama."

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"

#: src/cairo/world.md:25
msgid "### The `uuid()` command"
msgstr "### El comando `uuid()`"

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""
"A menudo es útil generar IDs únicos para las entidades. La función `uuid()` "
"puede utilizarse para generar un ID único."

#: src/cairo/world.md:29 src/cairo/commands.md:20 src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr "Úsalo así:"

#: src/cairo/world.md:31
msgid ""
"```rust,ignore\n"
"let game_id = ctx.world.uuid();\n"
"```"
msgstr ""
"```rust,ignore\n"
"let game_id = ctx.world.uuid();\n"
"```"

#: src/cairo/world.md:36
msgid "### Full World API"
msgstr "### Full API Mundo"

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""
"El mundo expone una interfaz con la que puede interactuar cualquier cliente."

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"

#: src/cairo/components.md:1
msgid "## Components"
msgstr "## Componentes"

#: src/cairo/components.md:3
msgid "> Components = Data"
msgstr "> Components = Data"

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""
"Los componentes sirven de base para definir la estructura del mundo, "
"encapsulando el estado para que los sistemas muten. "

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""
"Al diseñar los componentes de un mundo, es crucial considerar cuidadosamente "
"las abstracciones que se crean, manteniendo siempre en mente la "
"composabilidad."

#: src/cairo/components.md:10
msgid "### Components are Structs"
msgstr "### Los Componentes son Structs"

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""
"Los componentes se definen como structs en Cairo. Pueden contener cualquier "
"número de campos, sin embargo, la mejor práctica en ECS es tener pequeños "
"componentes aislados. Esto promueve la modularidad y la componibilidad, lo "
"que le permite reutilizar los componentes a través de múltiples tipos de "
"entidades."

#: src/cairo/components.md:14
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"

#: src/cairo/components.md:23
msgid "#### The #[key] attribute"
msgstr "#### El atributo #[key]"

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""
"El atributo `#[key]` indica a Dojo que este componente está indexado por el "
"campo `player`. Es necesario definir una clave para cada componente, ya que "
"así es como se consulta el componente. Sin embargo, puedes crear claves "
"compuestas definiendo múltiples campos como claves. "

#: src/cairo/components.md:27
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""
"En este caso, deberá configurar el componente con los campos de reproductor "
"y ubicación:"

#: src/cairo/components.md:40
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Resource {\n"
"            player: ctx.origin,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Resource {\n"
"            player: ctx.origin,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/components.md:53
msgid "#### Implementing Traits"
msgstr "#### Implementación de Traits"

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""
"Los componentes pueden implementar traits. Esto es útil para definir "
"funcionalidades comunes entre componentes. Por ejemplo, puedes definir un "
"componente `Position` que implemente un trait `PositionTrait`. Este trait "
"podría definir funciones como `is_zero` y `is_equal` que podrían utilizarse "
"al acceder al componente."

#: src/cairo/components.md:57
msgid ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:77
msgid "#### Custom Setting Components"
msgstr "##### Métodos Personalizados"

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""
"Supongamos que necesitamos un lugar donde guardar un valor global con la "
"flexibilidad de modificarlo en el futuro. Tomemos, por ejemplo, un parámetro "
"global combat_cool_down que defina la duración necesaria para que una "
"entidad esté preparada para otro ataque. Para lograrlo, podemos crear un "
"componente dedicado a almacenar este valor, permitiendo al mismo tiempo su "
"modificación a través de un modelo de gobierno descentralizado."

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""
"Para establecer estos componentes, seguiría el método de creación habitual. "
"Sin embargo, al inicializarlos, emplee un identificador constante, como "
"GAME_SETTINGS_ID."

#: src/cairo/components.md:83
msgid ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "
msgstr ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "

#: src/cairo/components.md:94
msgid "#### Types"
msgstr "#### Tipos"

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr "Tipos de componentes compatibles:"

#: src/cairo/components.md:98
msgid ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`"
msgstr ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`"

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr "Actualmente no es posible utilizar Arrays."

#: src/cairo/components.md:109
msgid "### In practice with modularity in mind"
msgstr "### En la práctica teniendo en cuenta la modularidad"

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""
"Considere una analogía tangible: Humanos y Trasgos. Aunque poseen "
"diferencias intrínsecas, comparten rasgos comunes, como tener una posición y "
"salud. Sin embargo, los humanos poseen un componente adicional. Además, "
"introducimos un componente Contador, un rasgo distintivo que cuenta el "
"número de humanos y goblins."

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""
"Así, el Humano tendrá un componente `Potions`, `Health` y `Position`, y el "
"Trasgo tendrá un componente `Health` y `Position`. Así nos ahorramos tener "
"que crear componentes de Salud y Posición para cada tipo de entidad."

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr "Entonces un sistema sería así:"

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:218
msgid ""
"> A complete example can be found in the [Dojo Starter](https://github.com/"
"dojoengine/dojo-starter)"
msgstr ""
"> Puede encontrar un ejemplo completo en el [Dojo Starter](https://github."
"com/dojoengine/dojo-starter)"

#: src/cairo/systems.md:1
msgid "## Systems"
msgstr "## Sistemas"

#: src/cairo/systems.md:3
msgid "> Systems = Logic"
msgstr "> Systems = Logic"

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""
"Los sistemas sustentan la lógica de tu mundo. Aunque los sistemas son "
"intrínsecamente apátridas, su función principal es modificar el estado de "
"los componentes. Cada sistema cuenta con una función `execute` a la que se "
"recurre durante las interacciones dentro del mundo."

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr ""
"Veamos el sistema más sencillo posible, que muta el estado del componente "
"`Moves`."

#: src/cairo/systems.md:9
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod Spawn {\n"
"    use array::ArrayTrait;\n"
"    use traits::Into;\n"
"\n"
"    use dojo::world::Context;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        set !(\n"
"            ctx.world, ctx.origin, (\n"
"                Moves { player: ctx.origin, remaining: 10 }\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod Spawn {\n"
"    use array::ArrayTrait;\n"
"    use traits::Into;\n"
"\n"
"    use dojo::world::Context;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        set !(\n"
"            ctx.world, ctx.origin, (\n"
"                Moves { player: ctx.origin, remaining: 10 }\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:31
msgid "### The Execute function"
msgstr "### La función Execute"

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""
"La función `execute` es obligatoria en un sistema y se ejecuta cuando se "
"llama, tomando `Context` como primer parámetro. Más información en [Context]"
"(./mundo.md)."

#: src/cairo/systems.md:35
msgid "### Other functions in a System"
msgstr "### Otras funciones en un Sistema"

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""
"Eres libre de añadir otras funciones a tu sistema, pero no serán invocables "
"desde el mundo. Esto es útil para dividir tu lógica en trozos más pequeños."

#: src/cairo/systems.md:39
msgid "### Using View Functions"
msgstr "### Uso de las funciones View"

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""
"Hay ocasiones en las que necesitamos calcular el valor de un componente de "
"forma dinámica, en lugar de obtener su estado estático. Por ejemplo, en el "
"contexto de un VRGDA, si quieres saber el precio actual, no basta con "
"consultar el estado del componente. En su lugar, necesitarás calcular el "
"precio basándote en ciertos parámetros y en el estado actual."

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr "Aquí es donde entran en juego las funciones View."

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr "**¿Qué son las funciones View?**"

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""
"Las funciones View son una forma de derivar o calcular valores a partir del "
"estado actual de un componente. Son invocadas por el mundo y reciben como "
"argumento el estado actual del componente. Posteriormente, estas funciones "
"devuelven un valor calculado basado en este estado."

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr "**Ejemplo de VRGDA**:"

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this link]"
"(https://github.com/dojoengine/dojo-examples), illustrates how to implement "
"a view function:"
msgstr ""
"El siguiente fragmento, tomado del ejemplo VRGDA disponible en [este enlace]"
"(https://github.com/dojoengine/dojo-examples), ilustra cómo implementar una "
"función view:"

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""
"En este ejemplo, la función calcula y devuelve el precio actual del VRGDA "
"basándose en el estado actual de la subasta."

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr "**¿Cómo Invocar Funciones View?**"

#: src/cairo/systems.md:80
msgid ""
"- **Using Dojo Core**: If you are working within the [Dojo Core](../client/"
"npm/core.md), utilize the `call` function. \n"
"  \n"
"- **For Rust Users**: The [Starkli](https://book.starkli.rs/) library "
"provides a handy method to invoke view functions in Rust."
msgstr ""
"- Utilizando Dojo Core**: Si estás trabajando dentro del [Dojo Core](../"
"client/npm/core.md), utiliza la función `call`. \n"
"  \n"
"- Para usuarios de Rust**: La librería [Starkli](https://book.starkli.rs/) "
"proporciona un método práctico para invocar funciones de vista en Rust."

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""
"¡Espero que esta versión revisada mejore la claridad y fluidez de la "
"información que desea transmitir!"

#: src/cairo/systems.md:86
msgid "### System Authentication"
msgstr "### Autenticación del Sistema"

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""
"Los sistemas deben tener permiso para escribir en los componentes. Por "
"defecto no tienen permisos. Sin embargo, con `sozo` podemos darles permisos "
"para escribir en los componentes."

#: src/cairo/systems.md:90
msgid ""
"```console\n"
"sozo auth writer Moves Spawn \n"
"```"
msgstr ""
"```console\n"
"sozo auth writer Moves Spawn \n"
"```"

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""
"Aquí hemos autorizado al sistema `Spawn` a escribir en el componente `Moves`."

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""
"Más información en la documentación de [sozo](../toolchain/sozo/overview.md)."

#: src/cairo/entities.md:1
msgid "## Entities"
msgstr "## Entidades"

#: src/cairo/entities.md:3
msgid ""
"> Entities are the primary key value within the world, to which components "
"can be attached."
msgstr ""
"> Las entidades son el valor clave primario dentro del mundo, al que se "
"pueden adjuntar componentes."

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""
"Diferentes sistemas ECS manejan las entidades de diferentes maneras. En "
"Dojo, las entidades son tratadas como un valor clave primario dentro del "
"mundo, al que se le pueden adjuntar componentes. Para ilustrar este "
"concepto, considere un ejemplo simple de un personaje en un juego que tiene "
"un componente `Moves` y un componente `Position`."

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""
"Al definir los componentes de esta entidad, es importante señalar que no "
"hacemos referencia a la entidad directamente. En su lugar, simplemente "
"proporcionamos dos structs que contendrá la entidad. "

#: src/cairo/entities.md:9
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the `ctx."
"origin` to reference the current entity."
msgstr ""
"Ahora, vamos a crear un `Spawn` para el personaje. Es importante notar que "
"no hemos definido explícitamente una entidad en ninguna parte. En su lugar, "
"utilizamos el `ctx.origin` para hacer referencia a la entidad actual."

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr ""
"En este ejemplo estamos utilizando el `ctx.origin` para hacer referencia a "
"la entidad actual."

#: src/cairo/entities.md:30
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/entities.md:58
msgid ""
"> ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-"
"FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""
"> Teoría ECS: Se ha escrito mucho sobre los sistemas ECS, para profundizar "
"lea [ECS-FAQ](https://github.com/SanderMertens/ecs-faq)"

#: src/cairo/authorization.md:1
msgid "## Authorization"
msgstr "## Autorización"

#: src/cairo/authorization.md:3
msgid ""
"> Authorization is crucial to a world, just like how authorization is "
"crucial to any smart contract."
msgstr ""
"> La autorización es crucial para un mundo, al igual que la autorización es "
"crucial para cualquier contrato inteligente."

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""
"Como se explica en el capítulo [Mundo](./world.md), los Mundos Autónomos "
"(MEA) funcionan como cadenas soberanas anidadas dentro de una blockchain "
"pública. Estos Mundos también están abiertos al público. Esta estructura "
"permite a cualquiera mejorar un Mundo desplegando componentes o sistemas. "
"Sin embargo, esta apertura también introduce consideraciones de seguridad. "
"Al igual que en Ethereum, la interacción con el estado de un componente "
"dentro de un Sistema requiere la autorización adecuada del propietario del "
"componente."

#: src/cairo/authorization.md:7
msgid "### Auth Architecture"
msgstr "### Arquitectura Auth"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""
"Cada vez que se llama a `set!` en un `System`, el mundo comprueba si el "
"`System` tiene autorización para actualizar el estado del componente. Sólo "
"cuando el `\n"
"System` posee la autorización necesaria, se ejecuta el \"set\". El siguiente "
"diagrama ilustra la arquitectura de autorización."

#: src/cairo/authorization.md:11
msgid "Authorization Architecture"
msgstr "Arquitectura de Autorización"

#: src/cairo/authorization.md:13
msgid "### Providing Authorization"
msgstr "### Proporcionando Autorización"

#: src/cairo/authorization.md:15
msgid ""
"> The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""
"> El desplegador del Componente es su propietario inicial. El propietario de "
"un Componente puede otorgar los roles `owner` y `writer`. Sólo los "
"propietarios pueden otorgar a un sistema el rol de `writer`, que le permite "
"actualizar el componente."

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr "`sozo` ofrece una cómoda herramienta para autorizar sistemas."

#: src/cairo/authorization.md:19
msgid ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"
msgstr ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""
"Este comando generará una autorización `writer` para que el sistema `spawn` "
"actualice el componente `Moves`."

#: src/cairo/commands.md:1
msgid "## Commands"
msgstr "## Comandos"

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""
"Entender los comandos es clave para comprender Dojo. Los utilizarás "
"ampliamente en los sistemas que diseñes."

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""
"Los comandos en Dojo son funciones generalizadas que se expanden en tiempo "
"de compilación para facilitar la ejecución de sistemas. Proporcionan una "
"forma conveniente para que los sistemas interactúen con el estado del mundo "
"al abstraer operaciones comunes, como obtener o actualizar componentes, y "
"generar IDs únicos. Al aprovechar estos comandos, los desarrolladores pueden "
"simplificar sus implementaciones de sistemas y mejorar la legibilidad del "
"código."

#: src/cairo/commands.md:8
msgid "### Using commands"
msgstr "## Usando comandos"

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""
"Los comandos se utilizan dentro de los sistemas para interactuar con el "
"estado del mundo. Se llaman usando la siguiente sintaxis:"

#: src/cairo/commands.md:12 src/cairo/commands.md:22
msgid ""
"```rust,ignore\n"
"let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
"```"
msgstr ""
"```rust,ignore\n"
"let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
"```"

#: src/cairo/commands.md:16
msgid "### The `get!` command"
msgstr "### El comando `get!`"

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr ""
"El comando `get!` se utiliza para recuperar componentes del estado del mundo."

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""
"Aquí estamos recuperando los componentes `Position` y `Moves` del estado del "
"mundo. También estamos utilizando el `ctx.origin` para recuperar los "
"componentes de la entidad actual."

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""
"A continuación, puede utilizar `position` y `moves` como lo haría con "
"cualquier otra estructura de Cairo."

#: src/cairo/commands.md:30
msgid "### The `set!` command"
msgstr "### El comando `set!`"

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr ""
"El comando `set!` se utiliza para actualizar el estado de los componentes."

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""
"Aquí estamos actualizando los componentes `Moves` y `Position` en el estado "
"del mundo usando el `ctx.origin` como id de la entidad."

#: src/cairo/commands.md:52
msgid "### The `emit!` command"
msgstr "### El comando `emit!`"

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr "El comando `emit!` se utiliza para emitir eventos personalizados."

#: src/cairo/commands.md:58 src/cairo/events.md:78
msgid ""
"```rust,ignore\n"
"emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"```"
msgstr ""
"```rust,ignore\n"
"emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"```"

#: src/cairo/events.md:1
msgid "## Events"
msgstr "## Events"

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/"
"overview.md), all these events are seamlessly indexed, ensuring easy and "
"efficient querying."
msgstr ""
"Los eventos juegan un papel fundamental en la decodificación de la dinámica "
"de un mundo Dojo. Cada vez que hay una actualización de un `Componente`, el "
"contrato `World` emite estos eventos. Lo que es aún más emocionante es que "
"puedes crear tus propios eventos personalizados para satisfacer necesidades "
"específicas. Además, gracias a [Torii](../toolchain/torii/overview.md), "
"todos estos eventos están perfectamente indexados, asegurando una consulta "
"fácil y eficiente."

#: src/cairo/events.md:6
msgid "### Component Events"
msgstr "### Componente Events"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr "Considere este ejemplo de un componente `Moves`:"

#: src/cairo/events.md:10
msgid ""
"```rust,ignore\n"
"#[component]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[component]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""
"Cuando se actualice este componente, el contrato `World` emitirá un evento "
"con la siguiente estructura:"

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""
"Esto será capturado por [Torii](../toolchain/torii/overview.md) e indexado "
"para su consulta. Esto le permitirá reconstruir el estado de su mundo."

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""
"Del mismo modo, cuando se elimina un componente, el contrato `World` emitirá "
"un evento con la siguiente estructura:"

#: src/cairo/events.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"

#: src/cairo/events.md:43
msgid "### World Events"
msgstr "### Events Mundo"

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""
"El contrato `World` también emite eventos cuando se inicializa y cuando se "
"registran nuevos componentes y sistemas. Estos eventos se emiten con las "
"siguientes estructuras:"

#: src/cairo/events.md:47
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"

#: src/cairo/events.md:55
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:63
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""
"Estos eventos también son capturados por [Torii](../toolchain/torii/overview."
"md) e indexados para su consulta."

#: src/cairo/events.md:74
msgid "### Custom Events"
msgstr "### Eventos Personalizados"

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""
"Dentro de tus sistemas, emitir eventos personalizados puede ser muy "
"beneficioso. Afortunadamente, existe una práctica macro `emit!` que te "
"permite emitir eventos directamente desde tu mundo. Úsala así:"

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr ""
"Incluye esto en tu sistema y emitirá un evento con la siguiente estructura:"

#: src/cairo/events.md:84
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr "Ahora un ejemplo completo usando un evento personalizado:"

#: src/cairo/events.md:94
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(ctx.world, ctx.origin, (Position, "
"Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(ctx.world, (moves, next));\n"
"    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"    return ();\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn execute(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(ctx.world, ctx.origin, (Position, "
"Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(ctx.world, (moves, next));\n"
"    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"    return ();\n"
"}\n"
"```"

#: src/cairo/events.md:107
msgid ""
"> Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""
"> Nota: Lea sobre las macros `get!` y `set!` en [Comandos](./commands.md)."

#: src/cairo/testing.md:1
msgid "## Testing"
msgstr "## Testing"

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""
"Las pruebas son una parte crucial de cualquier proceso de desarrollo de "
"software. Dojo proporciona un marco de pruebas que te permite escribir "
"pruebas para tus contratos inteligentes. Como Dojo usa un compilador "
"personalizado, necesitas usar `sozo` para probar tus contratos."

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr "Desde el directorio de su proyecto, simplemente:"

#: src/cairo/testing.md:7
msgid ""
"```shell\n"
"sozo test\n"
"```"
msgstr ""
"```shell\n"
"sozo test\n"
"```"

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr "Esto buscará todas las pruebas dentro de su proyecto y las ejecutará."

#: src/cairo/testing.md:14
msgid "### Writing Unit Tests"
msgstr "### Escribir Tests Unit"

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the Component/"
"System you are writing."
msgstr ""
"La mejor práctica es incluir los tests units en el mismo fichero que el "
"Component/System que se está escribiendo."

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the [dojo-starter](https://github."
"com/dojoengine/dojo-starter):"
msgstr ""
"Vamos a mostrar un ejemplo de prueba `Component` del [dojo-starter](https://"
"github.com/dojoengine/dojo-starter):"

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr "`components.cairo`"

#: src/cairo/testing.md:21
msgid ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not "
"zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, "
"y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not "
"zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, "
"y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""
"En esta prueba estamos comprobando las funciones `is_zero` y `is_equal` del "
"componente `Position`. Es una buena práctica probar todas las funciones de "
"los componentes."

#: src/cairo/testing.md:52
msgid "### Writing Integration Tests"
msgstr "### Escribir Tests de Integración"

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""
"Las pruebas de integración son pruebas e2e que prueban todo el sistema. "
"Puedes escribir pruebas de integración para tu mundo creando un directorio "
"`tests` en la raíz de tu proyecto. A continuación, cree un archivo para cada "
"prueba de integración que desee escribir."

#: src/cairo/testing.md:56
msgid ""
"This is the example from the [dojo-starter](https://github.com/dojoengine/"
"dojo-starter):"
msgstr ""
"Este es el ejemplo del [dojo-starter](https://github.com/dojoengine/dojo-"
"starter):"

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr "`systems.cairo`"

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"

#: src/cairo/testing.md:113
msgid "#### Useful Dojo Test Functions"
msgstr "#### Funciones de Test útiles de Dojo"

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""
"`spawn_test_world(components, systems)` - Esta función creará un mundo de "
"pruebas con los componentes y sistemas que introduzcas. También desplegará "
"el mundo y registrará los componentes y sistemas."

#: src/cairo/modules.md:1
msgid "## Dojo Modules"
msgstr "## Módulos Dojo"

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""
"Con la estandarización de Sistemas y Componentes podemos crear una "
"arquitectura de módulos para Dojo. Esto nos permite crear módulos "
"reutilizables que pueden ser usados en cualquier mundo Dojo."

#: src/cairo/modules.md:5
msgid "### Module Architecture"
msgstr "### Arquitectura del Módulo"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""
"Piensa en los módulos como ERCs para Dojo. Son una forma estándar de crear y "
"compartir funcionalidad. Los módulos son una colección de Sistemas y "
"Componentes que pueden ser importados a un mundo Dojo. Dojo sigue los "
"patrones ERC y ya tiene módulos definidos para ERC20, ERC721 y ERC1155."

#: src/cairo/modules/erc20.md:1
msgid "## ERC20"
msgstr "## ERC20"

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""
"El módulo ERC20 de Dojo es una implementación estándar del estándar de "
"tokens ERC20, pero utiliza Sistemas y Componentes Dojo. Esto nos permite "
"aprovechar las excelentes propiedades del estándar ERC20 y utilizarlo de "
"forma nativa dentro del entorno Dojo."

#: src/cairo/modules/erc20.md:5
msgid "### Integration into Your World"
msgstr "### Integración en Su Mundo"

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""
"Para integrar el módulo ERC20 en su mundo, primero debe desplegar el "
"contrato ERC20 Dojo. Posteriormente, instala los sistemas y componentes en "
"tu mundo."

#: src/client/overview.md:1
msgid "# Overview"
msgstr "## Visión general"

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""
"Dojo es BYO cliente, lo que significa que puedes utilizar cualquier cliente "
"que desees para conectarte a la red Dojo."

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr ""
"Los clientes de referencia están disponibles para las siguientes plataformas:"

#: src/client/overview.md:7
msgid "- [npm](./npm.md)"
msgstr "- [npm](./npm.md)"

#: src/client/npm.md:1
msgid "# Javascript Libraries"
msgstr "# Librerías Javascript "

#: src/client/npm.md:3
msgid ""
"> Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""
"> Javascript es una gran manera de empezar con Dojo. Es fácil de usar y "
"puedes empezar en cuestión de minutos."

#: src/client/npm.md:5
msgid "### Examples using these:"
msgstr "### Ejemplos usando estos:"

#: src/client/npm.md:7
msgid ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-"
"app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-"
"app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#: src/client/npm.md:10
msgid "### @dojoengine/core"
msgstr "### @dojoengine/core"

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""
"Esta es la librería de más bajo nivel, y es utilizada por todas las demás "
"librerías posteriores. Contiene la funcionalidad central de Dojo y expone "
"las interfaces contractuales. Úsala si quieres construir tu propia librería "
"sobre Dojo."

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr "[Documentación](./npm/core.md)"

#: src/client/npm.md:16 src/client/npm/core.md:12
msgid ""
"```console\n"
"yarn add @dojoengine/core\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/core\n"
"```"

#: src/client/npm.md:20
msgid "### @dojoengine/react"
msgstr "### @dojoengine/react"

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud React](https://github.com/latticexyz/mud/tree/"
"main/packages)"
msgstr ""
"Este es un fork directo de [Mud React](https://github.com/latticexyz/mud/"
"tree/main/packages)"

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""
"Esta librería contiene un conjunto de componentes React que pueden ser "
"usados cuando se construyen aplicaciones React usando Dojo."

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr "[Documentación](./npm/react.md)"

#: src/client/npm.md:28
msgid ""
"```console\n"
"yarn add @dojoengine/react\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/react\n"
"```"

#: src/client/npm.md:33
msgid "### @dojoengine/create-burner"
msgstr "### @dojoengine/create-burner"

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr ""
"Crear quemador es una forma sencilla de incorporar monederos de quemador en "
"tu aplicación Dojo."

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr "[Repositorio](https://github.com/dojoengine/create-burner)"

#: src/client/npm.md:39
msgid ""
"```console\n"
"yarn add @dojoengine/create-burner\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/create-burner\n"
"```"

#: src/client/npm/core.md:1
msgid "## @dojoengine/core"
msgstr "## @dojoengine/core"

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""
"Esta biblioteca abstrae la interfaz del mundo y proporciona un conjunto de "
"funciones de ayuda para interactuar con el mundo. Es preferible utilizar "
"esta biblioteca que interactuar directamente con el mundo."

#: src/client/npm/core.md:5
msgid ""
"- World explorers\n"
"- World deployers\n"
"- Games\n"
"- Anaylitics"
msgstr ""
"- World explorers\n"
"- World deployers\n"
"- Games\n"
"- Anaylitics"

#: src/client/npm/core.md:10
msgid "### Getting Started"
msgstr "### Primeros pasos"

#: src/client/npm/core.md:16
msgid "### Example Usage"
msgstr "### Ejemplo de Uso"

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"
msgstr ""
"Este es un ejemplo de [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"

#: src/toolchain/dojoup.md:1
msgid "# `dojoup`"
msgstr "# `dojoup`"

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr "Actualiza o vuelve a una rama específica de Dojo con facilidad."

#: src/toolchain/dojoup.md:5
msgid "## Installing"
msgstr "## Instalación"

#: src/toolchain/dojoup.md:11
msgid "## Usage"
msgstr "## Uso"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr "Para instalar la última versión **estable**:"

#: src/toolchain/dojoup.md:18
msgid ""
"> Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""
"> Nota: Es posible que tenga que instalar `jq` para utilizar `dojoup`. Puede "
"hacerlo con los siguientes comandos:"

#: src/toolchain/dojoup.md:20
msgid ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"
msgstr ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr ""
"Para instalar una **versión** específica (en este caso la versión `nightly`):"

#: src/toolchain/dojoup.md:30
msgid ""
"```sh\n"
"dojoup --version nightly\n"
"```"
msgstr ""
"```sh\n"
"dojoup --version nightly\n"
"```"

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""
"Para instalar una **rama** específica (en este caso, la última confirmación "
"de la rama `release/0.1.0`):"

#: src/toolchain/dojoup.md:36
msgid ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""
"Para instalar la rama principal de un **fork** (en este caso la rama "
"principal de `tarrencev/dojo`):"

#: src/toolchain/dojoup.md:42
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""
"Para instalar una rama específica en una bifurcación** (en este caso, el "
"último commit de la rama `patch-10` en `tarrencev/dojo`):"

#: src/toolchain/dojoup.md:48
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr "Para instalar desde una **Pull Request específica**:"

#: src/toolchain/dojoup.md:54
msgid ""
"```sh\n"
"dojoup --pr 1071\n"
"```"
msgstr ""
"```sh\n"
"dojoup --pr 1071\n"
"```"

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr "Para instalar desde un **commit específico**:"

#: src/toolchain/dojoup.md:60
msgid ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"
msgstr ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/"
"dojo`, assuming you're in the home directory)"
msgstr ""
"Para instalar un directorio o repositorio local (por ejemplo, uno ubicado en "
"`~/git/dojo`, suponiendo que estás en el directorio home)"

#: src/toolchain/dojoup.md:66
msgid ""
"##### Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""
"##### Nota: los indicadores --branch, --repo y --version se ignoran durante "
"las instalaciones locales."

#: src/toolchain/dojoup.md:68
msgid ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""
"**Consejo**: Todas las banderas tienen un carácter equivalente. Puede "
"utilizar `-v` en lugar de `--version`, etc."

#: src/toolchain/dojoup.md:78
msgid "### Precompiled binaries"
msgstr "### Binarios precompilados"

#: src/toolchain/dojoup.md:80
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://"
"github.com/dojoengine/dojo/releases).\n"
"These are better managed by using [Dojoup](#using-dojoup)."
msgstr ""
"Los binarios precompilados están disponibles en la página de [GitHub "
"releases page](https://github.com/dojoengine/dojo/releases).\n"
"Es recomendable utilizar [Dojoup](#using-dojoup) para gestionarlos de manera "
"más eficiente."

#: src/toolchain/dojoup.md:84
msgid ""
"> ℹ️ **Note**\n"
">\n"
"> If you're on Windows, you will need to install and use [Git BASH](https://"
"gitforwindows.org/) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install),\n"
"> as your terminal, since Dojoup currently does not support Powershell or "
"Cmd."
msgstr ""
"> ℹ️ **nota**\n"
">\n"
"> Si estás en Windows, deberás instalar y utilizar [Git BASH](https://"
"gitforwindows.org/) o [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install),\n"
"> como tu terminal, ya que actualmente Dojoup no es compatible con "
"Powershell o Cmd."

#: src/toolchain/sozo/overview.md:1
msgid "## Sozo"
msgstr "## Sozo"

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of World-"
"building. In the future, it may include a GUI."
msgstr ""
"`sozo` es una poderosa herramienta todo en uno para gestionar sus proyectos "
"Dojo. Ayuda con todo, desde la preparación de un nuevo proyecto hasta la "
"implementación e interacción con sus Dojo Worlds. Incluye una herramienta de "
"planificación de migración, diseñada para agilizar la actualización y la "
"implementación de AW. Proporciona una sólida interfaz de línea de comandos "
"(CLI) que simplifica las tareas de administración de mundos, permitiéndole "
"concentrarse en los aspectos creativos de la construcción de mundos. En el "
"futuro, puede incluir una GUI."

#: src/toolchain/sozo/overview.md:5
msgid "## Features"
msgstr "## Características"

#: src/toolchain/sozo/overview.md:7
msgid ""
"-   **Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""
"- **Binary CLI**: Sozo ofrece una intuitiva interfaz de línea de comandos "
"(CLI), asegurando una fácil gestión de tus Mundos, ya sea que estés "
"actualizando los existentes o desplegando nuevos."

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
msgid "## Installation"
msgstr "## Instalación"

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-"
"start.md), our dedicated installation package manager."
msgstr ""
"El binario `sozo` se puede instalar a través de [`dojoup`](../../getting-"
"started/quick-start.md), nuestro administrador de paquetes de instalación "
"dedicado."

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
msgid "### Installing from Source"
msgstr "### Instalación desde el código fuente"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr "Esto instalará Sozo y las dependencias requeridas en tu sistema local."

#: src/toolchain/sozo/overview.md:23
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`sozo` Reference](./reference.md) para obtener una "
"descripción completa de todos los subcomandos disponibles."

#: src/toolchain/sozo/reference.md:1
msgid "## sozo reference"
msgstr "## Referencias sozo"

#: src/toolchain/sozo/reference.md:3
msgid "### Project Commands"
msgstr "## Comandos de Proyecto"

#: src/toolchain/sozo/reference.md:5
msgid ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"
msgstr ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"

#: src/toolchain/sozo/reference.md:10
msgid "### World Commands"
msgstr "## Comandos de Mundo"

#: src/toolchain/sozo/reference.md:12
msgid ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"
msgstr ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"

#: src/toolchain/sozo/project-commands/init.md:1
msgid "## sozo init"
msgstr "## sozo init"

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."
msgstr ""
"`init` se utiliza para inicializar un nuevo proyecto. Inicializará un nuevo "
"proyecto en el directorio actual clonando [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."

#: src/toolchain/sozo/project-commands/init.md:5
#: src/tutorial/onchain-chess/0-setup.md:21
msgid ""
"```sh\n"
"sozo init\n"
"```"
msgstr ""
"```sh\n"
"sozo init\n"
"```"

#: src/toolchain/sozo/project-commands/build.md:1
msgid "## sozo build"
msgstr "## sozo build"

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""
"`build` se utiliza para compilar los contratos de El Cairo, generando los "
"artefactos necesarios para la implementación."

#: src/toolchain/sozo/project-commands/build.md:5
#: src/tutorial/onchain-chess/0-setup.md:38
msgid ""
"```sh\n"
"sozo build\n"
"```"
msgstr ""
"```sh\n"
"sozo build\n"
"```"

#: src/toolchain/sozo/project-commands/test.md:1
msgid "## sozo test"
msgstr "## sozo test"

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""
"`test` se utiliza para probar los contratos de Cairo del proyecto. Ejecutará "
"todas las pruebas encontradas dentro del proyecto."

#: src/toolchain/sozo/project-commands/test.md:5
msgid ""
"```sh\n"
"sozo test\n"
"```"
msgstr ""
"```sh\n"
"sozo test\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "## sozo migrate"
msgstr "## sozo migrate"

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""
"`migrate` se utiliza para realizar el proceso de migración (implementación), "
"declarando e implementando contratos según sea necesario para implementar o "
"actualizar el mundo."

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""
"Los cambios realizados en el mundo local después de la implementación "
"inicial se pueden enviar fácilmente a la contraparte remota ejecutando `sozo "
"migrar --world <WORLD_ADDRESS>` siendo `WORLD_ADDRESS` la dirección del "
"mundo remoto. En segundo plano, `migrate` calculará las diferencias entre el "
"mundo local y remoto, luego comenzará a construir una estrategia de "
"migración para determinar, si corresponde, qué parte del mundo local "
"necesita ser impulsada hacia arriba."

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7
msgid "### USAGE"
msgstr "### USO"

#: src/toolchain/sozo/project-commands/migrate.md:9
msgid ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105 src/toolchain/torii/reference.md:33
msgid "### OPTIONS"
msgstr "### OPCIONES"

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107 src/toolchain/torii/reference.md:35
msgid "#### General Options"
msgstr "#### Opciones Generales"

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Name of the World. At the moment, the only usage for "
"this option is to be used as a salt when deploying the World contract to "
"avoid address conflicts. This option is **required** when performing the "
"initial migration of the World."
msgstr ""
"`--name` _NOMBRE_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Nombre del Mundo. Por el momento, el único uso de "
"esta opción es como sal al implementar el contrato mundial para evitar "
"conflictos de direcciones. Esta opción es **obligatoria** al realizar la "
"migración inicial del mundo."

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
msgid "#### World Options"
msgstr "#### Opciones Mundo"

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The address of the World contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""
"`--world` _WORLD_ADDRESS_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;La dirección del Contrato Mundo.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
msgid "#### Starknet Options"
msgstr "#### Opciones de Starknet"

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet RPC endpoint. [default: http://"
"localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"
msgstr ""
"`--rpc-url` _URL_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El punto final RPC de Starknet. [predeterminado: "
"http://localhost:5050]\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
msgid "#### Account Options"
msgstr "#### Opciones de Cuenta"

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet account address.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""
"`--account-address` _ACCOUNT_ADDRESS_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;La dirección de la cuenta de Starknet.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
msgid "#### Signer Options - Raw"
msgstr "#### Opciones del Signer - RAW"

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The raw private key associated with the account "
"contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"
msgstr ""
"`--private-key` _CLAVE_PRIVADA_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;La clave privada sin procesar asociada con el "
"contrato de cuenta.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
msgid "#### Signer Options - Keystore"
msgstr "#### Opciones del Signer - Keystore"

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
msgid ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Use the keystore in the given folder or file."
msgstr ""
"`--keystore` _PATH_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Utilice el keystore en la carpeta o archivo indicado."

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The keystore password. Used with --keystore.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""
"`--password` _CONTRASEÑA_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;La contraseña del almacén de claves. Usado con --"
"keystore.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:186
msgid "### EXAMPLES"
msgstr "### EJEMPLOS"

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "1. Deploying your World for the first time to a local Katana node"
msgstr "1. Implementar tu mundo por primera vez en un nodo Katana local"

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "2. Updating a remote World after making some changes"
msgstr "2. Actualizar un mundo remoto después de realizar algunos cambios"

#: src/toolchain/sozo/project-commands/migrate.md:63
msgid ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "## sozo execute"
msgstr "## sozo execute"

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr "`execute` se utiliza para ejecutar el sistema de un Mundo."

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""
"Realizar una ejecución del sistema requiere enviar una transacción, por lo "
"tanto, `execute` espera una dirección de cuenta así como su respectiva clave "
"privada para poder firmar la transacción antes de enviarla."

#: src/toolchain/sozo/world-commands/execute.md:9
msgid ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The calldata to be passed to the system that you "
"want to execute.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420."
msgstr ""
"`--calldata` _CALLDATA_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Los datos de llamada que se pasarán al sistema que "
"desea ejecutar.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Valores separados por comas, por ejemplo, "
"0x12345,0x69420."

#: src/toolchain/sozo/world-commands/execute.md:56
msgid ""
"1. Executing the _position_ system which takes two values (_x_: 0x77 and "
"_y_: 0x44)"
msgstr ""
"1. Ejecutando el sistema _position_ el cual toma dos valores (_x_: 0x77 y "
"_y_: 0x44)"

#: src/toolchain/sozo/world-commands/execute.md:58
msgid ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"
msgstr ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:1
msgid "## sozo register"
msgstr "## sozo register"

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr "`register` se utiliza para registrar nuevos sistemas y componentes."

#: src/toolchain/sozo/world-commands/register.md:5
msgid ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:16
msgid ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:1
msgid "## sozo system"
msgstr "## sozo system"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""
"`system` se utiliza para interactuar con los sistemas de un Mundo. Es útil "
"para consultar información sobre un sistema."

#: src/toolchain/sozo/world-commands/system.md:7
msgid ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"
msgstr ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "### SUBCOMMANDS"
msgstr "### SUBCOMANDOS"

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "#### `get`"
msgstr "#### `get`"

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr "Obtener el class hash de un sistema"

#: src/toolchain/sozo/world-commands/system.md:21
msgid ""
"```sh\n"
"sozo system get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "##### Arguments"
msgstr "##### Argumentos"

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the system"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El nombre del sistema"

#: src/toolchain/sozo/world-commands/system.md:30
msgid "#### `dependency`"
msgstr "#### `dependency`"

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr "Recuperar las dependencias de los componentes de un sistema."

#: src/toolchain/sozo/world-commands/system.md:34
msgid ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:59
msgid "1. Get the class hash of the _spawn_ system"
msgstr "1. Obtenga el class hash del sistema _spawn_"

#: src/toolchain/sozo/world-commands/system.md:61
msgid ""
"```sh\n"
"sozo system get spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system get spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:65
msgid "2. Get the component dependencies of the _spawn_ system"
msgstr "2. Obtenga las dependencias de los componentes del sistema _spawn_"

#: src/toolchain/sozo/world-commands/system.md:67
msgid ""
"```sh\n"
"sozo system dependency spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency spawn\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:1
msgid "## sozo component"
msgstr "## sozo component"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""
"`component` se utiliza para interactuar con los componentes de un mundo. Es "
"útil para consultar sobre la información de un componente o el valor de un "
"componente de una entidad."

#: src/toolchain/sozo/world-commands/component.md:7
msgid ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"
msgstr ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr "Obtener el class hash de un componente"

#: src/toolchain/sozo/world-commands/component.md:22
msgid ""
"```sh\n"
"sozo component get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El nombre del componente"

#: src/toolchain/sozo/world-commands/component.md:31
msgid "#### `schema`"
msgstr "#### `schema`"

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr "Recuperar el esquema de un componente"

#: src/toolchain/sozo/world-commands/component.md:35
msgid ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:44
msgid "#### `entity`"
msgstr "#### `entity`"

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr "Obtener el valor del componente para una entidad"

#: src/toolchain/sozo/world-commands/component.md:48
msgid ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"
msgstr ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:54
msgid ""
"_`NAME`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_  \n"
"  &nbsp;&nbsp;&nbsp;&nbsp;El nombre del componente"

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The keys of the entity that you want to query.  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""
"_`KEYS`_\n"
"  &nbsp;&nbsp;&nbsp;&nbsp;Las key de la entidad que desea consultar.\n"
"  &nbsp;&nbsp;&nbsp;&nbsp;Valores separados por comas, por ejemplo, "
"0x12345,0x69420,..."

#: src/toolchain/sozo/world-commands/events.md:1
msgid "## sozo events"
msgstr "## sozo events"

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr "`events` se utiliza para consultar eventos de Mundo."

#: src/toolchain/sozo/world-commands/events.md:5
msgid ""
"```sh\n"
"sozo events\n"
"```"
msgstr ""
"```sh\n"
"sozo events\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "## sozo auth"
msgstr "## sozo auth"

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr "`auth` se utiliza para gestionar la autorización de Mundo."

#: src/toolchain/sozo/world-commands/auth.md:5
msgid ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:15
msgid ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"

#: src/toolchain/katana/overview.md:1
msgid "## Katana"
msgstr ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""
"`katana` es un nodo de Starknet _extremadamente rápido_, diseñado para "
"admitir el desarrollo local con Dojo."

#: src/toolchain/katana/overview.md:5
msgid "### Features"
msgstr "### Características"

#: src/toolchain/katana/overview.md:7
msgid ""
"-   [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-"
"specs/tree/v0.3.0) support\n"
"-   Custom methods for manipulating the blockchain states"
msgstr ""
"- Soporte [Starknet JSON-RPC v0.3.0] (https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0)\n"
"- Métodos personalizados para manipular los estados de blockchain."

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via [`dojoup`](../../getting-started/quick-"
"start.md)."
msgstr ""
"El binario `katana` está disponible a través de [`dojoup`](../../getting-"
"started/quick-start.md)."

#: src/toolchain/katana/overview.md:14
msgid "### Installing from source"
msgstr "### Instalación desde el código fuente"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"

#: src/toolchain/katana/overview.md:22
msgid "### Usage"
msgstr "### Uso"

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"

#: src/toolchain/katana/overview.md:60
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`referencia de katana`](./reference.md) para obtener una "
"referencia detallada y documentación sobre Katana."

#: src/toolchain/katana/reference.md:1
msgid "## katana reference"
msgstr "## referencia de katana"

#: src/toolchain/katana/reference.md:3
msgid "### NAME"
msgstr "### NOMBRE"

#: src/toolchain/katana/reference.md:5
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""
"katana - Crea un nodo de prueba local para implementar y probar contratos "
"inteligentes de Starknet."

#: src/toolchain/katana/reference.md:9
msgid ""
"```sh\n"
"katana [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"katana [OPTIONS]\n"
"```"

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
msgid "### DESCRIPTION"
msgstr "### DESCRIPCIÓN"

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"Cree un nodo de testnet local para implementar y probar contratos "
"inteligentes de Starknet. Katana apoya el despliegue y ejecución de los "
"contratos **nuevos** y **heredados** (Cairo 0) de Cairo."

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""
"Esta sección cubre una extensa lista de información sobre los Modos de "
"Minería, los Métodos de RPC Soportados, los flags de Katana y sus usos. "
"Puedes ejecutar múltiples flags al mismo tiempo."

#: src/toolchain/katana/reference.md:19
msgid "#### Mining Modes"
msgstr "#### Modos de Minería"

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""
"En Katana, los modos de minería determinan la frecuencia con la que se "
"extraen los bloques. De forma predeterminada, se extrae automáticamente un "
"nuevo bloque tan pronto como se envía una transacción."

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""
"Puede cambiar del comportamiento de minería predeterminado a la minería a "
"intervalos, donde se crea un nuevo bloque en un intervalo de tiempo fijo "
"seleccionado por el usuario. Para habilitar este modo de minería, use el "
"indicador `--block-time <SECONDS>`, como se demuestra en el siguiente "
"ejemplo."

#: src/toolchain/katana/reference.md:25
msgid ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10\n"
"```"
msgstr ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10\n"
"```"

#: src/toolchain/katana/reference.md:30
msgid "#### Supported Transport Layers"
msgstr "#### Capas de Transporte Soportadas"

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""
"Actualmente, solo se admite la conexión HTTP. El servidor escucha en el "
"puerto 5050 de forma predeterminada, pero se puede cambiar ejecutando el "
"siguiente comando:"

#: src/toolchain/katana/reference.md:34
msgid ""
"```sh\n"
"katana --port <PORT>\n"
"```"
msgstr ""
"```sh\n"
"katana --port <PORT>\n"
"```"

#: src/toolchain/katana/reference.md:38
msgid "#### Starknet Feature Compatibility"
msgstr "#### Compatibilidad de características de Starknet"

#: src/toolchain/katana/reference.md:40
msgid "##### Supported Transaction Type"
msgstr "##### Tipos de transacciones admitidas"

#: src/toolchain/katana/reference.md:42
msgid ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"
msgstr ""
"| Tipo           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"

#: src/toolchain/katana/reference.md:48
msgid "#### Supported RPC Methods"
msgstr "#### Métodos RPC Soportados"

#: src/toolchain/katana/reference.md:50
msgid "##### Starknet Methods"
msgstr "##### Metodos de Starknet"

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on [this](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katana soporta la versión **v0.3.0** de las especificaciones Starknet JSON-"
"RPC. Los métodos estándar se basan en [esta](https://github.com/starkware-"
"libs/starknet-specs/tree/v0.3.0) referencia."

#: src/toolchain/katana/reference.md:54
msgid ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   `starknet_getClassAt`\n"
"\n"
"-   `starknet_syncing`\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"
msgstr ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   `starknet_getClassAt`\n"
"\n"
"-   `starknet_syncing`\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"

#: src/toolchain/katana/reference.md:83
msgid "##### Custom Methods"
msgstr "##### Métodos Personalizados"

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""
"Katana proporciona un conjunto conveniente de métodos RPC personalizados "
"para configurar rápidamente y fácilmente el nodo según las necesidades de tu "
"entorno de pruebas."

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock`  \n"
"Genera un nuevo bloque que incluye todas las transacciones pendientes en el "
"momento."

#: src/toolchain/katana/reference.md:90
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`  \n"
"Obtiene el tiempo estimado para el próximo bloque."

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`  \n"
"Aumenta el tiempo estimado para el próximo bloque en una cantidad específica "
"de tiempo, en segundos."

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""
"`katana_setNextBlockTimestamp`  \n"
"Similar a `katana_increaseNextBlockTimestamp`, pero permite establecer el "
"tiempo exacto que deseas en el próximo bloque."

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"`katana_predeployedAccounts`\n"
"Obtenga la información de todas las cuentas previamente implementadas."

#: src/toolchain/katana/reference.md:102
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""
"`katana_setStorageAt`\n"
"Establezca un valor exacto del espacio de almacenamiento de un contrato."

#: src/toolchain/katana/reference.md:109
msgid ""
"`--silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Don't print anything on startup."
msgstr ""
"`--silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; sin mostrar mensajes en la pantalla durante el "
"inicio."

#: src/toolchain/katana/reference.md:112
msgid ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable auto and interval mining, and mine on "
"demand instead."
msgstr ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Desactivar la minería automática e intervalos, y en "
"su lugar minar bajo demanda."

#: src/toolchain/katana/reference.md:115
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Block time in seconds for interval mining."
msgstr ""
"`-b, --block-time <SEGUNDOS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Tiempo de bloque en segundos para la minería por "
"intervalos."

#: src/toolchain/katana/reference.md:118
msgid ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dump the state of chain on exit to the given "
"file.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; If the value is a directory, the state will be "
"written to `<PATH>/state.bin`."
msgstr ""
"`--dump-state <PATH>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Vuelque el estado de la cadena al salir del archivo "
"dado.\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Si el valor es un directorio, el estado se "
"escribirá en `<PATH>/state.bin`."

#: src/toolchain/katana/reference.md:122
msgid ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Initialize the chain from a previously saved state "
"snapshot."
msgstr ""
"`--load-state <PATH>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Inicialice la cadena a partir de una instantánea de "
"estado previamente guardada."

#: src/toolchain/katana/reference.md:125
msgid ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help (see a summary with '-h')."
msgstr ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir ayuda (ver un resumen con '-h')."

#: src/toolchain/katana/reference.md:128
msgid ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version information."
msgstr ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir información de la versión."

#: src/toolchain/katana/reference.md:131
msgid "#### Server Options"
msgstr "#### Opciones del servidor"

#: src/toolchain/katana/reference.md:133
msgid ""
"`-p, --port <PORT>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Port number to listen on. [default: 5050]"
msgstr ""
"`-p, --port <PUERTO>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de puerto en el que escuchar [por defecto: "
"5050]"

#: src/toolchain/katana/reference.md:136
msgid ""
"`--host <HOST>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The IP address the server will listen on."
msgstr ""
"`--host <ANFITRIÓN>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; La dirección IP en la que el servidor escuchará."

#: src/toolchain/katana/reference.md:141
msgid ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify the seed for randomness of accounts to be "
"predeployed."
msgstr ""
"`--seed <SEMILLA>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especificar la semilla para la aleatoriedad de las "
"cuentas que serán pre-implementadas (predeployed accounts)."

#: src/toolchain/katana/reference.md:144
msgid ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Number of pre-funded accounts to generate. "
"[default: 10]"
msgstr ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de cuentas pre-financiadas para generar [por "
"defecto: 10]"

#: src/toolchain/katana/reference.md:147
msgid ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable charging fee for transactions."
msgstr ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir información de la versión."

#: src/toolchain/katana/reference.md:150
msgid "#### Environment Options"
msgstr "#### Opciones de entorno"

#: src/toolchain/katana/reference.md:152
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The chain ID. [default: KATANA]"
msgstr ""
"`--chain-id <ID_CADENA>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El ID de la cadena [por defecto: KATANA]"

#: src/toolchain/katana/reference.md:155
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The gas price."
msgstr ""
"`--gas-price <PRECIO_GAS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El precio del gas."

#: src/toolchain/katana/reference.md:158
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account validation logic."
msgstr ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; El número máximo de pasos disponibles para la "
"lógica de validación de la cuenta."

#: src/toolchain/katana/reference.md:161
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account execution logic."
msgstr ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; El número máximo de pasos disponibles para la "
"lógica de ejecución de la cuenta."

#: src/toolchain/katana/reference.md:164
msgid "### Shell Completions"
msgstr "### Finalizaciones de Shell"

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr "shell de terminaciones `katana`"

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr "Genera un script de finalización de shell para el shell determinado."

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr "Los shells soportados son:"

#: src/toolchain/katana/reference.md:172
msgid ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"
msgstr ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"

#: src/toolchain/katana/reference.md:178
msgid "#### EXAMPLES"
msgstr "### EJEMPLOS"

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr ""
"Genere un script de finalización de shell para `bash` y agréguelo a un "
"archivo `.bashrc`:"

#: src/toolchain/katana/reference.md:182
msgid ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"
msgstr ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"

#: src/toolchain/katana/reference.md:188
msgid "1. Create 15 dev accounts and disable transaction fee mechanism"
msgstr ""
"1. Cree 15 cuentas de desarrollo y desactive el mecanismo de tarifas de "
"transacción"

#: src/toolchain/katana/reference.md:190
msgid ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"
msgstr ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"

#: src/toolchain/katana/reference.md:194
msgid "2. Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""
"2. Establezca la identificación de la cadena en `SN_GOERLI` y ejecute el "
"servidor en el puerto 8545."

#: src/toolchain/katana/reference.md:196
msgid ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"
msgstr ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"

#: src/toolchain/katana/reference.md:200
msgid ""
"3. Load previously stored state and dump the state of this session to a file "
"on shutdown"
msgstr ""
"3. Cargue el estado previamente almacenado y vuelque el estado de esta "
"sesión en un archivo al cerrar"

#: src/toolchain/katana/reference.md:202
msgid ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"
msgstr ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"

#: src/toolchain/torii/overview.md:1
msgid "## Torii - Networking & Indexing"
msgstr "## Torii - Redes e indexación"

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""
"Torii es un indexador automático para mundos dojo. Construido en rust para "
"ser increíblemente rápido y excepcionalmente escalable."

#: src/toolchain/torii/overview.md:5
msgid "### Dojo indexer"
msgstr "### Indexador de Dojo"

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""
"Torii indexa los mundos de tu dojo y expone una API GraphQL para "
"consultarlos. Simplemente ejecuta:"

#: src/toolchain/torii/overview.md:9
msgid ""
"```sh\n"
"torii\n"
"```"
msgstr ""
"```sh\n"
"torii\n"
"```"

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr "¡Y tendrás una API GraphQL ejecutándose en `http://localhost:8080`!"

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/"
"quick-start.md), our dedicated installation package manager."
msgstr ""
"El binario `torii` se puede instalar a través de [`dojoup`](../../getting-"
"started/quick-start.md), nuestro administrador de paquetes de instalación "
"dedicado."

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "Si prefieres instalar desde el código fuente:"

#: src/toolchain/torii/overview.md:22
msgid ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"
msgstr ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr "Esto instalará Sozo y las dependencias requeridas en tu sistema local."

#: src/toolchain/torii/overview.md:28
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`torii` Reference](./reference.md) para obtener una "
"referencia completa."

#: src/toolchain/torii/reference.md:1
msgid "## torii reference"
msgstr "## referencia torii"

#: src/toolchain/torii/reference.md:3
msgid "### Name"
msgstr "### Nombre"

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr ""
"torii - Un indexador automático y una capa de red para un contrato Mundo."

#: src/toolchain/torii/reference.md:9
msgid ""
"```sh\n"
"torii [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"torii [OPTIONS]\n"
"```"

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""
"`torii` inicia el indexador y expone los puntos finales de la API GraphQL/"
"gRPC. El indexador consulta el punto final Starknet RPC especificado en "
"busca de bloques de transacciones y escucha las transacciones relacionadas "
"con el contrato mundial. Estas transacciones pueden incluir registros de "
"componentes/sistemas, actualizaciones del estado de la entidad, llamadas al "
"sistema y eventos. Luego, los datos analizados se almacenan en una base de "
"datos SQLite local."

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""
"Los puntos finales de las API GraphQL y gRPC se ejecutan en conjunto con el "
"indexador, proporcionando consultas personalizadas específicas del contrato "
"mundial para aplicaciones cliente."

#: src/toolchain/torii/reference.md:19
msgid "#### Database URL"
msgstr "#### Base de Datos URL"

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""
"`torii` usa una base de datos sqlite para almacenar datos indexados. La base "
"de datos se puede almacenar en memoria o de forma persistente en el sistema "
"de archivos."

#: src/toolchain/torii/reference.md:23
msgid ""
"- The in-memory database is ephermal and only lasts as long as the indexer "
"is running. This is a fast and simple option to start the indexer for "
"development/testing.\n"
"- Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""
"- La base de datos en memoria es efímera y solo dura mientras se ejecuta el "
"indexador. Esta es una opción rápida y sencilla para iniciar el indexador "
"para desarrollo/prueba.\n"
"- En la producción se debe utilizar un almacenamiento persistente. Depende "
"del sistema de archivos local para el almacenamiento."

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""
"Nota: Si utiliza una base de datos en memoria, la memoria se recolectará "
"como basura después de un período de inactividad, lo que provocará que las "
"consultas generen errores. Una solución alternativa es iniciar `katana` con "
"la opción `--block-time` o usar una base de datos persistente."

#: src/toolchain/torii/reference.md:28
msgid ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"
msgstr ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"

#: src/toolchain/torii/reference.md:37
msgid ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Address of the world contract to index"
msgstr ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dirección del contrato de Mundo a indexar."

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Starknet RPC endpoing to use [default: http//"
"localhost:5050]"
msgstr ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Punto final Starknet RPC a utilizar "
"[predeterminado: http//localhost:5050]"

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a local manifest to initialize from"
msgstr ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especifique un manifiesto local desde el que "
"inicializar"

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Database URL (read more above) [default: sqlite::"
"memory:]"
msgstr ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; URL de la base de datos (leer más arriba) "
"[predeterminado: sqlite::memory:]"

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a block to start indexing from, ignored if "
"stored head exists [default: 0]"
msgstr ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especifique un bloque desde el que comenzar a "
"indexar, ignorado si existe un encabezado almacenado [predeterminado: 0]"

#: src/toolchain/torii/reference.md:52
msgid ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help"
msgstr ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir ayuda"

#: src/toolchain/torii/reference.md:55
msgid ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version"
msgstr ""
"`-V, --versión`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprime Información de la version"

#: src/deployment/locally.md:1
msgid "## Deploying Locally"
msgstr "## Implementación local"

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""
"Dojo está diseñado para un desarrollo rápido y cuenta con un entorno de "
"desarrollo local ultrarrápido llamado [Katana](./toolchain/katana/overview."
"md). Katana sirve como una cadena de bloques Starknet en el dispositivo, lo "
"que le permite probar rigurosamente sus contratos inteligentes antes de "
"realizar la transición a una red de prueba remota."

#: src/deployment/locally.md:5
msgid "### Katana Deployments"
msgstr "### Implementaciones de Katana"

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr "La implementación en Katana no podría ser más sencilla."

#: src/deployment/locally.md:9
msgid ""
"> This assumes you have followed the [Quick Start](./getting-started/quick-"
"start.md) guide and have a project initialized."
msgstr ""
"> Esto supone que ha seguido la guía [Inicio rápido](./getting-started/quick-"
"start.md) y tiene un proyecto inicializado."

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr "Desde el directorio de su proyecto, ejecute:"

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr "¡Esto ha iniciado una Katana local en la que ahora puedes implementar!"

#: src/deployment/locally.md:19
msgid "### Deploying to Katana"
msgstr "### Implementación en Katana"

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr "Para implementar su proyecto en Katana, ejecute:"

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""
"Nota: esto sólo funcionará si ha compilado sus contratos. Si no lo has "
"hecho, ejecuta:"

#: src/deployment/remote.md:1
msgid "## Deployment to Remote Network"
msgstr "## Implementación en Red Remota"

#: src/deployment/remote.md:3
msgid "> *IMPORTANT: Dojo is unaudited. Use at your own risk.*"
msgstr "> *IMPORTANTE: Dojo no está auditado. Úselo bajo su propio riesgo.*"

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""
"Dojo facilita la implementación en redes remotas; solo necesita tener una "
"cuenta válida y endpoint de red."

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr "Scarb.toml"

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"

#: src/deployment/remote.md:33
msgid "### Remote Katana"
msgstr "### Katana Remoto"

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""
"Katanas se pueden alojar y ejecutar como redes de prueba remotas; sin "
"embargo, esto no se recomienda para uso en producción."

#: src/deployment/remote.md:37
msgid "__todo__: add instructions for deploying to remote katana"
msgstr "__todo__: agregue instrucciones para implementar en katana remoto"

#: src/deployment/remote.md:40
msgid "### Madara "
msgstr "### Madara"

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara) es un secuenciador "
"Starknet increíblemente rápido. Construido sobre el robusto marco de "
"Substrate y rápido, gracias a Rust 🦀, Madara ofrece un rendimiento y una "
"escalabilidad inigualables para impulsar su cadena Validity Rollup basada en "
"Starknet."

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr ""
"Hay una red de prueba pública de Madara disponible para su implementación:"

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr "Puede utilizar la siguiente cuenta para desplegar:"

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"

#: src/deployment/remote.md:59
msgid "### Starknet "
msgstr "### Starknet "

#: src/deployment/remote.md:61
msgid "__todo__: add instructions for deploying to remote Starknet"
msgstr "__todo__: agregue instrucciones para implementar en Starknet remoto"

#: src/tutorial/onchain-chess/index.md:1
msgid "# Building a Chess Game"
msgstr "# Construyendo un Juego de Ajedrez"

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr ""
"_\"Acabo de terminar de leer El Libro del Dojo. ¿Qué debo hacer a "
"continuación?\"_"

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""
"Las respuestas a esta pregunta son siempre \"¡Haz algo!\", a veces seguidas "
"de una lista de proyectos interesantes. Esta es una gran respuesta para "
"algunas personas, pero otras podrían estar buscando un poco más de dirección."

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""
"Esta guía está destinada a llenar el vacío entre los tutoriales para "
"principiantes muy dirigidos y el trabajo en sus proyectos. El objetivo "
"principal aquí es conseguir que escribas código. El objetivo secundario es "
"que leas la documentación."

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""
"Si aún no ha leído el Libro Dojo, le recomendamos encarecidamente que lo "
"haga antes de comenzar este proyecto."

#: src/tutorial/onchain-chess/index.md:11
msgid "## What are we building?"
msgstr "## ¿Qué estamos construyendo?"

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""
"Estamos creando un contrato de juego de ajedrez en cadena que le permite "
"comenzar un nuevo juego y jugar ajedrez. Esta guía no cubre todas las reglas "
"del juego de ajedrez. Construirás paso a paso de la siguiente manera:"

#: src/tutorial/onchain-chess/index.md:15
msgid ""
"1. A system to spawn all the chess pieces\n"
"2. A system to make pieces move\n"
"3. Add some functions to check a legal move\n"
"4. Play chess ♟♙ - integration test!"
msgstr ""
"1. Un sistema para generar todas las piezas de ajedrez.\n"
"2. Un sistema para hacer que las piezas se muevan\n"
"3. Agregue algunas funciones para verificar un movimiento legal.\n"
"4. Juega al ajedrez ♟♙ - ¡prueba de integración!"

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/"
"rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""
"El código completo del tutorial se encuentra en [este repositorio] (https://"
"github.com/rkdud007/chess-dojo/tree/tutorialv2)."

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""
"Si esto parece demasiado difícil, ¡no te preocupes! Esta guía es para "
"principiantes. Si conoces algunos conceptos básicos sobre El Cairo y Dojo, "
"estás bien. No haremos una partida de ajedrez completa con todas las reglas. "
"Lo mantendremos simple."

#: src/tutorial/onchain-chess/index.md:24
msgid "## What after this guide?"
msgstr "## ¿Qué pasa después de esta guía?"

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""
"Estamos creando otra guía para ayudar a diseñar la interfaz. Esto completará "
"nuestro juego de ajedrez."

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr ""
"Una vez que haya terminado los cinco capítulos, podemos pasar a la guía de "
"interfaz."

#: src/tutorial/onchain-chess/0-setup.md:1
msgid "# 0. Setup"
msgstr "# 0. Setup"

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-"
"dojo.md) chapter to gain a basic understanding of the Dojo game._"
msgstr ""
"_Antes de comenzar, recomendamos seguir el capítulo [`hello-dojo`](../../"
"cairo/hello-dojo.md) para obtener una comprensión básica del juego Dojo._"

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "## Initializing the Project"
msgstr "## Inicializando el Proyecto"

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""
"Cree una nueva carpeta de proyecto Dojo. Puedes nombrar tu proyecto como "
"quieras."

#: src/tutorial/onchain-chess/0-setup.md:9
msgid ""
"```sh\n"
"mkdir dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"mkdir dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr "Abra la carpeta del proyecto."

#: src/tutorial/onchain-chess/0-setup.md:15
msgid ""
"```sh\n"
"cd dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"cd dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr "E inicialice el proyecto usando sozo init."

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "## Cleaning Up the Boilerplate"
msgstr "## Limpiando lo repetitivo"

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""
"El proyecto viene con muchos códigos repetitivos. Límpielo todo. Asegúrese "
"de que los archivos `components.cairo` y `systems.cairo` estén vacíos."

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr "En `lib.cairo`, conserve solo:"

#: src/tutorial/onchain-chess/0-setup.md:31
msgid ""
"```rust,ignore\n"
"mod components;\n"
"mod systems;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod components;\n"
"mod systems;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr "Compila tu proyecto con:"

#: src/tutorial/onchain-chess/0-setup.md:42
msgid "## Basic components"
msgstr "## Componentes Básicos"

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""
"Si bien hay muchas formas de diseñar un juego de ajedrez utilizando el "
"modelo ECS, seguiremos este enfoque:"

#: src/tutorial/onchain-chess/0-setup.md:46
msgid ""
"> Every square of the chess board (e.g., A1) will be treated as an entity. "
"If a piece exists on a square, the square entity will hold that piece."
msgstr ""
"> Cada casilla del tablero de ajedrez (por ejemplo, A1) será tratada como "
"una entidad. Si existe una pieza en un cuadrado, la entidad cuadrada "
"contendrá esa pieza."

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this [chapter]"
"(../../cairo/components.md)."
msgstr ""
"Primero, agregue este componente básico al archivo `components.cairo`. Si no "
"está familiarizado con la sintaxis de los componentes del motor Dojo, vuelva "
"a este [capítulo](../../cairo/components.md)."

#: src/tutorial/onchain-chess/0-setup.md:50
msgid ""
"```rust,ignore\n"
"#[derive(Component)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:78
msgid "## Basic systems"
msgstr "## Sistemas Básicos"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""
"A partir del siguiente capítulo, implementará los sistemas `initiate` y "
"`move` uno en cada capítulo. Creemos cada sistema en su propio archivo para "
"una mejor modularidad."

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""
"Cree una carpeta `systems` en `src`. Cree dos archivos `initiate.cairo` y "
"`move.cairo` dentro de la carpeta. Cada archivo debe contener una estructura "
"básica del sistema."

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr "Por ejemplo, `initiate.cairo` tiene este aspecto:"

#: src/tutorial/onchain-chess/0-setup.md:86
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod initiate_system {\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod initiate_system {\n"
"\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr "y en `systems.cairo` usaremos `initiate_system` así:"

#: src/tutorial/onchain-chess/0-setup.md:95
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"\n"
"use initiate::initiate_system;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod initiate;\n"
"\n"
"use initiate::initiate_system;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr "Haz lo mismo con los otros sistemas. Actualice `systems.cairo` a:"

#: src/tutorial/onchain-chess/0-setup.md:103
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"mod move;\n"
"\n"
"use initiate::initiate_system;\n"
"use move::move_system;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod initiate;\n"
"mod move;\n"
"\n"
"use initiate::initiate_system;\n"
"use move::move_system;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:111
msgid "## Compile your project"
msgstr "## Compila tu proyecto"

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr ""
"Ahora prueba con `sozo build` para compilar. ¿Enfrentó algunos errores?"

#: src/tutorial/onchain-chess/0-setup.md:115
#: src/tutorial/onchain-chess/0-setup.md:179
msgid ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr ""
"Probablemente haya enfrentado algunos errores de implementación de traits, "
"que puede implementar como una derivación como:"

#: src/tutorial/onchain-chess/0-setup.md:121
msgid ""
"```rust,ignore\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr "¡Excelente! entonces solucionemos este error."

#: src/tutorial/onchain-chess/0-setup.md:153
msgid ""
"```sh\n"
"error: Trait has no implementation in context: dojo::serde::SerdeLen::<core::"
"option::Option::<dojo_chess::components::PieceType>>\n"
" --> Square:80:54\n"
"                dojo::SerdeLen::<Option<PieceType>>::len()\n"
"                                                     ^*^\n"
"```"
msgstr ""
"```sh\n"
"error: Trait has no implementation in context: dojo::serde::SerdeLen::<core::"
"option::Option::<dojo_chess::components::PieceType>>\n"
" --> Square:80:54\n"
"                dojo::SerdeLen::<Option<PieceType>>::len()\n"
"                                                     ^*^\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""
"Una cosa que debe asegurarse es que `<Option<PieceType>>` sea el tipo que "
"creamos. Entonces este tipo no implementa rasgos básicos como SerdeLen. Debe "
"definir la implementación usted mismo."

#: src/tutorial/onchain-chess/0-setup.md:162
msgid ""
"```rust,ignore\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""
"Solucione otros problemas como se indicó anteriormente, para que pueda "
"ejecutar el comando `sozo build` correctamente."

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "## Run test"
msgstr "## Run test"

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""
"Antes de continuar con el siguiente capítulo, recuerde que `sozo build` y "
"`sozo test` son pasos importantes para garantizar que su código sea correcto."

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr "Ejecute la prueba de sozo. ¿Enfrentó algún error?"

#: src/tutorial/onchain-chess/0-setup.md:183
msgid ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""
"En caso de error sin implementación, implemente PrintTrait para ejecutar la "
"prueba de sozo con éxito. Para el error no eliminado, agregue el trait Drop. "
"Solucione otros errores agregando derivaciones o implementándolas caso por "
"caso."

#: src/tutorial/onchain-chess/0-setup.md:189
msgid "## Add more components"
msgstr "## Agregar más componentes"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""
"Antes de continuar, agregue más componentes para que podamos usarlos en el "
"próximo capítulo al crear sistemas."

#: src/tutorial/onchain-chess/0-setup.md:193
msgid "### Requirements"
msgstr "### Características"

#: src/tutorial/onchain-chess/0-setup.md:195
msgid ""
"- `Color` enum enum with values White and Black\n"
"- `Game` component:"
msgstr ""
"- Enumeración `Color` con valores Blanco y Negro\n"
"- Componente `Juego`:"

#: src/tutorial/onchain-chess/0-setup.md:198
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:205
msgid "- `GameTurn` component:"
msgstr "- `GameTurn` component:"

#: src/tutorial/onchain-chess/0-setup.md:207
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:212
msgid ""
"- We will later set game entity composed of the `Game` and `GameTurn` "
"components.\n"
"- Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""
"- Posteriormente configuraremos la entidad del juego compuesta por los "
"componentes `Game` y `GameTurn`.\n"
"- Ejecute `sozo build` y `sozo test` y asegúrese de que todas las pruebas "
"pasen."

#: src/tutorial/onchain-chess/0-setup.md:215
msgid ""
"Try to solve on your own, and before you move on check the answer below."
msgstr ""
"Intente resolverlo usted mismo y, antes de continuar, verifique la respuesta "
"a continuación."

#: src/tutorial/onchain-chess/0-setup.md:217
msgid ""
"<details>\n"
"<summary>Click to see full `components.cairo` code</summary>"
msgstr ""
"<details>\n"
"<summary>Haga clic para ver el código completo de `components.cairo`</"
"summary>"

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:397
msgid "</details>"
msgstr "</details>"

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr ""
"¡Felicidades! Has completado la configuración básica para crear un juego de "
"ajedrez en cadena 🎉"

#: src/tutorial/onchain-chess/1-initiate.md:1
msgid "# 1. Initiate System"
msgstr "# 1. Iniciar el sistema"

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""
"Este capítulo abordará la implementación del `initiate_system`, que genera "
"el juego y los cuadrados que contienen piezas."

#: src/tutorial/onchain-chess/1-initiate.md:5
msgid "## What is `initiate_system`?"
msgstr "## ¿Qué es `initiate_system`?"

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""
"Para jugar al ajedrez, debes iniciar el juego y generar las piezas. "
"`initiate_system` generará la entidad del juego y luego colocará cada pieza "
"en su posición adecuada. Asegúrese de que el estado del juego coincida con "
"el tipo de pieza correcto y que el color de pieza correcto esté en la "
"posición designada en el tablero."

#: src/tutorial/onchain-chess/1-initiate.md:9
msgid ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" height=\"auto"
"\">"
msgstr ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" height=\"auto"
"\">"

#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
msgid "## Requirements"
msgstr "## Requisitos"

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"initiate.cairo` file._"
msgstr ""
"_Copie las pruebas unitarias a continuación y péguelas en la parte inferior "
"de su archivo `systems/initiate.cairo`._"

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"1. Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input.\n"
"2. Implement the game entity, comprised of the `Game` component and "
"`GameTurn` component we created in the previous step.\n"
"3. Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`.\n"
"4. Run `sozo test` and pass all the tests."
msgstr ""
"1. Escriba una función `execute` en el sistema que acepte el contexto "
"mundial, la dirección blanca y la dirección negra como entrada.\n"
"2. Implemente la entidad del juego, compuesta por el componente `Game` y el "
"componente `GameTurn` que creamos en el paso anterior.\n"
"3. Implemente entidades cuadradas mediante el componente `Square`, de a1 a "
"h8 que contenga el `PieceType` correcto.\n"
"4. Ejecute la `sozo test` y pase todas las pruebas."

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "## Test Flow"
msgstr "## Test Flow"

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"- Spawn the test world that imports the components and systems used in "
"testing.\n"
"- Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs.\n"
"- Retrieve the game entity and piece entity created during "
"`initiate_system`.\n"
"- Ensure the game has been correctly created.\n"
"- Verify that each `Piece` is located in the correct `Square`."
msgstr ""
"- Generar el mundo de pruebas que importa los componentes y sistemas "
"utilizados en las pruebas.\n"
"- Ejecute `initiate_system` proporcionando las direcciones de billetera de "
"los jugadores blanco y negro como entradas.\n"
"- Recuperar la entidad del juego y la entidad de la pieza creada durante "
"`initiate_system`.\n"
"- Asegúrate de que el juego se haya creado correctamente.\n"
"- Verificar que cada `Piece` esté ubicada en el `Square` correcto."

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
msgid "## Unit Tests"
msgstr "## Unit Tests"

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
msgid "## Need help?"
msgstr "## ¿Necesitas ayuda?"

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community]"
"(https://discord.gg/akd2yfuRS3)!"
msgstr ""
"Si estás atascado, ¡no dudes en hacer preguntas en la [comunidad Dojo] "
"(https://discord.gg/akd2yfuRS3)!"

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) for chapter 1 here."
msgstr ""
"Puede encontrar la [respuesta](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) para el capítulo 1 aquí."

#: src/tutorial/onchain-chess/2-move.md:1
msgid "# 2. Move System"
msgstr "# 2. Sistema de Movimiento"

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr ""
"Este capítulo abordará la implementación de `move_system`, que reubica una "
"pieza en el tablero."

#: src/tutorial/onchain-chess/2-move.md:5
msgid "## What is `move_system`?"
msgstr "## ¿Qué es `move_system`?"

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""
"Para jugar al ajedrez es necesario mover las piezas en el tablero. Dado que "
"representamos las ubicaciones de las piezas con una entidad Square, "
"`move_system` recupera la posición actual como (x,y). También recupera la "
"siguiente posición como (x,y), tratando la pieza en el cuadro de posición "
"actual como el objetivo que se moverá a la siguiente posición."

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"move.cairo` file._"
msgstr ""
"_Copie las pruebas unitarias a continuación y péguelas en la parte inferior "
"de su archivo `systems/move.cairo`._"

#: src/tutorial/onchain-chess/2-move.md:13
msgid "1. Write an `execute` function in the system with the following inputs:"
msgstr ""
"1. Escriba una función `execute` en el sistema con las siguientes entradas:"

#: src/tutorial/onchain-chess/2-move.md:15
msgid ""
"```rust,ignore\n"
" fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    )\n"
"```"
msgstr ""
"```rust,ignore\n"
" fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    )\n"
"```"

#: src/tutorial/onchain-chess/2-move.md:25
msgid ""
"2. Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece.\n"
"\n"
"3. Run `sozo test` and ensure all tests pass."
msgstr ""
"2. Actualice el cuadrado con `next_position` para que contenga la nueva "
"pieza y asegúrese de que el cuadrado con `curr_position` ya no contenga una "
"pieza.\n"
"\n"
"3. Ejecute la `sozo test` y asegúrese de que todas las pruebas pasen."

#: src/tutorial/onchain-chess/2-move.md:31
msgid ""
"- Follow the same logic as `test_initiate` from the previous chapter.\n"
"- Move the White Knight from (1,0) to (2,2) using the `move_system`.\n"
"- Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""
"- Sigue la misma lógica que `test_initiate` del capítulo anterior.\n"
"- Mueve el Caballero Blanco de (1,0) a (2,2) usando el `move_system`.\n"
"- Recuperar la posición actualizada y verificar que la pieza se haya movido "
"exitosamente a su nueva ubicación."

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:1
msgid "# 3. Check Legal Move"
msgstr "# 3. Verifique Movimiento Legal"

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr "En este capítulo, crearemos funciones para verificar:"

#: src/tutorial/onchain-chess/3-legal.md:5
msgid ""
"- If the next move goes outside the board.\n"
"- If there's a piece that can be captured.\n"
"- If the next move is allowed for the type of piece.\n"
"- If the user can allow to make a action (based on the piece's color).\n"
"- ... You can also add other custom check functions."
msgstr ""
"- Si el siguiente movimiento sale fuera del tablero.\n"
"- Si hay alguna pieza que se pueda capturar.\n"
"- Si el siguiente movimiento está permitido por el tipo de pieza.\n"
"- Si el usuario puede permitir realizar una acción (según el color de la "
"pieza).\n"
"-... También puede agregar otras funciones de verificación personalizadas."

#: src/tutorial/onchain-chess/3-legal.md:11
msgid "## Make Check Functions"
msgstr "## Realizar Funciones de Verificación"

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""
"Necesitamos agregar algunas funciones de verificación en `move_system`. Esto "
"ayudará a garantizar que se permita el siguiente movimiento."

#: src/tutorial/onchain-chess/3-legal.md:15
msgid "1. See if the next spot is allowed for the type of piece moving."
msgstr ""
"1. Vea si el siguiente lugar está permitido para el tipo de pieza que se "
"mueve."

#: src/tutorial/onchain-chess/3-legal.md:17
msgid ""
"```rust,ignore\n"
"  fn is_right_piece_move(\n"
"        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
"next_position: (u32, u32)\n"
"    ) -> bool {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"  fn is_right_piece_move(\n"
"        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
"next_position: (u32, u32)\n"
"    ) -> bool {}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:23
msgid "2. See if the next spot is still on the board."
msgstr "2. Vea si el siguiente lugar todavía está en el tablero."

#: src/tutorial/onchain-chess/3-legal.md:25
msgid ""
"```rust,ignore\n"
"  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
"```"
msgstr ""
"```rust,ignore\n"
"  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:29
msgid ""
"3. See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""
"3. Observa si la persona que intenta el movimiento lo hace en el momento "
"adecuado y con el color de su pieza."

#: src/tutorial/onchain-chess/3-legal.md:31
msgid ""
"```rust,ignore\n"
" fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
"game_id: felt252) -> bool{}\n"
"```"
msgstr ""
"```rust,ignore\n"
" fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
"game_id: felt252) -> bool{}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:35
msgid ""
"4. You can also add other check functions to be extra sure the move is "
"allowed."
msgstr ""
"4. También puede agregar otras funciones de verificación para asegurarse de "
"que el movimiento esté permitido."

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""
"Una vez que haya realizado estas funciones de verificación, puede usarlas en "
"la función principal `move_system`. Puedes decidir cómo configurarlos y "
"cuáles usar. Daremos un ejemplo para ayudar:"

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:85
msgid "## Testing Each Function"
msgstr "## Probar cada función"

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""
"Como tenemos diferentes funciones de verificación, debemos probar cada una. "
"Para hacerlo más fácil, usemos piezas que sean iguales para muchas pruebas."

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""
"Primero, cree una función auxiliar llamada `init_world_test`. Esto nos "
"devolverá un `IWorldDispatcher` que podremos usar muchas veces en las "
"pruebas del sistema de movimiento."

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr "Entonces, nuestra función principal `test_move` será más simple."

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""
"Ahora podemos hacer pruebas que muestren errores si intentamos movimientos "
"que no están permitidos. Hagamos una función `test_piecetype_illegal`. Esto "
"verificará si la función `is_right_piece_move`, que implementó en el sistema "
"de movimiento, funciona correctamente."

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""
"Termina haciendo tus pruebas. Estos deberían encontrar movimientos "
"incorrectos y devolver errores."

#: src/tutorial/onchain-chess/4-test.md:1
msgid "# 4. Test Contract"
msgstr "# 4. Contrato de Test"

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""
"En este capítulo, usaremos todo lo que hemos aprendido para ejecutar un "
"escenario de juego de ajedrez completo."

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr "Esto es lo que haremos en nuestra prueba:"

#: src/tutorial/onchain-chess/4-test.md:7
msgid ""
"1. Spawn `white_pawn_1` to (0,1)\n"
"2. Move `white_pawn_1` to (0,3)\n"
"3. Move `black_pawn_2` to (1,6)\n"
"4. Move `white_pawn_1` to (0,4)\n"
"5. Move `black_pawn_2` to (1,5)\n"
"6. Move `white_pawn_1` to (1,5)\n"
"7. Capture `black_pawn_2`"
msgstr ""
"1. Spawn `white_pawn_1` to (0,1)\n"
"2. Move `white_pawn_1` to (0,3)\n"
"3. Move `black_pawn_2` to (1,6)\n"
"4. Move `white_pawn_1` to (0,4)\n"
"5. Move `black_pawn_2` to (1,5)\n"
"6. Move `white_pawn_1` to (1,5)\n"
"7. Capture `black_pawn_2`"

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""
"Para colocar las piezas utilice nuestro `initiate_system`. Para moverlos, "
"utilice `move_system`. Recuerde verificar si se puede capturar una pieza al "
"usar `move_system`."

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr ""
"Antes de llegar al código, configure su prueba de integración de esta manera:"

#: src/tutorial/onchain-chess/4-test.md:19
msgid ""
"- Copy the test below and add it to your `src/tests.cairo` file.\n"
"- Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""
"- Copie la prueba a continuación y agréguela a su archivo `src/tests."
"cairo`.\n"
"- Crea un `test.cairo` en tu src y actualiza `lib.cairo` agregando la línea "
"`mod tests;`."

#: src/tutorial/onchain-chess/4-test.md:22
msgid "## Full Code"
msgstr "## Full Code"

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:143
msgid "## Diving into the Code"
msgstr "## Profundizando en el código"

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr "Primero, configuraremos los jugadores y sus colores."

#: src/tutorial/onchain-chess/4-test.md:147
msgid ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"
msgstr ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""
"Deberíamos enumerar tanto los componentes como los sistemas en matrices, y "
"cada uno tenga CLASS_HASH como elemento."

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr "A continuación, crearemos nuestro mundo de juego."

#: src/tutorial/onchain-chess/4-test.md:169
msgid ""
"```rust,ignore\n"
"     let world = spawn_test_world(components, systems);\n"
"```"
msgstr ""
"```rust,ignore\n"
"     let world = spawn_test_world(components, systems);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""
"Usamos `initiate_system` para poner nuestras piezas cuadradas en el tablero. "
"Cada cuadrado contiene una pieza. La función de ejecución del sistema "
"necesita alguna entrada, que le damos como datos de llamada."

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""
"Comprobemos si hay un peón blanco en (0,1). Recuerde, para obtener una pieza "
"que existe en el cuadrado, debe usar las claves del componente `Square`, que "
"son `game_id`, `x` e `y`. Haz la misma prueba con el peón negro."

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""
"Después de configurar el tablero, usa `move_system` para realizar "
"movimientos. Proporcione la posición actual, la siguiente posición, la "
"dirección del jugador y la identificación del juego."

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr "Sigue moviendo piezas y comprobando si están en los lugares correctos."

#: src/tutorial/onchain-chess/4-test.md:212
msgid "## Congratulations!"
msgstr "## ¡Felicidades!"

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""
"¡Has creado los contratos básicos para un juego de ajedrez usando el motor "
"Dojo! Este tutorial fue solo el comienzo. Hay muchas formas de mejorar el "
"juego, como optimizar piezas, agregar controles o considerar casos "
"especiales. Si quieres hacer más con este juego de ajedrez, prueba estos "
"desafíos:"

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"- Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient.\n"
"- Add a checkmate feature. Our game doesn't end now, so decide when it "
"should!\n"
"- Include special moves like castling, En Passant Capture, or Pawn "
"Promotion.\n"
"- Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""
"- Crea un `initiate_system` que utilice lazy init. Si no está seguro acerca "
"del inicio diferido, [léalo](https://en.wikipedia.org/wiki/"
"Lazy_initialization). Esto puede ayudar a que las acciones de tu juego sean "
"más eficientes.\n"
"- Agregar una función de jaque mate. Nuestro juego no termina ahora, ¡así "
"que decide cuándo debería terminar!\n"
"- Incluye movimientos especiales como enroque, captura al paso o promoción "
"de peones.\n"
"- ¡Haz tus propias reglas de ajedrez! Incluso podrías crear tu propia "
"versión del [juego inmortal](https://immortal.game/)"

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo community](https://"
"discord.gg/akd2yfuRS3)!"
msgstr ""
"¡Por último, comparte tu proyecto con otros en la [comunidad Dojo] (https://"
"discord.gg/akd2yfuRS3)!"

#: src/misc/contributors.md:1
#, fuzzy
msgid "Contributing to Dojo Book"
msgstr "## Contribuyendo al Libro de Dojo"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""
"Conforme el motor de Dojo avanza y se desarrolla, es fundamental que el "
"Libro de Dojo se mantenga al día con estos avances. Actualizar y "
"perfeccionar el libro garantiza que siga siendo un recurso relevante y "
"valioso para aquellos interesados en comprender y utilizar las últimas "
"características y capacidades del motor de Dojo. ¡Toda ayuda es bienvenida!"

#: src/misc/contributors.md:5
#, fuzzy
msgid "The purpose of the book"
msgstr "### El propósito del libro es"

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""
"El libro de Dojo está diseñado para ser un recurso completo que atienda a "
"usuarios de varios niveles de experiencia. Su objetivo es servir como una "
"guía introductoria para aquellos que son nuevos en Dojo y sus paquetes "
"complementarios, así como una referencia para usuarios más experimentados "
"que buscan profundizar su comprensión de las características y capacidades "
"del motor."

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "El libro está dividido en varios capítulos principales:"

#: src/misc/contributors.md:11
msgid "Framework Theory"
msgstr ""

#: src/misc/contributors.md:13
#, fuzzy
msgid "Building a World"
msgstr "### Compilando desde el código fuente"

#: src/misc/contributors.md:15
#, fuzzy
msgid "Code of Conduct"
msgstr "### Código de conducta"

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of Conduct](https://www.rust-lang.org/"
"policies/code-of-conduct)."
msgstr ""
"El libro sigue el [Rust Code of Conduct](https://www.rust-lang.org/policies/"
"code-of-conduct)."

#: src/misc/contributors.md:19
#, fuzzy
msgid "Ways to contribute"
msgstr "### Formas de contribuir"

#: src/misc/contributors.md:21
msgid "#### Issues"
msgstr "#### Issues"

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""
"Si consideras que falta algún contenido o que alguna información está "
"desactualizada, no dudes en abrir un 'issue' al respecto. Si encuentras "
"varias partes del contenido que necesitan ser complementadas, por favor, "
"abre un 'issue' separado para cada una."

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""
"Luego, los 'issues' serán etiquetados para que otros colaboradores puedan "
"encontrar áreas de trabajo que les interesen más fácilmente."

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""
"El 'issue' debe contener lo que falta o lo que podría mejorar, con todos los "
"detalles que consideres necesarios."

#: src/misc/contributors.md:29
msgid "#### Pull requests"
msgstr "#### Pull requests"

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""
"Siéntete libre de contribuir con cambios al libro abriendo un PR (pull "
"request). Todo es bienvenido, desde reformular una oración, corregir un "
"error tipográfico hasta agregar nuevas secciones o capítulos."

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""
"Cuando tu pull request esté abierto, otros colaboradores lo revisarán y "
"podrían solicitar cambios. ¡No te desanimes!"

#: src/misc/contributors.md:35
#, fuzzy
msgid "Writing style"
msgstr "### Estilo de escritura"

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr ""
"Esta sección documenta algunos estándares de escritura utilizados a lo largo "
"del libro."

#: src/misc/contributors.md:39
#, fuzzy
msgid "Chapters start with a second level heading"
msgstr "#### Los capítulos comienzan con un encabezado de segundo nivel"

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "Nosotras usamos:"

#: src/misc/contributors.md:43
msgid ""
"```md\n"
"## Some Page\n"
"```"
msgstr ""
"```md\n"
"## Some Page\n"
"```"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr "Nosotras no usamos:"

#: src/misc/contributors.md:49
msgid ""
"```md\n"
"# Some Page\n"
"```"
msgstr ""
"```md\n"
"# Some Page\n"
"```"

#~ msgid "Introduction"
#~ msgstr "Introducción"

#~ msgid "Installation"
#~ msgstr "Instalación"

#~ msgid "Dojo Engine"
#~ msgstr "Motor de Dojo"

#~ msgid "Storage"
#~ msgstr "Almacenamiento"

#~ msgid "Appendix"
#~ msgstr "Apéndice"

#~ msgid "sozo Commands"
#~ msgstr "Comandos de sozo"

#~ msgid "Project Commands"
#~ msgstr "Comandos del Proyecto"

#~ msgid "World Commands"
#~ msgstr "Comandos del Mundo"

#~ msgid ""
#~ "Dojo is a provable game engine with an integrated toolchain, designed for "
#~ "creating onchain games and autonomous worlds using [Cairo 1.0](https://"
#~ "github.com/starkware-libs/cairo). It employs an [entity component system]"
#~ "(https://en.wikipedia.org/wiki/Entity_component_system) and a [diamond "
#~ "pattern](https://eips.ethereum.org/EIPS/eip-2535), facilitating a "
#~ "modular, scalable world. Worlds grow via the addition of Components "
#~ "(state) and Systems (logic). Our architectural design is greatly "
#~ "influenced by the brilliant [Bevy](https://bevyengine.org/) engine."
#~ msgstr ""
#~ "Dojo es un motor de juegos demostrables con una herramienta integrada, "
#~ "diseñada para crear juegos y mundos autónomos en la cadena de bloques "
#~ "utilizando [Cairo 1.0](https://github.com/starkware-libs/cairo). Emplea "
#~ "un [sistema de componentes de entidades](https://en.wikipedia.org/wiki/"
#~ "Entity_component_system) y el [patrón diamante](https://eips.ethereum.org/"
#~ "EIPS/eip-2535), facilitando un mundo modular y escalable. Los mundos "
#~ "crecen mediante la adición de Componentes (estado) y Sistemas (lógica). "
#~ "Nuestro diseño arquitectónico está fuertemente influenciado por el "
#~ "brillante motor [Bevy](https://bevyengine.org/)."

#~ msgid "#### Key Features"
#~ msgstr "#### Características clave"

#~ msgid ""
#~ "- Entity Component System (ECS) built on [Cairo 1.0](https://github.com/"
#~ "starkware-libs/cairo)\n"
#~ "- [Sozo](./framework/sozo/overview.md) world migration planner\n"
#~ "- [Torii](./framework/torii/overview.md) networking and indexing stack\n"
#~ "- [Katana](./framework/katana/overview.md) RPC development network\n"
#~ "- Typed SDKs"
#~ msgstr ""
#~ "- Sistema de Componentes de Entidades (ECS) construido en [Cairo 1.0]"
#~ "(https://github.com/starkware-libs/cairo)\n"
#~ "- [Sozo](./framework/sozo/overview.md) planificador de migraciones de "
#~ "mundos\n"
#~ "- [Torii](./framework/torii/overview.md) pila de red e indexación\n"
#~ "- [Katana](./framework/katana/overview.md) red de desarrollo RPC\n"
#~ "- SDKs tipados"

#~ msgid "### Why Cairo & Starknet?"
#~ msgstr "### ¿Por qué Cairo y StarkNet?"

#~ msgid "### Vision"
#~ msgstr "### Visión"

#~ msgid ""
#~ "Dojo is a bold work in progress, aimed at empowering developers to "
#~ "construct onchain games and Autonomous Worlds (AWs) within hours, not "
#~ "weeks."
#~ msgstr ""
#~ "Dojo es un audaz trabajo en progreso, con el objetivo de capacitar a los "
#~ "desarrolladores para construir juegos en la cadena y Mundos Autónomos "
#~ "(AWs) en cuestión de horas, no semanas."

#~ msgid "Open your terminal and run the following command:"
#~ msgstr "Abre tu terminal y ejecuta el siguiente comando:"

#~ msgid ""
#~ "Running `dojoup` by itself will install the latest (nightly) [precompiled "
#~ "binaries](#precompiled-binaries): `sozo`, `katana`, and `torii`.\n"
#~ "See `dojoup --help` for more options, like installing from a specific "
#~ "version or commit."
#~ msgstr ""
#~ "Ejecutar `dojoup` por sí mismo instalará las últimas versiones (nightly) "
#~ "de [binarios precompilados](#precompiled-binaries): `sozo`, `katana`, and "
#~ "`torii`.\n"
#~ "Consulta `dojoup --help` para más opciones, como instalar desde una "
#~ "versión o commit específico."

#~ msgid "# Dojo Engine - Getting Started Guide"
#~ msgstr "# Motor de Dojo - Guía de Inicio"

#~ msgid ""
#~ "This README guides you through the process of setting up your local "
#~ "development environment for Dojo."
#~ msgstr ""
#~ "Este archivo README te guiará a través del proceso de configurar tu "
#~ "entorno de desarrollo local para Dojo."

#~ msgid "## Clone the Repository"
#~ msgstr "## Clonar el repositorio"

#~ msgid "First, clone the repository to your local machine:"
#~ msgstr "Primero, clona el repositorio en tu máquina local:"

#~ msgid ""
#~ "For proper linting and syntax highlighting, you should install the Cairo "
#~ "1.0 extension for Visual Studio Code."
#~ msgstr ""
#~ "Para obtener un correcto resaltado de sintaxis y linting, debes instalar "
#~ "la extensión de Cairo 1.0 para Visual Studio Code."

#~ msgid ""
#~ "- Clone the Cairo repository somewhere on your machine (make sure not to "
#~ "clone within the Dojo directory)."
#~ msgstr ""
#~ "- Clona el repositorio de Cairo en algún lugar de tu máquina (asegúrate "
#~ "de no clonarlo dentro del directorio de Dojo)."

#~ msgid ""
#~ "- Install the Cairo Language Server extension. Here's a step-by-step "
#~ "guide, or you can follow the [official instructions](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."
#~ msgstr ""
#~ "- Instala la extensión Cairo Language Server. Aquí tienes una guía paso a "
#~ "paso, o puedes seguir las [instrucciones oficiales](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."

#~ msgid "Navigate to the vscode-cairo directory:"
#~ msgstr "Navega al directorio vscode-cairo:"

#~ msgid "Install the required packages:"
#~ msgstr "Instala los paquetes necesarios:"

#~ msgid "Package the extension:"
#~ msgstr "Empaqueta la extensión:"

#~ msgid "Install the extension:"
#~ msgstr "Instala la extensión:"

#~ "> **Mac Tip:** If you don't have the `code` command, in VSCode do `Cmd"
#~ "+Shift+P` and type 'shell command' to find the Shell Command: Install "
#~ "'code' command in PATH command."
#~ msgstr ""
#~ "> **Mac Tip:** Si no tienes el comando `code`, en VSCode presiona `Cmd"
#~ "+Shift+P` y escribe 'shell command' para encontrar el comando: Instale el "
#~ "comando 'code' en el PATH."

#~ msgid ""
#~ "The Cairo language server should now be installed globally in your Visual "
#~ "Studio Code. If you have the server enabled, Scarb should automatically "
#~ "pick this up and start linting your Cairo files."
#~ msgstr ""
#~ "El servidor de lenguaje de Cairo debería estar instalado globalmente en "
#~ "tu Visual Studio Code ahora. Si tienes el servidor habilitado, Scarb "
#~ "debería detectarlo automáticamente y comenzar a realizar el análisis de "
#~ "estilo en tus archivos de Cairo."

#~ msgid ""
#~ "- [Overview](./framework/cairo/overview.md)\n"
#~ "- [World](./framework/cairo/world.md)\n"
#~ "- [Components](./framework/cairo/components.md)\n"
#~ "- [Systems](./framework/cairo/systems.md)\n"
#~ "- [Entities](./framework/cairo/entities.md)\n"
#~ "- [Commands](./framework/cairo/commands.md)\n"
#~ "- [Storage](./framework/cairo/storage.md)"
#~ msgstr ""
#~ "- [Visión general](./framework/cairo/overview.md)\n"
#~ "- [Mundo](./framework/cairo/world.md)\n"
#~ "- [Componentes](./framework/cairo/components.md)\n"
#~ "- [Sistemas](./framework/cairo/systems.md)\n"
#~ "- [Entidades](./framework/cairo/entities.md)\n"
#~ "- [Comandos](./framework/cairo/commands.md)\n"
#~ "- [Almacenamiento](./framework/cairo/storage.md)"

#~ msgid ""
#~ "Dojo comes with batteries included to power your games. There are 3 core "
#~ "tools which you will use to build your worlds."
#~ msgstr ""
#~ "Dojo viene con herramientas incluidas para impulsar tus juegos. Hay 3 "
#~ "herramientas principales que utilizarás para construir tus mundos."

#~ msgid ""
#~ "The Entity Component System (ECS) forms the backbone of the Dojo engine. "
#~ "Here's an overview of its core elements:"
#~ msgstr ""
#~ "El Sistema de Componentes de Entidades (ECS) es el corazón del motor de "
#~ "Dojo. Aquí tienes una descripción general de sus elementos principales:"

#~ msgid ""
#~ "1. **Entities**: Unique objects that can bear multiple components. They "
#~ "are identifiable through unique IDs.\n"
#~ "2. **Components**: Diverse attributes of an entity, such as geometry, "
#~ "physics, and hit points. Components are exclusively responsible for data "
#~ "storage.\n"
#~ "3. **Systems**: Segments of code that manage entities and alter "
#~ "components.\n"
#~ "4. **Queries**: Utilized by systems to select entities based on the "
#~ "associated components.\n"
#~ "5. **World**: A comprehensive container for entities, components, "
#~ "systems, and queries."
#~ msgstr ""
#~ "1. **Entidades**: Objetos únicos que pueden tener múltiples componentes. "
#~ "Se identifican mediante identificadores únicos (IDs).\n"
#~ "2. **Componentes**: Diversos atributos de una entidad, como geometría, "
#~ "física y puntos de vida. Los componentes son exclusivamente responsables "
#~ "del almacenamiento de datos.\n"
#~ "3. **Sistemas**: Segmentos de código que administran entidades y "
#~ "modifican componentes.\n"
#~ "4. **Consultas (Queries)**: Utilizadas por los sistemas para seleccionar "
#~ "entidades en función de los componentes asociados.\n"
#~ "5. **Mundo (World)**: Un contenedor completo para entidades, componentes, "
#~ "sistemas y consultas."

#~ msgid "### Building an Autonomous World with Dojo"
#~ msgstr "### Construyendo un Mundo Autónomo con Dojo"

#~ msgid "Follow these steps to effectively create a Dojo world:"
#~ msgstr "Sigue estos pasos para crear eficazmente un mundo con Dojo:"

#~ msgid ""
#~ "1. **Conceptualize Entities**: Visualize the entities that will populate "
#~ "your world.\n"
#~ "2. **Recognize Shared Attributes**: Determine common characteristics of "
#~ "your entities, such as position, name, or health.\n"
#~ "3. **Construct Reusable Components**: Create versatile components derived "
#~ "from these shared attributes.\n"
#~ "4. **Develop Specialized Systems**: Design systems that are adept at "
#~ "performing a specific task."
#~ msgstr ""
#~ "1. **Conceptualiza las Entidades**: Visualiza las entidades que poblarán "
#~ "tu mundo.\n"
#~ "2. **Identifica Atributos Compartidos**: Determina las características "
#~ "comunes de tus entidades, como posición, nombre o salud.\n"
#~ "3. **Construye Componentes Reutilizables**: Crea componentes versátiles "
#~ "derivados de estos atributos compartidos.\n"
#~ "4. **Desarrolla Sistemas Especializados**: Diseña sistemas que sean "
#~ "hábiles para realizar tareas específicas."

#~ msgid ""
#~ "To illustrate, here's an example of a basic design that utilizes "
#~ "components and systems to create four distinct entities:"
#~ msgstr ""
#~ "Para ilustrar, aquí tienes un ejemplo de un diseño básico que utiliza "
#~ "componentes y sistemas para crear cuatro entidades distintas:"

#~ msgid "__todo__"
#~ msgstr "__Próximamente__"

#~ msgid ""
#~ "Components serve as the foundation for defining the world's structure, "
#~ "encapsulating state for systems to mutate. For instance, a Position "
#~ "component can be implemented as a struct, exposing `is_zero` and "
#~ "`is_equal` methods. Dojo compiles these components into contracts that "
#~ "can be declared and installed within a world, enabling the creation of "
#~ "diverse and customizable environments."
#~ msgstr ""
#~ "Los componentes sirven como base para definir la estructura del mundo, "
#~ "encapsulando el estado para que los sistemas puedan modificarlo. Por "
#~ "ejemplo, un componente de Posición se puede implementar como una "
#~ "estructura, exponiendo métodos como `is_zero` e `is_equal`. Dojo compila "
#~ "estos componentes en contratos que pueden ser declarados e instalados "
#~ "dentro de un mundo, lo que permite la creación de entornos diversos y "
#~ "personalizables."

#~ msgid ""
#~ "Suppose you plan to create two entities that move around the map and are "
#~ "fundamentally different from each other, except for the fact that they "
#~ "both exist within the world. In this case, you could create a shared "
#~ "Position component for both entities. This demonstrates the power of the "
#~ "Entity Component System (ECS) abstraction: by writing a single component, "
#~ "you can reuse it across multiple diverse entities, promoting modularity "
#~ "and flexibility within your world design."
#~ msgstr ""
#~ "Supongamos que planeas crear dos entidades que se mueven por el mapa y "
#~ "son fundamentalmente diferentes entre sí, excepto por el hecho de que "
#~ "ambas existen dentro del mundo. En este caso, podrías crear un componente "
#~ "de \"Posición\" compartido para ambas entidades. Esto demuestra el poder "
#~ "de la abstracción del Sistema de Componentes de Entidades(ECS): al "
#~ "escribir un solo componente, puedes reutilizarlo en múltiples entidades "
#~ "diversas, fomentando la modularidad y flexibilidad en el diseño de tu "
#~ "mundo."

#~ msgid ""
#~ "Systems represent functions that operate on the world state. They take "
#~ "input from the user, retrieve the current state from the world, compute a "
#~ "state transition, and apply it. Each system has a single entry point, the "
#~ "execute function. To streamline interaction with the world, systems can "
#~ "utilize\n"
#~ "commands."
#~ msgstr ""
#~ "Los Sistemas representan funciones que operan sobre el estado del mundo. "
#~ "Toman información del usuario, obtienen el estado actual del mundo, "
#~ "calculan una transición de estado y la aplican. Cada sistema tiene un "
#~ "único punto de entrada, la función `execute`. Para simplificar la "
#~ "interacción con el mundo, los sistemas pueden utilizar comandos."

#~ msgid "Finally, lets move the character with the `MoveSystem`."
#~ msgstr "Finalmente, movamos al personaje con el `MoveSystem`."

#~ msgid "# Storage"
#~ msgstr "# Almacenamiento"

#~ msgid ""
#~ "In a Dojo Autonomous World, the `World` contract serves as the central "
#~ "store that manages and maintains the overall state. No state is "
#~ "maintained at the component level, this allows a clean split in logic and "
#~ "state. Most developers will not need to touch the storage methods, every "
#~ "part of the world can just be maintained via the [commands](./commands."
#~ "md)."
#~ msgstr ""
#~ "En un Mundo Autónomo de Dojo, el contrato `World` sirve como la tienda "
#~ "central que administra y mantiene el estado general. No se mantiene "
#~ "ningún estado a nivel de componente, lo que permite una división clara "
#~ "entre la lógica y el estado. La mayoría de los desarrolladores no "
#~ "necesitarán manipular los métodos de almacenamiento, ya que cada parte "
#~ "del mundo puede ser gestionada mediante los [comandos](./commands.md)."

#~ msgid "## Detailed overview of Storage"
#~ msgstr "## Descripción detallada del Almacenamiento"

#~ msgid ""
#~ "State is maintained via a generated partition when you create a "
#~ "component. The compiler calculates the size of the component along with "
#~ "the key you have used and creates a partition within the world. Think of "
#~ "the partition as a table which can be read from and written to."
#~ msgstr ""
#~ "El estado se mantiene mediante una partición generada al crear un "
#~ "componente. El compilador calcula el tamaño del componente junto con la "
#~ "clave que has utilizado, y crea una partición dentro del mundo. Puedes "
#~ "pensar en la partición como una tabla a la cual se puede leer y escribir."

#~ msgid ""
#~ "Torii serves as a comprehensive indexing and networking layer for dojo "
#~ "worlds. It systematically organizes the state of dojo worlds, "
#~ "facilitating efficient querying for clients."
#~ msgstr ""
#~ "Torii actúa como una capa completa de indexación y redes para los mundos "
#~ "de Dojo. Organiza sistemáticamente el estado de los mundos de Dojo, "
#~ "facilitando consultas eficientes para los clientes."

#~ msgid "__coming soon__"
#~ msgstr "__Próximamente__"

#~ msgid ""
#~ "-   [sozo Commands](./sozo/)\n"
#~ "-   [katana Reference](./katana/)"
#~ msgstr ""
#~ "-   [Comandos sozo](./sozo/)\n"
#~ "-   [Referencias katana](./katana/)"

#~ msgid ""
#~ "-   [Project Commands](./project-commands.md)\n"
#~ "-   [World Commands](./world-commands.md)"
#~ msgstr ""
#~ "-   [Comandos de Proyecto](./project-commands.md)\n"
#~ "-   [Comandos de Mundo](./world-commands.md)"

#~ msgid "### SYNOPSIS"
#~ msgstr "### SINOPSIS"

#~ msgid ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Allow transaction max fee to be zero"
#~ msgstr ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Permitir que la tarifa máxima de la transacción "
#~ "sea cero"

#~ msgid "1. Set the number of accounts to 15 and allow zero fee transaction"
#~ msgstr ""
#~ "1. Establecer el número de cuentas en 15 y permitir transacciones sin "
#~ "tarifas"
