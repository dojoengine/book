msgid ""
msgstr ""
"Project-Id-Version: Building Autonomous Worlds with Dojo\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-09-17 09:41+0900\n"
"Last-Translator: y-bi <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "前言"

#: src/SUMMARY.md:4
msgid "What is Dojo?"
msgstr "Dojo 是什么？"

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "AW 理论"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "Cairo生态系统"

#: src/SUMMARY.md:7
msgid "FAQs"
msgstr "常见问题"

#: src/SUMMARY.md:9
msgid "Getting Started"
msgstr "入门"

#: src/SUMMARY.md:11
msgid "Quick Start"
msgstr "快速入门"

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr "手动安装"

#: src/SUMMARY.md:13
msgid "Development Setup"
msgstr "开发设置"

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr "贡献"

#: src/SUMMARY.md:16
msgid "Community"
msgstr "社区"

#: src/SUMMARY.md:18
msgid "Get Started"
msgstr "开始加入社区"

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr "结构"

#: src/SUMMARY.md:22
msgid "Hello Dojo"
msgstr "Hello Dojo"

#: src/SUMMARY.md:23
msgid "Config"
msgstr "配置"

#: src/SUMMARY.md:24
msgid "World"
msgstr "世界"

#: src/SUMMARY.md:25
msgid "Components"
msgstr "组件"

#: src/SUMMARY.md:26
msgid "Systems"
msgstr "系统"

#: src/SUMMARY.md:27
msgid "Entities"
msgstr "实体"

#: src/SUMMARY.md:28
msgid "Authorization"
msgstr "授权"

#: src/SUMMARY.md:29
msgid "Commands"
msgstr "命令"

#: src/SUMMARY.md:30
msgid "Events"
msgstr "活动"

#: src/SUMMARY.md:31
msgid "Testing"
msgstr "测试"

#: src/SUMMARY.md:32
msgid "Dojo Modules"
msgstr "Dojo的模块"

#: src/SUMMARY.md:33
msgid "ERC20"
msgstr "ERC20"

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr "ERC721"

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr "ERC1155"

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr "DeFi"

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr "客户端 SDK"

#: src/SUMMARY.md:40
msgid "Overview"
msgstr "概述"

#: src/SUMMARY.md:41
msgid "JS"
msgstr "JS"

#: src/SUMMARY.md:42
msgid "Core"
msgstr "核心"

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr "工具链"

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr "Dojoup"

#: src/SUMMARY.md:47
msgid "Sozo"
msgstr "Sozo"

#: src/SUMMARY.md:48 src/SUMMARY.md:60 src/SUMMARY.md:62
msgid "Reference"
msgstr "参考资料"

#: src/SUMMARY.md:49
msgid "init"
msgstr "初始化"

#: src/SUMMARY.md:50
msgid "build"
msgstr "编译"

#: src/SUMMARY.md:51
msgid "test"
msgstr "测试"

#: src/SUMMARY.md:52
msgid "migrate"
msgstr "迁移"

#: src/SUMMARY.md:53
msgid "execute"
msgstr "执行"

#: src/SUMMARY.md:54
msgid "register"
msgstr "注册"

#: src/SUMMARY.md:55
msgid "system"
msgstr "系统"

#: src/SUMMARY.md:56
msgid "component"
msgstr "组件"

#: src/SUMMARY.md:57
msgid "events"
msgstr "事件"

#: src/SUMMARY.md:58
msgid "auth"
msgstr "授权"

#: src/SUMMARY.md:59
msgid "Katana"
msgstr "Katana"

#: src/SUMMARY.md:61
msgid "Torii"
msgstr "Torii"

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr "部署"

#: src/SUMMARY.md:66
msgid "Locally"
msgstr "本地"

#: src/SUMMARY.md:67
msgid "Remote"
msgstr "远程"

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr "教程"

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr "链上国际象棋"

#: src/SUMMARY.md:72
msgid "0. Setup"
msgstr "0. 设置"

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr "1. 初始化"

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr "2. 移动"

#: src/SUMMARY.md:75
msgid "3. Check Legal Move"
msgstr "3. 检查合法移动"

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr "4. 测试国际象棋"

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr "贡献者"

#: src/index.md:1
msgid "Dojo"
msgstr "Dojo"

#: src/index.md:3
msgid ""
"> Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo 是一个开源项目，目前处于早期开发阶段，并热忱的欢迎贡献者们。更多相关资"
"源，请在 [Discord](https://discord.gg/vUN4Xq9Qv6)上加入我们的社区，并查看我们"
"的[Github](https://github.com/dojoengine/book) 。"

#: src/index.md:7
msgid "## Dojo: The Provable Game Engine"
msgstr "## Dojo：可证明游戏引擎"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""
"Dojo 采用 [Cairo语言](https://github.com/starkware-libs/cairo)，为设计自主世"
"界和链上游戏提供了强大的架构和工具集。它拥有一个集成的实体组件系统（ECS），包"
"括一个本地索引器、RPC 测试网和一个全面的 CLI 管理工具包。"

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the [Theory](./theory/"
"autonomous-worlds.md) elucidates this emergent concept of autonomous worlds "
"and Provable games."
msgstr ""
"本指南旨在让您熟悉 Dojo 引擎和 可证明（Provable） 游戏的变革潜力。 [理论](./"
"theory/autonomous-worlds.md)专节阐明了自主世界和 可证明游戏这一新兴概念。"

#: src/index.md:13
msgid ""
"- [Quickstart](./getting-started/quick-start.md)\n"
"- [What is Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""
"- [快速入门](./getting-started/quick-start.md)\n"
"- [什么是 Dojo？](./theory/what-is-dojo.md)\n"
"- [探索架构](./cairo/hello-dojo.md)"

#: src/index.md:18
msgid "### Explainer"
msgstr "### 说明者"

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://"
"twitter.com/tarrenceva) explaining how Dojo works at the 2023 [Autonomous "
"Anonymous Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""
"以下是[Cartridge](https://cartridge.gg/) 的[Tarrence](https://twitter.com/"
"tarrenceva) 在 2023 年[Autonomous Anonymous Summit](https://twitter.com/"
"pet3rpan_/status/1666764726427353091) 上说明 Dojo 如何工作的视频："

#: src/index.md:22
msgid ""
"<video controls poster=\"https://"
"gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa."
"arweave.net/kW-uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/"
"mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"
msgstr ""
"<video controls poster=\"https://"
"gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa."
"arweave.net/kW-uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/"
"mp4\">\n"
"  您的浏览器不支持视频标记。\n"
"</video>"

#: src/index.md:30
msgid "### Organizational Structure"
msgstr "### 组织结构"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO]"
"(https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many "
"more [contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojo 是一项开源计划，采用 MIT 许可，致力于推广和推进自主世界 (AW) 概念。它由"
"[Cartridge](https://cartridge.gg/)、[Realms & BibliothecaDAO](https://"
"bibliothecadao.xyz/)、[briq](https://briq.construction/)和更多[贡献者们]"
"(https://github.com/orgs/dojoengine/people)牵头。\n"
"\n"
"\n"
"中文版由[Starknet Astro](https://twitter.com/StarkNetAstroCN)与[AW Research]"
"(https://twitter.com/AW_Research)共同翻译。"

#: src/index.md:33
msgid "### How do I get involved?"
msgstr "### 我该如何参与？"

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) and "
"[contribution guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""
"查看我们的 [Github](https://github.com/dojoengine)、[Twitter](https://"
"twitter.com/dojostarknet)、[Discord](https://discord.gg/vUN4Xq9Qv6) 和 [贡献"
"指南](https://book.dojoengine.org/misc/contributors.html)"

#: src/theory/what-is-dojo.md:1
msgid "# What is Dojo?"
msgstr "# Dojo 是什么？"

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [on-"
"chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""
"Dojo 是在游戏行业的新兴领域--[链上游戏](https://naavik.co/digest/primer-"
"fully-on-chain-gaming) 的尝试中吸取的经验教训的结晶。任何尝试过开发链上游戏的"
"开发者都会明白其中固有的工程障碍--这种认识促使我们创建了 Dojo。正如您不会在每"
"次开发新游戏时都重新创建 Unity 一样，同样的原则也适用于此。Dojo 旨在处理复杂"
"的基础架构，让开发人员能够专注于其游戏的独特之处。"

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""
"Dojo 立志成为构建可证明游戏的首选工具。它完全开源，欢迎所有形式的贡献。"

#: src/theory/what-is-dojo.md:9
msgid "## Stop building infrastructure; start building games"
msgstr "## 停止做基础设施，开始做游戏"

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-"
"chain games. It includes:"
msgstr "Dojo 的工具套件消除了构建链上游戏的基础设施复杂性。它包括："

#: src/theory/what-is-dojo.md:13
msgid "### Entity Component System (ECS)"
msgstr "### 实体组件系统（ECS）"

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""
"Dojo 提供了一种在智能合约上构建游戏的标准化方法。Dojo 认识到游戏设计的复杂"
"性，简化了开发流程，使创作者能够专注于游戏逻辑。这种标准化为世界互联网络铺平"
"了道路，让开发人员的专业知识能够有效的发挥，促进了游戏整合。"

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""
"Dojo 采用 ECS（实体组件系统）作为架构模式，以有效管理和组织自主世界（AW）的状"
"态和行为。在这种模式中，计算被定义为在一组实体上运行的系统列表，每个实体都由"
"一组动态的纯数据组件组成。各系统通过对实体组件进行持久、高效的查询，选择要处"
"理的实体。"

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr "阅读有关 [Dojo ECS](../cairo/overview.md) 的详细信息。"

#: src/theory/what-is-dojo.md:21
msgid "### [Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr "### [Torii](/crates/torii/README.md) - Starknet索引器"

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""
"构建链上游戏通常需要解决链上状态索引的难题。不过，Dojo 将合约状态标准化，以反"
"映传统的关系数据库。通过这种设置，[Torii 索引器](../toolchain/torii/overview."
"md)可以自动索引所有合约状态，确保高效、精简的查询。然后，Torii 通过 GraphQL "
"API 或 gRPC（即将推出）公开这些状态，允许开发人员轻松查询和检索数据。"

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-"
"chain games. It also eliminates the need to manually create indexers, which "
"can be a tedious and error-prone process."
msgstr ""
"使用 Torii 大大减少了构建链上游戏所需的时间和精力。它还消除了手动创建索引器的"
"需要，而手动创建索引器可能是一个乏味且容易出错的过程。"

#: src/theory/what-is-dojo.md:27
msgid ""
"### [Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr "### [Katana](/crates/katana/README.md) - 如闪电般快速的开发网"

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""
"Katana 是一个可定制的 StarkNet 开发网。它速度极快，可让您迅速迭代游戏逻辑。"

#: src/theory/what-is-dojo.md:31
msgid "### [Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr "### [Sozo CLI](/crates/sozo/README.md) - CLI 管理工具"

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""
"一些Dojo 世界有望成为链上最为庞大的那些合约。Sozo 是一款 CLI 工具，可帮助您管"
"理您的世界。通过它，您可以创建、构建、测试和部署您的世界。此外，您还可以制作"
"新的组件和系统，并将它们注册到您的世界中。"

#: src/theory/what-is-dojo.md:35
msgid "### What Dojo doesn't give you"
msgstr "### Dojo 不提供的东西"

#: src/theory/what-is-dojo.md:37
msgid ""
"1. Visual graphics - While Dojo provides networking and contracts, it "
"doesn't offer graphical engines. You can bring your graphics of choice! "
"Integrate your Dojo world with Unreal, Godot, or Unity."
msgstr ""
"1. 可视化图形 - Dojo 提供网络访问和合约，但不提供图形引擎。您可以自行选择图形"
"引擎！将您的 Dojo 世界与虚幻、Godot 或 Unity 整合。"

#: src/theory/what-is-dojo.md:39
msgid "## Understanding the Dojo Workflow: A Visual Guide"
msgstr "## 理解 Dojo的工作流程：一份可视化指南"

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""
"为了帮助您了解 `Sozo` 的工作原理，我们制作了一份可视化指南，概述了使用功能强"
"大的 `Sozo` 工具和 `Katana` 开发网的执行流程。"

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""
"这种可视化表示法将帮助您掌握使用 Dojo 的基本步骤，指导您完成创建和管理链上游"
"戏的过程。"

#: src/theory/what-is-dojo.md:45
msgid "Dojo Sozo Workflow"
msgstr "Dojo Sozo 工作流程"

#: src/theory/autonomous-worlds.md:1
msgid "## Autonomous Worlds"
msgstr "## 自主世界"

#: src/theory/autonomous-worlds.md:3
msgid ""
"> \"Autonomous worlds represent persistent, permissionless, and "
"decentralized open environments that users can freely interact with and "
"contribute to.\""
msgstr ""
"> \"自主世界代表着持久、无许可和分散的开放环境，用户可以自由地与之互动并做出"
"贡献\"。"

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""
"自主世界（AW）的确切定义仍然有些难以捉摸，因为它更像是一个抽象概念，尚未完全"
"具体化。Lattice 在 2022 年首次[介绍](https://0xparc.org/blog/autonomous-"
"worlds) 了这一术语，但在区块链上运行的开放世界这一概念已经存在了一段时间。"
"MUD 引入的抽象概念是让市场认识到这些世界潜力的催化剂。"

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""
"自主世界在基本性质上与区块链有显著的相似之处。一旦建立，它们就会持续存在，在"
"链的整个生命周期内保持状态。玩家可以加入或退出，开发者可以部署功能来扩展这些"
"世界--这一切都无需权限，就像将合约添加到链上一样。虽然自主世界并没有公认的定"
"义，但我们认为游戏必须至少具备以下两个基本特征才能被视为自主世界："

#: src/theory/autonomous-worlds.md:9
msgid ""
"1. Decentralized data availability layer: While the state execution may "
"reside on a centralized layer, it is crucial that the state can be "
"reconstructed if the execution layer ceases to exist. Rollups offer a "
"solution, providing increased capacity execution layers while ensuring data "
"is permanently settled on Ethereum. This guarantees the world's perpetual "
"persistence.\n"
"\n"
"2. Permissionless entry point for expanding the world: The World contract "
"must be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""
"1. 分散数据可用层：虽然状态执行可能位于中心化层，但如果执行层不复存在，状态能"
"否重建至关重要。Rollup提供了一种解决方案，在确保数据永久沉淀在以太坊上的同"
"时，提供了容量更大的执行层。这保证了世界的永久持久性。\n"
"\n"
"2. 用于扩展世界的无需权限入口：世界合约必须能够接受新的系统和组件，而无需获得"
"许可。虽然这并不意味着每个组件和系统都会被利用，但它们必须遵守这一模式，确保"
"开放和不受限制地访问潜在的增强功能。"

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""
"我们坚信，自主世界有潜力在 zk 证明和区块链技术提供的媒介中催化对新形式的探"
"索。这不仅关系到游戏，还关系到新形式的艺术作品、协调、乐趣，它们都来自修补和"
"激进创新，最终在这个勇敢的去中心化和无信任的新世界中对 \"游玩\" 的概念提出质"
"疑。"

#: src/theory/autonomous-worlds.md:15
msgid "### Homework"
msgstr "### 阅读作业"

#: src/theory/autonomous-worlds.md:16
msgid ""
"- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)\n"
"- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)\n"
"- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)\n"
"- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)\n"
"- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)\n"
"- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-"
"up-worlds/)\n"
"- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/"
"on-chain-realities-and-autonomous-worlds)"
msgstr ""
"- [Wired - 自主世界入门](https://www.wired.com/story/autonomous-worlds-aim-"
"to-free-online-games-from-corporate-control/)\n"
"- [0xParc - 自主世界（第一部分）](https://0xparc.org/blog/autonomous-"
"worlds)\n"
"- [Gubsheep - 最强大的加密游戏论文](https://gubsheep.substack.com/p/the-"
"strongest-crypto-gaming-thesis)\n"
"- [Lattice - MUD：自主世界的引擎](https://lattice.xyz/blog/mud-an-engine-for-"
"autonomous-worlds)\n"
"- [Guiltygyoza - 游戏 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - 可组合工程](https://www.guiltygyoza.xyz/2023/05/composable-"
"engineering)\n"
"- [Jay Springett - 发条世界](https://www.thejaymo.net/2022/05/06/wind-up-"
"worlds/)\n"
"- [Are.na 自主世界文集](https://www.are.na/sylve-chevet/on-chain-realities-"
"and-autonomous-worlds)"

#: src/theory/cairo.md:1
msgid "# Provable games"
msgstr "# 可证明的游戏"

#: src/theory/cairo.md:3
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-"
"knowledge-proofs/) properties for efficient scaling and verification of "
"computations. [Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) "
"addresses this need by providing a generalized language, eliminating the "
"complexity of creating circuits to incorporate [SNARKs](https://consensys."
"net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""
"可证明博弈需要[零知识](https://ethereum.org/en/zero-knowledge-proofs/)特性，"
"以便高效地扩展和验证计算。[Cairo](https://book.starknet.io/chapter_1/"
"what_is_cairo.html)通过提供一种通用语言来满足这一需求，消除了需要创建电路以纳"
"入[SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/)"
"的复杂性。 "

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr "**您只需用Cairo语言编程，您的应用程序就自动成为可证明的**。 "

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), "
"which is compatible with Starknet's Layer 2, Starknet appchains, and even in-"
"browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK "
"primitives to fuel your game development."
msgstr ""
"此外，您还可以在[Cairo虚拟机](https://medium.com/starkware/cairo-welcome-on-"
"board-1cf3487554f) (CVM)上部署您的程序，该虚拟机与Starknet Layer2、Starknet应"
"用链兼容，甚至可以通过 WebAssembly (WASM) 在浏览器中部署！Dojo 的目标是为您的"
"游戏开发提供直接的 ZK 基元。"

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""
"有关Starknet、Cairo及其技术栈的更多信息，请查阅 [Starknet & Cairo book]"
"(https://book.starknet.io/)。"

#: src/theory/cairo.md:11
msgid "## Cairo"
msgstr "## Cairo"

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""
"Cairo 是由 Starkware 开发的一种开源、图灵完备的智能合约语言，旨在为有效性卷"
"积 Starknet提供支持。该语言可实现高表达性和可验证的计算，非常适合构建可扩展的"
"安全应用，包括去中心化金融（DeFi）项目。"

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""
"Dojo 以 Cairo 为基础，为开发自主世界（AW）创建了一个强大的框架。通过利用 "
"Cairo 的功能，Dojo 旨在简化开发流程，提高可维护性，并增强自主世界的性能。"

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/"
"commands.md). Commands are a design pattern that helps to reduce boilerplate "
"code, resulting in cleaner and more maintainable applications. They achieve "
"this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Dojo 框架的一个主要特点是使用 [命令](../cairo/commands.md)。命令是一种设计模"
"式，有助于减少模板代码，使应用程序更简洁、更易维护。它们通过将特定的操作或运"
"行封装在自足的、可重用的单元中来实现这一目标。"

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""
"开发人员可以在系统中自由编写命令，而 Cairo 编译器则负责内嵌相应的函数。 "

#: src/theory/cairo.md:21
msgid "#### Essential Reading"
msgstr "#### 必读"

#: src/theory/cairo.md:22
msgid ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"
msgstr ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"

#: src/theory/cairo.md:26
msgid "### Starknet as an L2"
msgstr "### 作为 L2的Starknet"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknet 是一个有效性卷积第二层（L2）解决方案，旨在扩展以太坊。它的运行方式是"
"提供高交易吞吐量和低气体成本，同时保持与以太坊第一层（L1）相同的安全级别。它"
"采用的策略类似于解决数独难题：验证一个解决方案比从头开始寻找解决方案更容易。"
"同样，Starknet 通过使用链外计算的 STARK 证明，以更便宜的 L1 验证取代了繁重而"
"昂贵的 L1 计算。"

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""
"用更专业的术语来说，Starknet 是一种无权限的 Validity-Rollup（也称为 \"ZK-"
"Rollup\"），支持一般计算，目前作为以太坊上的二级网络运行。该网络的一级安全性"
"由其使用的 STARK 加密证明系统提供保障，该系统被认为是最安全、最可扩展的系统之"
"一。"

#: src/theory/cairo.md:32
msgid "### Starknet as an Appchain"
msgstr "### 作为应用链的Starknet"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-"
"Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, and "
"appchains. Remarkably, you can also run it in WebAssembly (WASM) to generate "
"proofs on the client-side! The Dojo team is working closely with the [Madara]"
"(https://github.com/keep-starknet-strange/madara) team to enable Starknet "
"appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairo语言是一种同构的通用语言，针对零知识（ZK）证明进行了优化。它是 "
"Starknet、Starkex 和 应用链 背后的驱动力。值得注意的是，你还可以在 "
"WebAssembly (WASM) 中运行它，在客户端生成证明！Dojo 团队正在与 [Madara]"
"(https://github.com/keep-starknet-strange/madara) 团队紧密合作，使 Starknet "
"应用链能够无缝运行 Dojo 世界。"

#: src/theory/faqs.md:1
msgid "# FAQs"
msgstr "# 常见问题"

#: src/theory/faqs.md:3
msgid "#### Who owns Dojo?"
msgstr "#### 谁拥有Dojo？"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""
"Dojo 严格遵循 Apache 2.0 许可协议，是开源软件。任何人都可以免费使用 Dojo，任"
"何人都可以为项目做出贡献。"

#: src/theory/faqs.md:7
msgid "#### Why Dojo?"
msgstr "#### 为何选择Dojo？"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""
"Dojo 的创建旨在解决创始人在构建链上游戏时遇到的问题。它规范了构建此类游戏的流"
"程，并提供了一整套工具，使其变得更加容易。"

#: src/theory/faqs.md:11
msgid "#### What is the Dojo roadmap?"
msgstr "#### Dojo 路线图是怎样的？"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) and join the [Discord](https://"
"discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas for the project, "
"please open an issue."
msgstr ""
"Dojo 正在快速发展。您可以在 [Dojo Github](https://github.com/dojoengine/dojo/"
"issues) 上找到open状态的issue，也可以加入 [Discord](https://discord.gg/"
"vUN4Xq9Qv6) 参与其中。如果您对项目有想法，请打开一个issue。"

#: src/theory/faqs.md:15
msgid "#### What is an onchain game?"
msgstr "#### 什么是链上游戏？"

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""
"链上游戏是完全存在于公共区块链网络上的游戏；所有状态和逻辑都在链上。客户端"
"（如网络浏览器）并不存在于链上，而是纯粹为了与链上状态进行交互和解释而存在。"

#: src/theory/faqs.md:19
msgid "#### What is an autonomous world?"
msgstr "#### 什么是自主世界？"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous Worlds](../theory/"
"autonomous-worlds.md)."
msgstr ""
"自主世界是一个完全在链上存在的世界。它不受任何单一实体的控制，而是由该世界中"
"设定的规则所支配。这篇文章深入探讨了这一主题：[Autonomous Worlds](../theory/"
"autonomous-worlds.md)。"

#: src/theory/faqs.md:23
msgid "#### What is Cairo?"
msgstr "#### Cairo是什么？"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a low-"
"level language designed to compile to the Cairo Virtual Machine. Learn more "
"about it here: [Cairo](../theory/cairo.md)."
msgstr ""
"Cairo 是由 Starkware 发明的一种开源编程语言。它是一种图灵完备的语言，用于通用"
"计算。它是一种低级语言，旨在编译到Cairo虚拟机。点击此处了解更多信息：[Cairo]"
"(.../theory/cairo.md)。"

#: src/theory/faqs.md:27
msgid "#### What is a provable game?"
msgstr "#### 什么是可证明的游戏？"

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""
"由于零知识证明的神奇作用，我们可以通过验证链外创建的 zk 证明来确保游戏的公平"
"性。但这意味着什么呢？请看一盘国际象棋。我们的目标是让棋手们彼此信任对方的棋"
"步。如果是在区块链环境中，考虑到国际象棋的简单规则，用一种直接的方法，每一步"
"棋都是在区块链上进行的交易。这样做成本很高。我们只想知道胜负，而不是每一步"
"棋。"

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""
"通过 zk 证明和客户端通信，玩家可以建立状态通道，在链外共享移动并确保其有效"
"性。最后，可以向区块链提交 zk 证明，以确认游戏的公平性。这就构成了一个可证明"
"的游戏。"

#: src/getting-started/quick-start.md:1
msgid "## Quick Start"
msgstr "## 快速启动"

#: src/getting-started/quick-start.md:3
msgid ""
"> It is worth reading [theory](../theory/autonomous-worlds.md) to "
"familiarize yourself with the concept of Autonomous Worlds (AWs) and the "
"[Cairo ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""
"> 在深入研究代码之前，这里有值得你阅读一下的 [理论](../theory/autonomous-"
"worlds.md) 用以来熟悉自主世界（AW）的概念，以及[Cairo生态系统](../theory/"
"cairo.md) 。"

#: src/getting-started/quick-start.md:6
msgid "### Install Dojoup"
msgstr "### 安装 Dojoup"

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup [here](https://github.com/dojoengine/dojo/blob/master/dojoup/README."
"md)."
msgstr ""
"Dojo 由 Katana、Torii 和 Sozo 三种开发工具组成。使用 Dojoup 可以轻松安装它"
"们。有关 Dojoup 的详细信息，请点击 [此处](https://github.com/dojoengine/dojo/"
"blob/master/dojoup/README.md)。"

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"

#: src/getting-started/quick-start.md:14
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen,\n"
"which will make the `dojoup` command available in your CLI."
msgstr ""
"这将安装 Dojoup，然后只需按照屏幕上的说明操作、\n"
"即可在 CLI 中使用 `dojoup` 命令。"

#: src/getting-started/quick-start.md:17 src/toolchain/dojoup.md:15
msgid ""
"```sh\n"
"dojoup\n"
"```"
msgstr ""
"```sh\n"
"dojoup\n"
"```"

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup."
"md)."
msgstr ""
"有关 `dojoup` 的完整参考和调试，请参阅 [Dojoup](../toolchain/dojoup.md)。"

#: src/getting-started/quick-start.md:23
msgid "### Next steps"
msgstr "### 下一步"

#: src/getting-started/quick-start.md:25
msgid ""
"> Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""
"> 前往  [Hello Dojo](../cairo/hello-dojo.md) ，创建你的第一个 Dojo 世界。"

#: src/getting-started/from-source.md:1
msgid "## Building from source"
msgstr "## 从源码构建"

#: src/getting-started/from-source.md:3
msgid ""
"> If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""
"> 如果您只是想试试工具链，我们强烈建议您参考 [快速入门](./quick-start.md) 指"
"南。"

#: src/getting-started/from-source.md:5
msgid "#### Prerequisites"
msgstr "#### 先决条件"

#: src/getting-started/from-source.md:7
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager.\n"
"The easiest way to install both is with [`rustup.rs`](https://rustup.rs/)."
msgstr ""
"您需要 [Rust](https://rust-lang.org) 编译器和 Rust 软件包管理器 Cargo。\n"
"安装这两种工具的最简单方法是使用 [`rustup.rs`](https://rustup.rs/)。"

#: src/getting-started/from-source.md:10
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://"
"visualstudio.microsoft.com/downloads/),\n"
"installed with the \"Desktop Development With C++\" Workloads option."
msgstr ""
"在 Windows 系统中，您还需要已经安装了 \"使用 C++ 进行桌面开发 \"工作负载选项"
"的、\n"
"最新版本的 [Visual Studio](https://visualstudio.microsoft.com/downloads/)"

#: src/getting-started/from-source.md:13
msgid "#### Building"
msgstr "#### 构建"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "您可以使用不同的 [Dojoup]（#using-dojoup）标记："

#: src/getting-started/from-source.md:17
msgid ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "或者，使用一条Cargo命令："

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://"
"github.com/dojoengine/dojo):"
msgstr ""
"或者从本地的 [Dojo repository](https://github.com/dojoengine/dojo) 拷贝中手动"
"构建："

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"

#: src/getting-started/setup.md:1
msgid "# Development Setup"
msgstr "# 开发设置"

#: src/getting-started/setup.md:3
msgid ""
"> This article is a guide to setting up a development environment for Dojo. "
"It is not suggested to follow this guide if you are just wanting to play "
"with the toolchain. We strongly suggest following the [Quick Start](../"
"getting-started/quick-start.md) guide."
msgstr ""
"> 本文是为 Dojo 设置开发环境的指南。如果您只是想试试工具链，则不建议遵循本指"
"南。我们强烈建议您阅读 [快速入门](../getting-started/quick-start.md)指南。"

#: src/getting-started/setup.md:5
msgid "### Prerequisites"
msgstr "### 先决条件"

#: src/getting-started/setup.md:7
msgid ""
"- Rust\n"
"- Cairo"
msgstr ""
"- Rust\n"
"- Cairo"

#: src/getting-started/setup.md:12
msgid "## Guide"
msgstr "## 指引"

#: src/getting-started/setup.md:14
msgid "### Clone"
msgstr "### Clone"

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"

#: src/getting-started/setup.md:20
msgid "### Linux & Mac"
msgstr "### Linux & Mac"

#: src/getting-started/setup.md:22
msgid "#### 1. Install Rust and Dependencies"
msgstr "#### 1. 安装 Rust 和依赖"

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr "首先安装 Rust 并运行测试套件来确认你的安装是否成功："

#: src/getting-started/setup.md:26
msgid ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"
msgstr ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"

#: src/getting-started/setup.md:30
msgid ""
"> Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""
"> 注意：根据您的 Linux 发行版，您可能需要安装其他依赖项。请确保你安装了在设置"
"过程中出现的任何建议的或缺失的依赖项。"

#: src/getting-started/setup.md:32
msgid "#### 2. Install Scarb Package Manager"
msgstr "#### 2. 安装 Scarb 软件包管理器"

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""
"接下来，通过运行如下命令来进行 [Scarb](https://docs.swmansion.com/scarb) 软件"
"包管理器的安装："

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"

#: src/getting-started/setup.md:40
msgid "#### 3. Add the Cairo 1.0 VSCode Extension"
msgstr "#### 3. 添加 Cairo 1.0 VSCode 扩展"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) extension for Visual Studio Code."
msgstr ""
"安装 Visual Studio Code 的 [Cairo 1.0](https://marketplace.visualstudio.com/"
"items?itemName=starkware.cairo1) 扩展。"

#: src/getting-started/setup.md:45
msgid "### Windows"
msgstr "### Windows"

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "即将推出"

#: src/getting-started/setup.md:49
msgid "### Container"
msgstr "### 容器"

#: src/getting-started/contributing.md:1
msgid "# Contributing to the Core"
msgstr "# 为核心做出贡献"

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr "> Dojo 是一个开源项目，目前处于早期开发阶段并热忱的欢迎贡献者们。"

#: src/getting-started/contributing.md:5
msgid "## How to Contribute"
msgstr "## 如何贡献"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""
"请前往 [Github](https://github.com/dojoengine/dojo/issues) 查看open状态的的"
"issue，如果你看到一个未分配的issue，请在评论中申请将它分配给你。如果你有关于"
"新功能的想法，请创建一个带有 `enhancement` 标签的issue。"

#: src/community/get-started.md:1
msgid "## Get Started"
msgstr "## 开始加入社区"

#: src/community/get-started.md:3
msgid ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"

#: src/cairo/hello-dojo.md:1
msgid "# Hello Dojo"
msgstr "# Hello Dojo"

#: src/cairo/hello-dojo.md:3
msgid ""
"> This section assumes that you have already installed the Dojo toolchain "
"and are familiar with Cairo. If not, please refer to the [Getting Started]"
"(../getting-started/quick-start.md) section."
msgstr ""
"> 本节假定您已安装 Dojo 工具链并熟悉 Cairo。如果没有，请参阅 [快速入门](../"
"getting-started/quick-start.md)部分。"

#: src/cairo/hello-dojo.md:5
msgid "## Dojo in 15 Minutes"
msgstr "## 十五分钟进道场(dojo)"

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""
"你可以将 Dojo 视为 Cairo 的抽象，类似于 React 对 JavaScript 的抽象。它能让您"
"编写速记命令，并在编译时扩展为复杂的查询。Dojo 基于著名的实体组件系统"
"（Entity Component System，ECS）架构。"

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""
"在 Dojo 中，您可以使用系统和组件来设计您的世界。系统概括了世界的逻辑，而组件"
"则表示状态。这种强大的模式允许你以高度模块化的方式构建逻辑。如果你还不明白，"
"不要着急，我们将在下文中详细介绍。"

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr "首先，让我们建立一个在本地运行的项目。在一个空目录下执行："

#: src/cairo/hello-dojo.md:13
msgid ""
"```console\n"
"sozo init\n"
"```"
msgstr ""
"```console\n"
"sozo init\n"
"```"

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""
"恭喜您您现在有了一个本地 Dojo 项目。该命令会在您的当前目录下创建一个 `dojo-"
"starter` 项目。它是新项目的理想起点，为您提供了开始项目所需的一切。"

#: src/cairo/hello-dojo.md:19
msgid "#### Anatomy of a Dojo Project"
msgstr "#### Dojo项目剖析"

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""
"检查 `dojo-starter` 项目的内容，你会发现其结构如下（不包括非Cairo代码文件）："

#: src/cairo/hello-dojo.md:23
msgid ""
"```bash\n"
"src\n"
"  - components.cairo\n"
"  - systems.cairo\n"
"  - lib.cairo\n"
"Scarb.toml\n"
"```"
msgstr ""
"```bash\n"
"src\n"
"  - components.cairo\n"
"  - systems.cairo\n"
"  - lib.cairo\n"
"Scarb.toml\n"
"```"

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""
"Dojo 项目在很大程度上类似于标准的 Cairo 项目，区别在于创建 `组件` 和 `系统` "
"时使用的一些特殊属性标记。让我们接下来探讨一下。"

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr "打开`src/components.cairo`文件以继续。"

#: src/cairo/hello-dojo.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"...rest of code\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"...rest of code\n"
"```"

#: src/cairo/hello-dojo.md:54
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we *must* include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""
"请注意 `#[derive(Component, Copy, Drop, Serde, SerdeLen)]`属性。要识别组件，"
"我们*必须*包含 `Component`。这将向 Dojo 编译器发出信号，表明此结构体应被视为"
"组件。"

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""
"我们的 `Moves` 组件在其状态中包含一个 `remaining` 值。`#[key]` 属性告知 "
"Dojo，该组件是由 `player`字段索引的。如果你对这一点不熟悉，我们将在本章后面的"
"内容中说明它的重要性。从本质上讲，它意味着您可以使用 `player` 字段来查询此组"
"件。"

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""
"同样，我们还拥有一个保存 `x` 和 `y` 值的 `Position` 组件。同样，该组件由 "
"`player` 字段索引。"

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr "现在，让我们检查一下`src/systems.cairo`文件："

#: src/cairo/hello-dojo.md:62
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                },\n"
"                Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                },\n"
"                Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr "让我们来分析一下："

#: src/cairo/hello-dojo.md:93
msgid ""
"```rust,ignore\n"
"#[system]\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"```"

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""
"正如我们使用的 `#[derive(Component)]` 属性一样，`#[system]` 属性通知 Dojo 编"
"译器此结构是一个系统，并指示它进行相应的编译。"

#: src/cairo/hello-dojo.md:99
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context)\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn execute(ctx: Context)\n"
"```"

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""
"您会发现该系统有一个 `execute` 函数。需要注意的是，所有 Dojo 系统都需要一个 "
"`execute` 函数。该函数接受一个 `Context` 作为参数。`Context`（上下文） 是一个"
"独特的结构，它提供了关于世界和调用者的信息。"

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""
"值得一提的是，一个系统可以不仅仅包含 `execute` 函数。您可以根据需要自由添加多"
"个函数。不过，`execute` 函数是必须的，因为系统执行时会调用它。"

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr "现在让我们看看下一行："

#: src/cairo/hello-dojo.md:109
msgid ""
"```rust,ignore\n"
"let position = get!(ctx.world, ctx.origin, (Position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"let position = get!(ctx.world, ctx.origin, (Position));\n"
"```"

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""
"在这里，我们使用 `get!` [命令](./commands.md) 来获取 `ctx.origin` 实体的 "
"`Position` 组件。`ctx.origin` 是调用者的地址。第一次调用时，它将返回："

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr "现在是下一行："

#: src/cairo/hello-dojo.md:125
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Moves {\n"
"            player: ctx.origin, remaining: 10\n"
"            }, Position {\n"
"            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Moves {\n"
"            player: ctx.origin, remaining: 10\n"
"            }, Position {\n"
"            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""
"这里我们使用 `set!` [命令](./commands.md) 为 `ctx.origin` 实体设置`Moves`和"
"`Position`组件。"

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr "在很短的时间内，我们在这里做了很多事情。让我们来回顾一下："

#: src/cairo/hello-dojo.md:142
msgid ""
"-   Explained the anatomy of a Dojo project\n"
"-   Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute\n"
"-   Explained the `execute` function\n"
"-   Explained the `Context` struct\n"
"-   Touched on the `get!` and `set!` commands"
msgstr ""
"-   解释了 Dojo 项目的解剖结构\n"
"-   解释 `#[derive(Component)]`和 `#[system]`属性的含义\n"
"-   解释了 `execute` 函数\n"
"-   解释了 `Context` 结构\n"
"-   介绍了 `get!` 和 `set!` 命令"

#: src/cairo/hello-dojo.md:149
msgid "### Run it locally!"
msgstr "#### 在本地运行！"

#: src/cairo/hello-dojo.md:151
msgid ""
"Now that we have some theory out of the way, lets build the Dojo project!"
msgstr "既然我们已经掌握了一些理论知识，那就来构建 Dojo 项目吧！"

#: src/cairo/hello-dojo.md:153 src/deployment/locally.md:29
msgid ""
"```bash\n"
"sozo build\n"
"```"
msgstr ""
"```bash\n"
"sozo build\n"
"```"

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr "这就把组件和系统编译成了一个可以部署的工件！就这么简单！"

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""
"现在，让我们将其部署到 [Katana](../toolchain/katana/overview.md) 中！首先，我"
"们需要让 Katana 运行："

#: src/cairo/hello-dojo.md:161 src/deployment/locally.md:13
msgid ""
"```bash\n"
"katana --disable-fee\n"
"```"
msgstr ""
"```bash\n"
"katana --disable-fee\n"
"```"

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""
"成功！现在，[Katana](../toolchain/katana/overview.md)应已在本地计算机上运行。"
"现在开始部署！"

#: src/cairo/hello-dojo.md:167 src/deployment/locally.md:23
msgid ""
"```bash\n"
"sozo migrate --name test\n"
"```"
msgstr ""
"```bash\n"
"sozo migrate --name test\n"
"```"

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""
"这将把工件部署到 [Katana](../toolchain/katana/overview.md) 中。你应该会看到类"
"似下面的终端输出："

#: src/cairo/hello-dojo.md:173
msgid ""
"```bash\n"
"Migration account: "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 7\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (7): New 7 Update 0\n"
"  \n"
"# Executor\n"
"  > Contract address: "
"0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
"# World\n"
"  > Contract address: "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"# Components (2)\n"
"Moves\n"
"  > class hash: "
"0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
"Position\n"
"  > class hash: "
"0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
"# Systems (3)\n"
"spawn\n"
"  > class hash: "
"0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
"move\n"
"  > class hash: "
"0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
"library_call\n"
"  > class hash: "
"0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
"\n"
"🎉 Successfully migrated World on block #4 at address "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"```"
msgstr ""
"```bash\n"
"Migration account: "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 7\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (7): New 7 Update 0\n"
"  \n"
"# Executor\n"
"  > Contract address: "
"0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
"# World\n"
"  > Contract address: "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"# Components (2)\n"
"Moves\n"
"  > class hash: "
"0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
"Position\n"
"  > class hash: "
"0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
"# Systems (3)\n"
"spawn\n"
"  > class hash: "
"0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
"move\n"
"  > class hash: "
"0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
"library_call\n"
"  > class hash: "
"0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
"\n"
"🎉 Successfully migrated World on block #4 at address "
"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
"```"

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""
"让我们讨论一下项目中的 `Scarb.toml` 文件。该文件包含环境变量，可使在项目中运"
"行 CLI 命令变得轻而易举。(点击[此处](./config.md)了解更多信息）。"

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr "在文件底部添加世界地址："

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr "这样就为项目建立了世界地址。然后就可以运行以下命令："

#: src/cairo/hello-dojo.md:215
msgid ""
"```bash\n"
"sozo execute spawn\n"
"```"
msgstr ""
"```bash\n"
"sozo execute spawn\n"
"```"

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr "这样就激活了产卵系统。现在你有了一个可以互动的本地世界。"

#: src/cairo/hello-dojo.md:221
msgid "### Indexing"
msgstr "### 索引"

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""
"设置好本地世界后，让我们来深入研究索引。你可以用这个简单的命令为整个世界建立"
"索引："

#: src/cairo/hello-dojo.md:225
msgid ""
"```bash\n"
"torii\n"
"```"
msgstr ""
"```bash\n"
"torii\n"
"```"

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""
"执行上述操作可激活本地 torii 服务器，使用 SQLite 作为其数据库，数据库地址为 "
"`http://0.0.0.0:8080`。它会自动将你的世界索引到表中，允许你使用 GraphQL 查"
"询。"

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr "我们已经讲了很多！下面我们来回顾一下："

#: src/cairo/hello-dojo.md:233
msgid ""
"-   Built a Dojo world\n"
"-   Deployed the project to Katana\n"
"-   Ran the spawn system locally\n"
"-   Indexed the world with Torii"
msgstr ""
"-   构建一个 Dojo 世界\n"
"-   将项目部署到 Katana\n"
"-   在本地运行生成系统\n"
"-   用 Torii 索引世界"

#: src/cairo/hello-dojo.md:238
msgid "### Next Steps"
msgstr "### 接下来的步骤"

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""
"本概述仅仅提供了一个对 Dojo 端到端的快速了解。然而，这些世界的潜力是巨大的！"
"Dojo 被设计为用于管理数百个系统和组件，可发挥无限的创造力。那么，您下一步将制"
"作什么呢？"

#: src/cairo/config.md:1
msgid "# Config"
msgstr "# 配置"

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a [Scarb]"
"(https://docs.swmansion.com/scarb/) file which is an excellent Cairo package "
"manager and project manager."
msgstr ""
"Dojo 世界在其 Scarb.toml 文件中定义。这是一个 [Scarb](https://docs.swmansion."
"com/scarb/) 文件，Scarb是一个出色的Cairo软件包管理器和项目管理器。"

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr "Scarb.toml 文件的完整示例："

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"

#: src/cairo/world.md:1
msgid "## World Contract"
msgstr "## 世界合约"

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""
"世界合约是一个中央系统内核，是启动和解决所有交互的基础。在这个内核中，合约被"
"部署、注册和执行，简化了下游系统的流程，使得客户只需与一个合约而不是潜在的数"
"百个合约打交道。"

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""
"Dojo 核心将此合约抽象化，作为开发者，您无需编写此合约，也无需在构建世界时对其"
"进行修改。但是，了解它的工作原理以及它与系统其他部分的交互方式非常重要。"

#: src/cairo/world.md:8
msgid ""
"> **To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""
"> **思考：** 将自治世界视为驻留在另一个区块链中的主权区块链--可以说是嵌套区块"
"链。正如你可以在以太坊上部署合约来增强其功能一样，你也可以在世界合约中引入系"
"统来丰富其功能。与以太坊类似，任何人都可以为 \"世界 \"做出贡献，但与组件状态"
"交互需要授权。有一个专门的主题会讨论授权。"

#: src/cairo/world.md:11
msgid "### Context"
msgstr "### Context（上下文）"

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""
"你会注意到，每个 System 都接受一个 `Context` 结构体作为第一个参数。这是一个特"
"殊的结构体，包含有关世界和调用者的信息。"

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"

#: src/cairo/world.md:25
msgid "### The `uuid()` command"
msgstr "### `uuid()`命令"

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr "为实体生成唯一 ID 通常很有用。`uuid()` 函数可用来生成唯一 ID。"

#: src/cairo/world.md:29 src/cairo/commands.md:20 src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr "像这样使用它："

#: src/cairo/world.md:31
msgid ""
"```rust,ignore\n"
"let game_id = ctx.world.uuid();\n"
"```"
msgstr ""
"```rust,ignore\n"
"let game_id = ctx.world.uuid();\n"
"```"

#: src/cairo/world.md:36
msgid "### Full World API"
msgstr "### 完整的世界API"

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr "世界公开了一个接口，任何客户端都可以与之交互。"

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"

#: src/cairo/components.md:1
msgid "## Components"
msgstr "## 组件"

#: src/cairo/components.md:3
msgid "> Components = Data"
msgstr "> 组件 = 数据"

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr "组件是定义世界结构的基础，封装了系统变异的状态。 "

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""
"在设计一个世界中的组件时，必须仔细考虑所创建的抽象概念，并始终牢记可组合性。"

#: src/cairo/components.md:10
msgid "### Components are Structs"
msgstr "### 组件是结构体"

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""
"组件在 Cairo 中被定义为结构体。它们可以包含任意数量的字段，但在 ECS 中，最好"
"的做法是使用小的孤立组件。这样可以促进模块化和可组合性，使您可以在多个实体类"
"型中重复使用组件。"

#: src/cairo/components.md:14
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"

#: src/cairo/components.md:23
msgid "#### The #[key] attribute"
msgstr "#### #[key]属性"

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""
"`#[key]` 属性向 Dojo 表明，该组件是由 `player` 字段索引的。您需要为每个组件定"
"义一个键，因为这是您查询组件的方式。不过，您可以通过将多个字段定义为键来创建"
"复合键。 "

#: src/cairo/components.md:27
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr "在这种情况下，您就可以通过player和location字段来设置组件："

#: src/cairo/components.md:40
msgid ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Resource {\n"
"            player: ctx.origin,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"set!(\n"
"    ctx.world,\n"
"    (\n"
"        Resource {\n"
"            player: ctx.origin,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/components.md:53
msgid "#### Implementing Traits"
msgstr "#### 实现Trait"

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""
"组件可以实现trait。这对于定义跨组件的通用功能非常有用。例如，您可能想定义一个"
"实现了 `PositionTrait` trait的 `Position` 组件。该trait可定义 `is_zero` 和 "
"`is_equal` 等函数，这些函数可在访问组件时使用。"

#: src/cairo/components.md:57
msgid ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:77
msgid "#### Custom Setting Components"
msgstr "#### 自定义设置的组件"

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""
"假设我们需要一个地方来保存一个全局值，并能在将来灵活地修改它。例如，一个全局"
"的战斗冷却参数（combat_cool_down）定义了一个实体准备再次攻击所需的持续时间。"
"为此，我们可以制作一个组件，专门用于存储这个值，同时还允许通过分散式管理模式"
"对其进行修改。"

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""
"要创建这些组件，您可以按照通常的创建方法去创建。不过，在初始化它们时，请使用"
"一个常量标识符，如 GAME_SETTINGS_ID。"

#: src/cairo/components.md:83
msgid ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "
msgstr ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "

#: src/cairo/components.md:94
msgid "#### Types"
msgstr "#### 类型"

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr "支持的组件类型："

#: src/cairo/components.md:98
msgid ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`"
msgstr ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`"

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr "目前无法使用数组。"

#: src/cairo/components.md:109
msgid "### In practice with modularity in mind"
msgstr "#### 在实践中考虑模块性"

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""
"下面是个具体的例子：人类和哥布林。虽然它们有着本质上的区别，但却有着共同的"
"trait，比如都会拥有位置（position）和健康（health）。不过，人类拥有一个额外的"
"组件。此外，我们还引入了 \"计数器\"（Counter）组件，它是用以统计人类和哥布林"
"数量的独特机能。"

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""
"因此，\"人类 \"将拥有 `Potions`, `Health`  和 `Position` 组件，而 \"哥布林 "
"\"将拥有 `Health` 和 `Position` 组件。这样，我们就不必为每种实体类型创建 "
"`Health`和 `Position`组件了。"

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr "因此，一个系统会像是这样："

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:218
msgid ""
"> A complete example can be found in the [Dojo Starter](https://github.com/"
"dojoengine/dojo-starter)"
msgstr ""
"> 完整示例见 [Dojo Starter](https://github.com/dojoengine/dojo-starter)"

#: src/cairo/systems.md:1
msgid "## Systems"
msgstr "## 系统"

#: src/cairo/systems.md:3
msgid "> Systems = Logic"
msgstr "> 系统 = 逻辑"

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""
"系统是世界逻辑的基础。虽然系统本质上是无状态的，但其主要作用是修改组件的状"
"态。每个系统都有一个'execute'函数，可在世界内部交互时调用。"

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr "让我们来看一个最简单的系统，它可以改变 `Moves` 组件的状态。"

#: src/cairo/systems.md:9
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod Spawn {\n"
"    use array::ArrayTrait;\n"
"    use traits::Into;\n"
"\n"
"    use dojo::world::Context;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        set !(\n"
"            ctx.world, ctx.origin, (\n"
"                Moves { player: ctx.origin, remaining: 10 }\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod Spawn {\n"
"    use array::ArrayTrait;\n"
"    use traits::Into;\n"
"\n"
"    use dojo::world::Context;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        set !(\n"
"            ctx.world, ctx.origin, (\n"
"                Moves { player: ctx.origin, remaining: 10 }\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:31
msgid "### The Execute function"
msgstr "#### 执行函数"

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""
"`execute` 函数在系统中是强制性的，调用时以 `Context` 为第一个参数。更多信息请"
"参阅 [Context](./world.md)。"

#: src/cairo/systems.md:35
msgid "### Other functions in a System"
msgstr "#### 系统中的其他函数"

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""
"您可以自由地在系统中添加其他函数，但这些函数不能从世界中调用。这对于将你的逻"
"辑分割成小块非常有用。"

#: src/cairo/systems.md:39
msgid "### Using View Functions"
msgstr "### 使用视图函数"

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""
"有时，我们需要动态地计算组件的值，而不是获取其静态状态。例如，在 VRGDA 中，如"
"果要确定当前价格，仅查询组件状态是不够的。相反，您需要根据某些参数和当前状态"
"来计算价格。"

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr "这就是视图函数发挥作用的地方。"

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr "**什么是视图函数？**"

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""
"视图函数是从组件的现有状态推导或计算值的一种方法。它们由世界调用，并接收组件"
"的当前状态作为参数。随后，这些函数会返回一个基于该状态的计算值。"

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr "**来自 VRGDA 的示例**："

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this link]"
"(https://github.com/dojoengine/dojo-examples), illustrates how to implement "
"a view function:"
msgstr ""
"下面的片段摘自 [这个链接](https://github.com/dojoengine/dojo-examples) 中的 "
"VRGDA 示例，说明了如何实现视图函数："

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr "在此示例中，函数根据正在进行的拍卖状态计算并返回 VRGDA 的当前价格。"

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr "**如何调用视图函数？**"

#: src/cairo/systems.md:80
msgid ""
"- **Using Dojo Core**: If you are working within the [Dojo Core](../client/"
"npm/core.md), utilize the `call` function. \n"
"  \n"
"- **For Rust Users**: The [Starkli](https://book.starkli.rs/) library "
"provides a handy method to invoke view functions in Rust."
msgstr ""
"- **使用 Dojo Core**：如果您在 [Dojo Core](../client/npm/core.md) 中开发，请"
"使用 `call` 函数。\n"
"  \n"
"- **适用于 Rust 用户**：[Starkli](https://book.starkli.rs/) 库提供了在 Rust "
"中调用视图函数的便捷方法。"

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr "我希望修订后的版本能使您想要传达的信息更加清晰流畅！"

#: src/cairo/systems.md:86
msgid "### System Authentication"
msgstr "### 系统验证"

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""
"系统必须获得写入组件的权限。默认情况下，它们没有权限。不过，我们可以通过 "
"`sozo` 赋予系统写入组件的权限。"

#: src/cairo/systems.md:90
msgid ""
"```console\n"
"sozo auth writer Moves Spawn \n"
"```"
msgstr ""
"```console\n"
"sozo auth writer Moves Spawn \n"
"```"

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr "在这里，我们授权 `Spawn` 系统写入`Moves` 组件。 "

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr "阅读 [sozo](../toolchain/sozo/overview.md) 文档中的更多内容。"

#: src/cairo/entities.md:1
msgid "## Entities"
msgstr "## 实体"

#: src/cairo/entities.md:3
msgid ""
"> Entities are the primary key value within the world, to which components "
"can be attached."
msgstr "> 实体是世界中的主要关键值，组件可以附加到实体上。"

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""
"不同的 ECS 系统处理实体的方式各不相同。在 Dojo 中，实体被视为世界中的一个主键"
"值，可以附加组件。为了说明这一概念，请看一个简单的例子：游戏中的角色有一个 "
"`Moves` 和一个 `Position`组件。"

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""
"在定义该实体的组件时，需要注意的是，我们并不直接引用该实体。相反，我们只是提"
"供了实体将包含的两个结构。这种方法强调了 ECS 系统的灵活性和可组合性，允许轻松"
"创建和修改具有各种组件组合的实体。 "

#: src/cairo/entities.md:9
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the `ctx."
"origin` to reference the current entity."
msgstr ""
"现在，让我们为角色创建一个 `Spawn`。需要注意的是，我们没有在任何地方明确定义"
"实体。相反，我们使用 `ctx.origin` 来引用当前实体。"

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr "在本例中，我们使用 `ctx.origin` 来引用当前实体。"

#: src/cairo/entities.md:30
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + "
"10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/entities.md:58
msgid ""
"> ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-"
"FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""
"> ECS 理论：关于 ECS 系统的文章很多，如需深入了解，请阅读 [ECS-FAQ](https://"
"github.com/SanderMertens/ecs-faq)"

#: src/cairo/authorization.md:1
msgid "## Authorization"
msgstr "## 授权"

#: src/cairo/authorization.md:3
msgid ""
"> Authorization is crucial to a world, just like how authorization is "
"crucial to any smart contract."
msgstr "> 授权对一个世界至关重要，就像授权对任何智能合约都至关重要一样。"

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""
"正如[World](./world.md)一章所讨论的，自治世界（AW）的功能是嵌套在公共区块链中"
"的主权链。这些世界也对公众开放。这种结构允许任何人通过部署组件或系统来增强世"
"界。然而，这种开放性也带来了安全方面的考虑。与以太坊类似，在系统中与组件的状"
"态进行交互需要获得组件所有者的适当授权。"

#: src/cairo/authorization.md:7
msgid "### Auth Architecture"
msgstr "### 验证架构"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""
"每次在 `System`中调用 `set!`时，世界都会检查 `System`是否拥有更新组件状态的授"
"权。只有当`System`拥有必要的授权时，`set!`才会被执行。下图说明了授权架构。"

#: src/cairo/authorization.md:11
msgid "Authorization Architecture"
msgstr "授权架构"

#: src/cairo/authorization.md:13
msgid "### Providing Authorization"
msgstr "### 提供授权"

#: src/cairo/authorization.md:15
msgid ""
"> The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""
"> 组件的部署者是其初始所有者。组件所有者可以授予别人 `owner` 和 `writer`角"
"色。只有所有者才能授予系统 `writer`角色，使其可以更新组件。"

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr "`sozo` 提供了一个授权系统的便捷工具。"

#: src/cairo/authorization.md:19
msgid ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"
msgstr ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr "该命令将为 `spawn` 系统生成一个 `writer` 授权，以更新 `Moves` 组件。"

#: src/cairo/commands.md:1
msgid "## Commands"
msgstr "## 命令"

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr "理解命令是理解 Dojo 的关键。您将在设计系统时大量使用它们。"

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""
"Dojo 中的命令是在编译时扩展的通用函数，便于系统执行。它们通过抽象常见操作（如"
"检索或更新组件以及生成唯一 ID），为系统提供了一种与世界状态交互的便捷方式。通"
"过利用这些命令，开发人员可以简化系统实现并提高代码的可读性。"

#: src/cairo/commands.md:8
msgid "### Using commands"
msgstr "### 使用命令"

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr "命令用于系统内部与世界状态的交互。它们的调用语法如下："

#: src/cairo/commands.md:12 src/cairo/commands.md:22
msgid ""
"```rust,ignore\n"
"let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
"```"
msgstr ""
"```rust,ignore\n"
"let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
"```"

#: src/cairo/commands.md:16
msgid "### The `get!` command"
msgstr "### `get!` 命令"

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr "`get!`命令用于从世界状态中检索组件。"

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""
"在这里，我们从世界状态中获取 `Position` 和 `Moves`组件。我们还使用 `ctx."
"origin` 来检索当前实体的组件。"

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr "然后，您可以像使用其他 Cairo 结构体一样使用 `position` 和 `moves`。"

#: src/cairo/commands.md:30
msgid "### The `set!` command"
msgstr "### `set！`命令"

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr "`set!` 命令用于更新组件状态。"

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""
"在这里，我们使用 `ctx.origin` 作为实体 ID，更新世界状态中的 `Moves` 和 "
"`Position` 组件。"

#: src/cairo/commands.md:52
msgid "### The `emit!` command"
msgstr "### `emit！`命令"

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr "`emit!`命令用于发射自定义事件。"

#: src/cairo/commands.md:58 src/cairo/events.md:78
msgid ""
"```rust,ignore\n"
"emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"```"
msgstr ""
"```rust,ignore\n"
"emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"```"

#: src/cairo/events.md:1
msgid "## Events"
msgstr "## 事件"

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/"
"overview.md), all these events are seamlessly indexed, ensuring easy and "
"efficient querying."
msgstr ""
"事件在让外部了解 Dojo 世界中的动态时起着关键作用。每次`Component`更新时，"
"`World` 合约都会发出这些事件。更令人兴奋的是，你可以根据特定需求制作自己的自"
"定义事件！此外，由于使用了 [Torii](../toolchain/torii/overview.md)，所有这些"
"事件都被无缝地索引起来，确保了轻松高效的查询。"

#: src/cairo/events.md:6
msgid "### Component Events"
msgstr "### 组件事件"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr "请看  `Moves` 组件的示例："

#: src/cairo/events.md:10
msgid ""
"```rust,ignore\n"
"#[component]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[component]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr "当该组件更新时，`World` 合约将发出一个结构如下的事件："

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""
"然后，[Torii](../toolchain/torii/overview.md)将捕获这些信息，并编制索引以供查"
"询。这样，你就可以重建世界的状态。"

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr "同样，当一个组件被删除时，`World` 合约将发出一个结构如下的事件："

#: src/cairo/events.md:35
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"

#: src/cairo/events.md:43
msgid "### World Events"
msgstr "### 世界事件"

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""
"当初始化以及注册新组件和系统时，`World`合约也会发出事件。这些事件通过以下结构"
"体发出："

#: src/cairo/events.md:47
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"

#: src/cairo/events.md:55
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:63
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""
"[Torii](../toolchain/torii/overview.md) 也会捕获这些事件，并编制索引以供查"
"询。"

#: src/cairo/events.md:74
msgid "### Custom Events"
msgstr "### 自定义事件"

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""
"在您的系统中，发射自定义事件是非常有益的。幸运的是，有一个方便的 `emit!`宏可"
"以让您直接从您的世界中发射事件。使用方法如下："

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr "在系统中加入此机能后，它将发出一个结构如下的事件："

#: src/cairo/events.md:84
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr "现在是一个使用自定义事件的完整示例： "

#: src/cairo/events.md:94
msgid ""
"```rust,ignore\n"
"fn execute(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(ctx.world, ctx.origin, (Position, "
"Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(ctx.world, (moves, next));\n"
"    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"    return ();\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn execute(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(ctx.world, ctx.origin, (Position, "
"Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(ctx.world, (moves, next));\n"
"    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
"    return ();\n"
"}\n"
"```"

#: src/cairo/events.md:107
msgid ""
"> Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr "> 注意：请阅读 [命令](./commands.md) 中的 `get!` 和 `set!` 宏。"

#: src/cairo/testing.md:1
msgid "## Testing"
msgstr "## 测试"

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""
"测试在任何软件开发过程中都是重要组成部分。Dojo 提供了一个测试框架，允许您为智"
"能合约编写测试。由于 Dojo 使用自定义编译器，因此您需要使用 `sozo` 来测试您的"
"合约。"

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr "在项目目录中，只需："

#: src/cairo/testing.md:7
msgid ""
"```shell\n"
"sozo test\n"
"```"
msgstr ""
"```shell\n"
"sozo test\n"
"```"

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr "这将搜索项目中的所有测试并运行它们。"

#: src/cairo/testing.md:14
msgid "### Writing Unit Tests"
msgstr "### 编写单元测试"

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the Component/"
"System you are writing."
msgstr "最佳做法是将单元测试包含在与正在编写的组件/系统相同的文件中。"

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the [dojo-starter](https://github."
"com/dojoengine/dojo-starter):"
msgstr ""
"让我们展示一个来自 [dojo-starter](https://github.com/dojoengine/dojo-"
"starter) 的 `Component` 测试示例："

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr "`components.cairo`"

#: src/cairo/testing.md:21
msgid ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not "
"zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, "
"y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not "
"zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, "
"y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""
"在本测试中，我们将测试 `Position` 组件的 `is_zero` 和 `is_equal` 函数。测试组"
"件的所有函数是一种很好的实践。"

#: src/cairo/testing.md:52
msgid "### Writing Integration Tests"
msgstr "### 编写集成测试"

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""
"集成测试是测试整个系统的 e2e 测试。您可以在项目根目录下创建一个 `tests` 目"
"录，为您的世界编写集成测试。然后为要编写的每个集成测试创建一个文件。"

#: src/cairo/testing.md:56
msgid ""
"This is the example from the [dojo-starter](https://github.com/dojoengine/"
"dojo-starter):"
msgstr ""
"这是来自 [dojo-starter](https://github.com/dojoengine/dojo-starter): 的示例："

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr "`systems.cairo`"

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"

#: src/cairo/testing.md:113
msgid "#### Useful Dojo Test Functions"
msgstr "#### 有用的 Dojo 测试函数"

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""
"`spawn_test_world(components, systems)` - 这个函数将用你传入的组件和系统创建"
"一个测试世界。它还将部署该世界并注册组件和系统。"

#: src/cairo/modules.md:1
msgid "## Dojo Modules"
msgstr "## Dojo 的模块"

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""
"通过系统和组件的标准化，我们可以为 Dojo 创建一个模块架构。这样，我们就可以创"
"建可在任何 Dojo 世界中使用的可重用模块。"

#: src/cairo/modules.md:5
msgid "### Module Architecture"
msgstr "### 模块架构"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""
"我们可将模块视为 Dojo 的 ERC。它们是创建和共享功能的标准方式。模块是可导入 "
"Dojo 世界的系统和组件的集合。Dojo 遵循 ERC 模式，并已经为 ERC20、ERC721 和 "
"ERC1155 定义了模块。"

#: src/cairo/modules/erc20.md:1
msgid "## ERC20"
msgstr "## ERC20"

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""
"Dojo 的 ERC20 模块是 ERC20 token标准的标准实现，但它使用了 Dojo 系统和组件。"
"这使我们能够利用 ERC20 标准的出色特性，并在 Dojo 环境中使用它。"

#: src/cairo/modules/erc20.md:5
msgid "### Integration into Your World"
msgstr "### 集成到你的世界"

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""
"要将 ERC20 模块集成到您的世界中，您必须首先部署 ERC20 Dojo 合约。然后，将系统"
"和组件安装到您的世界中。"

#: src/client/overview.md:1
msgid "# Overview"
msgstr "# 概览"

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr "Dojo 是 BYO 客户端，这意味着您可以使用任何客户端连接到 Dojo 网络。"

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr "参考客户端可在以下平台获取："

#: src/client/overview.md:7
msgid "- [npm](./npm.md)"
msgstr "- [npm](./npm.md)"

#: src/client/npm.md:1
msgid "# Javascript Libraries"
msgstr "# Javascript 库"

#: src/client/npm.md:3
msgid ""
"> Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr "> Javascript 是入门 Dojo 的好方法。它简单易用，几分钟就能上手。"

#: src/client/npm.md:5
msgid "### Examples using these:"
msgstr "### 使用的例子："

#: src/client/npm.md:7
msgid ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-"
"app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-"
"app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#: src/client/npm.md:10
msgid "### @dojoengine/core"
msgstr "### @dojoengine/core"

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""
"这是最底层的库，所有其他下游库都使用它。它包含 Dojo 的核心功能，并公开合约接"
"口。如果您想在 Dojo 的基础上构建自己的库，请使用它。"

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr "[文档](./npm/core.md)"

#: src/client/npm.md:16 src/client/npm/core.md:12
msgid ""
"```console\n"
"yarn add @dojoengine/core\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/core\n"
"```"

#: src/client/npm.md:20
msgid "### @dojoengine/react"
msgstr "### @dojoengine/react"

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud React](https://github.com/latticexyz/mud/tree/"
"main/packages)"
msgstr ""
"这是对 [Mud React](https://github.com/latticexyz/mud/tree/main/packages) 的直"
"接分叉"

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr "该库包含一组 React 组件，可用于使用 Dojo 构建 React 应用程序。"

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr "[文档](./npm/react.md)"

#: src/client/npm.md:28
msgid ""
"```console\n"
"yarn add @dojoengine/react\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/react\n"
"```"

#: src/client/npm.md:33
msgid "### @dojoengine/create-burner"
msgstr "### @dojoengine/create-burner"

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr "Create burner 是将burner钱包集成到 Dojo 应用程序中的简单方法。"

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr "[Reopsitory](https://github.com/dojoengine/create-burner)"

#: src/client/npm.md:39
msgid ""
"```console\n"
"yarn add @dojoengine/create-burner\n"
"```"
msgstr ""
"```console\n"
"yarn add @dojoengine/create-burner\n"
"```"

#: src/client/npm/core.md:1
msgid "## @dojoengine/core"
msgstr "## @dojoengine/core"

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""
"该库抽象了世界界面，并提供了一组与世界交互的辅助函数。与直接与世界交互相比，"
"我们更倾向于使用该库。"

#: src/client/npm/core.md:5
msgid ""
"- World explorers\n"
"- World deployers\n"
"- Games\n"
"- Anaylitics"
msgstr ""
"- 世界探索者\n"
"- 世界部署者\n"
"- 游戏\n"
"- 分析"

#: src/client/npm/core.md:10
msgid "### Getting Started"
msgstr "### 开始"

#: src/client/npm/core.md:16
msgid "### Example Usage"
msgstr "### 使用示例"

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"
msgstr ""
"本例来自 [Dojo React App](https://github.com/dojoengine/dojo-starter-react-"
"app)。"

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"

#: src/toolchain/dojoup.md:1
msgid "# `dojoup`"
msgstr "# `dojoup`"

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr "轻松更新或还原到特定的 Dojo 分支。"

#: src/toolchain/dojoup.md:5
msgid "## Installing"
msgstr "## 安装"

#: src/toolchain/dojoup.md:11
msgid "## Usage"
msgstr "## 使用方法"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr "安装最新的**稳定**版本："

#: src/toolchain/dojoup.md:18
msgid ""
"> Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""
"> 注意：您可能需要安装 `jq` 才能使用 `dojoup`。您可以使用以下命令进行安装："

#: src/toolchain/dojoup.md:20
msgid ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"
msgstr ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr "安装特定**版本**（此处为 \"nightly \"版本）："

#: src/toolchain/dojoup.md:30
msgid ""
"```sh\n"
"dojoup --version nightly\n"
"```"
msgstr ""
"```sh\n"
"dojoup --version nightly\n"
"```"

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr "安装特定的**分支**（在本例中为 `release/0.1.0` 分支的最新提交）："

#: src/toolchain/dojoup.md:36
msgid ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr "安装**分叉的主分支**（本例中为 `tarrencev/dojo` 的主分支）："

#: src/toolchain/dojoup.md:42
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""
"安装分叉中的**特定分支**（在本例中，安装`tarrencev/dojo`中`patch-10`分支的最"
"新提交）："

#: src/toolchain/dojoup.md:48
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr "从**特定的Pull Request**进行安装："

#: src/toolchain/dojoup.md:54
msgid ""
"```sh\n"
"dojoup --pr 1071\n"
"```"
msgstr ""
"```sh\n"
"dojoup --pr 1071\n"
"```"

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr "从**特定提交**进行安装："

#: src/toolchain/dojoup.md:60
msgid ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"
msgstr ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/"
"dojo`, assuming you're in the home directory)"
msgstr ""
"安装本地目录或版本库（例如位于 `~/git/dojo` 的版本库，假设您在主目录下）"

#: src/toolchain/dojoup.md:66
msgid ""
"##### Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr "##### 注意：本地安装时，--branch、--repo 和--version 标识符将被忽略。"

#: src/toolchain/dojoup.md:68
msgid ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""
"**提示**：所有标识符都有对应的单字符缩写！您可以使用 `-v` 代替 `--version` "
"等。"

#: src/toolchain/dojoup.md:78
msgid "### Precompiled binaries"
msgstr "### 预编译的二进制文件"

#: src/toolchain/dojoup.md:80
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://"
"github.com/dojoengine/dojo/releases).\n"
"These are better managed by using [Dojoup](#using-dojoup)."
msgstr ""
"预编译的Dojo二进制文件可从[GitHub上的发行页面](https://github.com/dojoengine/"
"dojo/releases)获取。\n"
"使用[Dojoup](#using-dojoup)可以更好地管理这些二进制文件。"

#: src/toolchain/dojoup.md:84
msgid ""
"> ℹ️ **Note**\n"
">\n"
"> If you're on Windows, you will need to install and use [Git BASH](https://"
"gitforwindows.org/) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install),\n"
"> as your terminal, since Dojoup currently does not support Powershell or "
"Cmd."
msgstr ""
"> ℹ️ **注**\n"
">\n"
"> 如果您使用的是 Windows 系统，则需要安装并使用 [Git BASH](https://"
"gitforwindows.org/) 或 [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install)、\n"
"> 因为 Dojoup 目前不支持 Powershell 或 Cmd。"

#: src/toolchain/sozo/overview.md:1
msgid "## Sozo"
msgstr "## Sozo"

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of World-"
"building. In the future, it may include a GUI."
msgstr ""
"`sozo`（译者注：sozo是日文“創造”的罗马字） 是一款功能强大的多合一工具，用于管"
"理 Dojo 项目。从搭建新项目的脚手架，一直到部署和与 Dojo Worlds 交互，它都能提"
"供帮助。它包括一个迁移规划工具，旨在简化 AW 的更新和部署。它提供了一个强大的"
"命令行界面（CLI），可简化世界管理任务，让您专注于世界构建的创意方面。将来，它"
"还可能包括图形用户界面。"

#: src/toolchain/sozo/overview.md:5
msgid "## Features"
msgstr "## 功能"

#: src/toolchain/sozo/overview.md:7
msgid ""
"-   **Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""
"-   **二进制包 CLI**：Sozo 提供直观的二进制包 CLI，确保了用户能轻松管理世界，"
"无论是更新现有世界还是部署新世界。"

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
msgid "## Installation"
msgstr "## 安装"

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-"
"start.md), our dedicated installation package manager."
msgstr ""
"`sozo` 二进制文件可通过[`dojoup`](../../getting-started/quick-start.md)安装，"
"这是我们专用的安装包管理器。"

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
msgid "### Installing from Source"
msgstr "### 从源码安装"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr "这将在本地系统中安装 Sozo 和所需的依赖项。"

#: src/toolchain/sozo/overview.md:23
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""
"> 📚 **参考资料**\n"
">\n"
"> 关于所有可用子命令的完整概述，请参阅 [`sozo`参考资料](./reference.md)。"

#: src/toolchain/sozo/reference.md:1
msgid "## sozo reference"
msgstr "## sozo 参考资料"

#: src/toolchain/sozo/reference.md:3
msgid "### Project Commands"
msgstr "### 项目命令"

#: src/toolchain/sozo/reference.md:5
msgid ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"
msgstr ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"

#: src/toolchain/sozo/reference.md:10
msgid "### World Commands"
msgstr "#### 世界命令"

#: src/toolchain/sozo/reference.md:12
msgid ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"
msgstr ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"

#: src/toolchain/sozo/project-commands/init.md:1
msgid "## sozo init"
msgstr "## sozo init"

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."
msgstr ""
"`init` 用于初始化一个新项目。它将通过克隆 [dojo-starter](https://github.com/"
"dojoengine/dojo-starter) 在当前目录下初始化一个新项目。"

#: src/toolchain/sozo/project-commands/init.md:5
#: src/tutorial/onchain-chess/0-setup.md:21
msgid ""
"```sh\n"
"sozo init\n"
"```"
msgstr ""
"```sh\n"
"sozo init\n"
"```"

#: src/toolchain/sozo/project-commands/build.md:1
msgid "## sozo build"
msgstr "## sozo build"

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr "`build` 用于编译 cairo 合约，生成部署所需的构件。"

#: src/toolchain/sozo/project-commands/build.md:5
#: src/tutorial/onchain-chess/0-setup.md:38
msgid ""
"```sh\n"
"sozo build\n"
"```"
msgstr ""
"```sh\n"
"sozo build\n"
"```"

#: src/toolchain/sozo/project-commands/test.md:1
msgid "## sozo test"
msgstr "## sozo test"

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr "`test`用于测试项目的Cairo合约。它将运行项目中的所有测试。"

#: src/toolchain/sozo/project-commands/test.md:5
msgid ""
"```sh\n"
"sozo test\n"
"```"
msgstr ""
"```sh\n"
"sozo test\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "## sozo migrate"
msgstr "## sozo migrate"

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""
"`migrate`用于执行迁移（部署）流程，根据部署或更新世界的需要声明和部署合约。"

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""
"在初始部署后对本地世界所做的更改，可以通过运行 `sozo migrate --world "
"<WORLD_ADDRESS>`（其中 `WORLD_ADDRESS`是远程世界的地址）轻松推送到远程世界。"
"在后台，`migrate` 会计算本地世界和远程世界的差异，然后开始构建迁移策略，以确"
"定（如果有的话）本地世界的哪一部分需要推送到上游。"

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7
msgid "### USAGE"
msgstr "### 用例"

#: src/toolchain/sozo/project-commands/migrate.md:9
msgid ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105 src/toolchain/torii/reference.md:33
msgid "### OPTIONS"
msgstr "### 选项"

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107 src/toolchain/torii/reference.md:35
msgid "#### General Options"
msgstr "#### 常规选项"

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Name of the World. At the moment, the only usage for "
"this option is to be used as a salt when deploying the World contract to "
"avoid address conflicts. This option is **required** when performing the "
"initial migration of the World."
msgstr ""
"`--name` _NAME_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;世界的名称。目前，该选项的唯一用途是在部署 \"世界 "
"\"合约时用作 \"盐\"，以避免地址冲突。在执行 \"世界 \"的初始迁移时，该选项是**"
"必需的**。"

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
msgid "#### World Options"
msgstr "#### 世界选项"

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The address of the World contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""
"`--world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;世界合约的地址。  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
msgid "#### Starknet Options"
msgstr "#### Starknet选项"

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet RPC endpoint. [default: http://"
"localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"
msgstr ""
"`--rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Starknet RPC 端点。[默认: http://localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
msgid "#### Account Options"
msgstr "#### 账户选项"

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet account address.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Starknet账户地址。  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
msgid "#### Signer Options - Raw"
msgstr "#### 签名者选项 - Raw"

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The raw private key associated with the account "
"contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"
msgstr ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;与账户合同相关的Raw私钥。  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
msgid "#### Signer Options - Keystore"
msgstr "#### 签名者选项 - Keystore"

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
msgid ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Use the keystore in the given folder or file."
msgstr ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;使用指定文件夹或文件中的keystore。"

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The keystore password. Used with --keystore.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;keystore的密码. 需要与 --keystore 参数一起使用.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:186
msgid "### EXAMPLES"
msgstr "#### 示例"

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "1. Deploying your World for the first time to a local Katana node"
msgstr "1. 首次在本地 Katana 节点上部署你的世界"

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "2. Updating a remote World after making some changes"
msgstr "2. 更改后更新远程世界"

#: src/toolchain/sozo/project-commands/migrate.md:63
msgid ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "## sozo execute"
msgstr "## sozo execute"

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr "`execute` 用于执行一个世界的系统。"

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""
"执行系统需要发送事务，因此，`execute`需要一个账户地址及其私钥，以便在发送事务"
"之前对其进行签名。"

#: src/toolchain/sozo/world-commands/execute.md:9
msgid ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The calldata to be passed to the system that you "
"want to execute.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420."
msgstr ""
"`--calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;要传给系统执行的 calldata。  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;以逗号分隔的值，例如 0x12345,0x69420。"

#: src/toolchain/sozo/world-commands/execute.md:56
msgid ""
"1. Executing the _position_ system which takes two values (_x_: 0x77 and "
"_y_: 0x44)"
msgstr "1. 执行 _position_ 系统，该系统取两个值（ _x_ : 0x77 和 _y_ : 0x44）"

#: src/toolchain/sozo/world-commands/execute.md:58
msgid ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"
msgstr ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:1
msgid "## sozo register"
msgstr "## sozo register"

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr "`register` 用于注册新系统和组件。"

#: src/toolchain/sozo/world-commands/register.md:5
msgid ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:16
msgid ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:1
msgid "## sozo system"
msgstr "## sozo system"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr "`system`用于与世界的系统进行交互。它有助于查询系统信息。"

#: src/toolchain/sozo/world-commands/system.md:7
msgid ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"
msgstr ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
msgid "### SUBCOMMANDS"
msgstr "### 子命令"

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
msgid "#### `get`"
msgstr "#### `get`"

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr "获取系统的Class Hash"

#: src/toolchain/sozo/world-commands/system.md:21
msgid ""
"```sh\n"
"sozo system get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "##### Arguments"
msgstr "##### 参数"

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the system"
msgstr ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;系统名称"

#: src/toolchain/sozo/world-commands/system.md:30
msgid "#### `dependency`"
msgstr "#### `dependency`"

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr "检索系统的组件依赖关系"

#: src/toolchain/sozo/world-commands/system.md:34
msgid ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:59
msgid "1. Get the class hash of the _spawn_ system"
msgstr "1. 获取 _spawn_ 系统的Class Hash"

#: src/toolchain/sozo/world-commands/system.md:61
msgid ""
"```sh\n"
"sozo system get spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system get spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:65
msgid "2. Get the component dependencies of the _spawn_ system"
msgstr "2. 获取 _spawn_ 系统的组件依赖关系"

#: src/toolchain/sozo/world-commands/system.md:67
msgid ""
"```sh\n"
"sozo system dependency spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency spawn\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:1
msgid "## sozo component"
msgstr "## sozo component"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""
"`component`用于与世界的组件进行交互。它可用于查询组件信息或实体的组件值。"

#: src/toolchain/sozo/world-commands/component.md:7
msgid ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"
msgstr ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr "获取组件的Class Hash"

#: src/toolchain/sozo/world-commands/component.md:22
msgid ""
"```sh\n"
"sozo component get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;组件名称"

#: src/toolchain/sozo/world-commands/component.md:31
msgid "#### `schema`"
msgstr "#### `schema`"

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr "获取组件的scbema"

#: src/toolchain/sozo/world-commands/component.md:35
msgid ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:44
msgid "#### `entity`"
msgstr "#### `entity`"

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr "获取实体的组件值"

#: src/toolchain/sozo/world-commands/component.md:48
msgid ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"
msgstr ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:54
msgid ""
"_`NAME`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;组件名称"

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The keys of the entity that you want to query.  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;要查询的实体的键值。  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;以逗号分隔的值，例如：0x12345,0x69420,..."

#: src/toolchain/sozo/world-commands/events.md:1
msgid "## sozo events"
msgstr "## sozo events"

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr "`events`用于查询世界事件。"

#: src/toolchain/sozo/world-commands/events.md:5
msgid ""
"```sh\n"
"sozo events\n"
"```"
msgstr ""
"```sh\n"
"sozo events\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "## sozo auth"
msgstr "## sozo auth"

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr "`auth` 用于管理世界授权。"

#: src/toolchain/sozo/world-commands/auth.md:5
msgid ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:15
msgid ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position "
"component\n"
"sozo auth writer Position spawn\n"
"```"

#: src/toolchain/katana/overview.md:1
msgid "## Katana"
msgstr "## Katana"

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""
"`katana` （译者注：katana是日文“刀”的罗马字）是一个速度惊人的本地星网节点，旨"
"在支持使用 Dojo 进行本地开发。"

#: src/toolchain/katana/overview.md:5
msgid "### Features"
msgstr "### 功能"

#: src/toolchain/katana/overview.md:7
msgid ""
"-   [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-"
"specs/tree/v0.3.0) support\n"
"-   Custom methods for manipulating the blockchain states"
msgstr ""
"-   支持 [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0)\n"
"-   用于操作区块链状态的自定义方法"

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via [`dojoup`](../../getting-started/quick-"
"start.md)."
msgstr ""
"`katana`二进制文件可通过 [`dojoup`](../../getting-started/quick-start.md) 获"
"取。"

#: src/toolchain/katana/overview.md:14
msgid "### Installing from source"
msgstr "### 从源码安装"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"

#: src/toolchain/katana/overview.md:22
msgid "### Usage"
msgstr "### 使用方法"

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"

#: src/toolchain/katana/overview.md:60
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""
"> 📚 **参考资料**\n"
">\n"
"> 请参阅 [`katana`参考资料](./reference.md)，了解有关 Katana 的深度参考资料和"
"文档。"

#: src/toolchain/katana/reference.md:1
msgid "## katana reference"
msgstr "## katana参考资料"

#: src/toolchain/katana/reference.md:3
msgid "### NAME"
msgstr "### 名称"

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr "katana - 创建本地测试网节点，用于部署和测试Starknet智能合约。"

#: src/toolchain/katana/reference.md:9
msgid ""
"```sh\n"
"katana [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"katana [OPTIONS]\n"
"```"

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
msgid "### DESCRIPTION"
msgstr "### 描述"

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"创建本地测试网节点，用于部署和测试Starknet智能合约。Katana 支持部署和执行 **"
"新** 以及 **旧**（Cairo 0）Cairo合约。"

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""
"本节包含有关挖矿模式、支持的 RPC 方法、Katana 标志符及其用法的大量信息。您可"
"以同时运行多个标志符。"

#: src/toolchain/katana/reference.md:19
msgid "#### Mining Modes"
msgstr "#### 挖矿模式"

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""
"在 Katana 中，挖矿模式决定了区块的挖矿频率。默认情况下，一旦有交易提交，就会"
"自动挖出一个新区块。"

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""
"您可以将默认的挖矿行为切换为间隔挖矿，即按照用户选择的固定时间间隔创建新区"
"块。要启用这种挖矿模式，请使用`--block-time <SECONDS>` 标识符，如下例所示。"

#: src/toolchain/katana/reference.md:25
msgid ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10\n"
"```"
msgstr ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10\n"
"```"

#: src/toolchain/katana/reference.md:30
msgid "#### Supported Transport Layers"
msgstr "#### 支持的传输层"

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""
"目前只支持 HTTP 连接。服务器默认监听 5050 端口，但可以通过运行以下命令进行更"
"改："

#: src/toolchain/katana/reference.md:34
msgid ""
"```sh\n"
"katana --port <PORT>\n"
"```"
msgstr ""
"```sh\n"
"katana --port <PORT>\n"
"```"

#: src/toolchain/katana/reference.md:38
msgid "#### Starknet Feature Compatibility"
msgstr "#### Starknet功能兼容性"

#: src/toolchain/katana/reference.md:40
msgid "##### Supported Transaction Type"
msgstr "##### 支持的交易类型"

#: src/toolchain/katana/reference.md:42
msgid ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"
msgstr ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"

#: src/toolchain/katana/reference.md:48
msgid "#### Supported RPC Methods"
msgstr "#### 支持的 RPC 方法"

#: src/toolchain/katana/reference.md:50
msgid "##### Starknet Methods"
msgstr "##### Starknet方法"

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on [this](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katana 支持版本**v0.3.0**的星网 JSON-RPC 规范。标准方法基于 [此处](https://"
"github.com/starkware-libs/starknet-specs/tree/v0.3.0) 的参考文献。"

#: src/toolchain/katana/reference.md:54
msgid ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   `starknet_getClassAt`\n"
"\n"
"-   `starknet_syncing`\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"
msgstr ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   `starknet_getClassAt`\n"
"\n"
"-   `starknet_syncing`\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"

#: src/toolchain/katana/reference.md:83
msgid "##### Custom Methods"
msgstr "##### 自定义方法"

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""
"Katana 提供了一套方便的自定义 RPC 方法，可快速、轻松地配置节点，以适应测试环"
"境。"

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock`  \n"
"挖掘一个新区块，其中包括当前所有待处理的交易。"

#: src/toolchain/katana/reference.md:90
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`  \n"
"获取下一个区块的时间。"

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`  \n"
"将区块的时间增加给定的时间量，以秒为单位。"

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""
"`katana_setNextBlockTimestamp`  \n"
"与 `katana_increaseNextBlockTimestamp` 类似，但会在下一个区块中使用你想要的确"
"切时间戳。"

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"`katana_predeployedAccounts`  \n"
"获取所有预部署账户的信息。"

#: src/toolchain/katana/reference.md:102
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""
"`katana_setStorageAt`\n"
"设置合约存储槽中的精确值。"

#: src/toolchain/katana/reference.md:109
msgid ""
"`--silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Don't print anything on startup."
msgstr ""
"`--silent`  \n"
" &nbsp;&nbsp;&nbsp;&nbsp; 启动时不打印任何内容。"

#: src/toolchain/katana/reference.md:112
msgid ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable auto and interval mining, and mine on "
"demand instead."
msgstr ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 禁用自动采矿和间隔采矿，改为按需采矿。"

#: src/toolchain/katana/reference.md:115
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Block time in seconds for interval mining."
msgstr ""
"`-b, --block-time <SECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 以秒为单位的区间挖掘时间。"

#: src/toolchain/katana/reference.md:118
msgid ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dump the state of chain on exit to the given "
"file.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; If the value is a directory, the state will be "
"written to `<PATH>/state.bin`."
msgstr ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 将退出时链的状态转存到给定文件。  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 如果值是目录，状态将被写入 `<PATH>/state.bin`。"

#: src/toolchain/katana/reference.md:122
msgid ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Initialize the chain from a previously saved state "
"snapshot."
msgstr ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;从先前保存的状态快照初始化链。"

#: src/toolchain/katana/reference.md:125
msgid ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help (see a summary with '-h')."
msgstr ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 打印帮助（用\"-h \"查看摘要）。"

#: src/toolchain/katana/reference.md:128
msgid ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version information."
msgstr ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 打印版本信息。"

#: src/toolchain/katana/reference.md:131
msgid "#### Server Options"
msgstr "#### 服务器选项"

#: src/toolchain/katana/reference.md:133
msgid ""
"`-p, --port <PORT>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Port number to listen on. [default: 5050]"
msgstr ""
"`-p, --port <PORT>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 要监听的端口号[默认：5050］。"

#: src/toolchain/katana/reference.md:136
msgid ""
"`--host <HOST>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The IP address the server will listen on."
msgstr ""
"`--host <HOST>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 服务器监听的 IP 地址。"

#: src/toolchain/katana/reference.md:141
msgid ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify the seed for randomness of accounts to be "
"predeployed."
msgstr ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 指定要预先部署的账户随机性种子。"

#: src/toolchain/katana/reference.md:144
msgid ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Number of pre-funded accounts to generate. "
"[default: 10]"
msgstr ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 要生成的预注资账户数 [默认值：10]。"

#: src/toolchain/katana/reference.md:147
msgid ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable charging fee for transactions."
msgstr ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;禁用交易收gas费。"

#: src/toolchain/katana/reference.md:150
msgid "#### Environment Options"
msgstr "#### 环境选项"

#: src/toolchain/katana/reference.md:152
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The chain ID. [default: KATANA]"
msgstr ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 链 ID [默认值：KATANA］。"

#: src/toolchain/katana/reference.md:155
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The gas price."
msgstr ""
"`--gas-price <GAS_PRICE>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Gas价格。"

#: src/toolchain/katana/reference.md:158
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account validation logic."
msgstr ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 账户验证逻辑的最大步骤数。"

#: src/toolchain/katana/reference.md:161
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the "
"account execution logic."
msgstr ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 账户执行逻辑的最大步数。"

#: src/toolchain/katana/reference.md:164
msgid "### Shell Completions"
msgstr "### Shell 补完"

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr "`katana` completions shell"

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr "为给定的 shell 生成 shell 补完脚本。"

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr "支持的shell有："

#: src/toolchain/katana/reference.md:172
msgid ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"
msgstr ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"

#: src/toolchain/katana/reference.md:178
msgid "#### EXAMPLES"
msgstr "#### 示例"

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr "为 `bash` 生成 shell 补完脚本，并将其添加到 `.bashrc` 文件中："

#: src/toolchain/katana/reference.md:182
msgid ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"
msgstr ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"

#: src/toolchain/katana/reference.md:188
msgid "1. Create 15 dev accounts and disable transaction fee mechanism"
msgstr "1. 创建 15 个开发用账户并禁用交易费机制"

#: src/toolchain/katana/reference.md:190
msgid ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"
msgstr ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"

#: src/toolchain/katana/reference.md:194
msgid "2. Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr "2. 将链 id 设置为 `SN_GOERLI`，并在 8545 端口运行服务器"

#: src/toolchain/katana/reference.md:196
msgid ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"
msgstr ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"

#: src/toolchain/katana/reference.md:200
msgid ""
"3. Load previously stored state and dump the state of this session to a file "
"on shutdown"
msgstr "3. 加载先前存储的状态，并在网络关闭时将此会话的状态转储到文件中"

#: src/toolchain/katana/reference.md:202
msgid ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"
msgstr ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"

#: src/toolchain/torii/overview.md:1
msgid "## Torii - Networking & Indexing"
msgstr "## Torii - 网络和索引"

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""
"Torii（译者注：torii是日文“鳥居”的罗马字） 是 dojo 世界的自动索引器。采用 "
"rust 构建，速度极快，可扩展性极强。"

#: src/toolchain/torii/overview.md:5
msgid "### Dojo indexer"
msgstr "### Dojo 索引器"

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""
"Torii 可为你的 dojo 世界建立索引，并提供 GraphQL API 以进行查询。只需运行："

#: src/toolchain/torii/overview.md:9
msgid ""
"```sh\n"
"torii\n"
"```"
msgstr ""
"```sh\n"
"torii\n"
"```"

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr "就可以在 `http://localhost:8080` 上运行 GraphQL API 了！"

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/"
"quick-start.md), our dedicated installation package manager."
msgstr ""
"你可以通过我们专用的安装包管理器 [`dojoup`](../../getting-started/quick-"
"start.md)安装 `torii` 二进制文件。"

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "如果您更喜欢从源代码中安装请："

#: src/toolchain/torii/overview.md:22
msgid ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"
msgstr ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr "这将在本地系统中安装 Torii 和所需的依赖项。"

#: src/toolchain/torii/overview.md:28
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""
"> 📚 **参考资料**\n"
">\n"
"> 请参阅 [`torii`参考](./reference.md) 获取完整参考。"

#: src/toolchain/torii/reference.md:1
msgid "## torii reference"
msgstr "## torii 参考资料"

#: src/toolchain/torii/reference.md:3
msgid "### Name"
msgstr "### 名称"

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr "torii - 世界合约的自动索引器和网络层。"

#: src/toolchain/torii/reference.md:9
msgid ""
"```sh\n"
"torii [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"torii [OPTIONS]\n"
"```"

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""
"`torii`会启动索引器，并公开 GraphQL/gRPC API 端点。索引器会向指定的 Starknet "
"RPC 端点查询事务块，并监听与世界契约相关的事务。这些事务包括组件/系统注册、实"
"体状态更新、系统调用和事件。解析后的数据将存储在本地 SQLite 数据库中。"

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""
"GraphQL 和 gRPC API 端点与索引器同步运行，为客户端应用程序提供特定于世界契约"
"的自定义查询。"

#: src/toolchain/torii/reference.md:19
msgid "#### Database URL"
msgstr "#### 数据库 URL"

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""
"`torii` 使用sqlite数据库存储索引数据。数据库既可以存储在内存中，也可以持久地"
"存储在文件系统中。"

#: src/toolchain/torii/reference.md:23
msgid ""
"- The in-memory database is ephermal and only lasts as long as the indexer "
"is running. This is a fast and simple option to start the indexer for "
"development/testing.\n"
"- Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""
"- 内存数据库是非持久存在的，只有索引器运行时才会存在。这是在开发/测试中启动索"
"引器的快速而简单的选择。\n"
"- 生产环境中应使用持久存储。它依赖本地文件系统进行存储。"

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""
"注意：如果使用内存数据库，在一段时间不活动后内存将被垃圾回收，导致查询出错。"
"解决方法是使用 `--block-time` 选项启动 `katana` 或使用持久数据库。"

#: src/toolchain/torii/reference.md:28
msgid ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"
msgstr ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"

#: src/toolchain/torii/reference.md:37
msgid ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Address of the world contract to index"
msgstr ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 要索引的世界合同的地址"

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Starknet RPC endpoing to use [default: http//"
"localhost:5050]"
msgstr ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 要使用的Starknet RPC 终端 [默认：http//"
"localhost:5050]"

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a local manifest to initialize from"
msgstr ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 指定要初始化的本地清单"

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Database URL (read more above) [default: sqlite::"
"memory:]"
msgstr ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 数据库 URL（更多信息请阅读上文） [默认：sqlite::"
"memory:]"

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a block to start indexing from, ignored if "
"stored head exists [default: 0]"
msgstr ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 指定要从哪个块开始建立索引，如果存在存储头，则忽略 "
"[默认：0]"

#: src/toolchain/torii/reference.md:52
msgid ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help"
msgstr ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 打印帮助"

#: src/toolchain/torii/reference.md:55
msgid ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version"
msgstr ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 打印版本信息"

#: src/deployment/locally.md:1
msgid "## Deploying Locally"
msgstr "## 本地部署"

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""
"Dojo 专为快速开发而设计，拥有一个名为 [Katana](./toolchain/katana/overview."
"md)的快如闪电的本地开发环境。Katana 可作为设备上的Starknet区块链，允许您在将"
"智能合约迁移到远程测试网络之前对其进行严格测试。"

#: src/deployment/locally.md:5
msgid "### Katana Deployments"
msgstr "#### Katana 部署"

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr "部署合约到 Katana 再简单不过了。"

#: src/deployment/locally.md:9
msgid ""
"> This assumes you have followed the [Quick Start](./getting-started/quick-"
"start.md) guide and have a project initialized."
msgstr ""
"> 这里假设您已按照 [快速入门](./getting-started/quick-start.md) 指南进行了操"
"作，并已初始化了一个项目。"

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr "在项目目录下运行："

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr "这样就启动了一个本地Katana，您现在可以在上面进行部署！"

#: src/deployment/locally.md:19
msgid "### Deploying to Katana"
msgstr "### 部署到Katana"

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr "要将项目部署到 Katana，请运行："

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr "注意 - 只有在你的合约已经编译过的情况下才能运行。如果没有，请运行："

#: src/deployment/remote.md:1
msgid "## Deployment to Remote Network"
msgstr "## 部署到远程网络"

#: src/deployment/remote.md:3
msgid "> *IMPORTANT: Dojo is unaudited. Use at your own risk.*"
msgstr "> *重要提示：Dojo 未经审计。使用风险自负。*"

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr "Dojo 可让您轻松部署到远程网络，您只需拥有一个有效账户和网络端点。"

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr "Scarb.toml"

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"

#: src/deployment/remote.md:33
msgid "### Remote Katana"
msgstr "### 远程 Katana"

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr "Katanas 可以作为远程测试网托管和运行，但不建议用于生产。"

#: src/deployment/remote.md:37
msgid "__todo__: add instructions for deploying to remote katana"
msgstr "__todo__：添加部署到远程 katana 的说明"

#: src/deployment/remote.md:40
msgid "### Madara "
msgstr "### Madara "

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara)是一款高速Starknet排"
"序器。Madara 基于强大的 Substrate 框架构建，由于采用了 Rust 🦀，因此速度极"
"快，可提供无与伦比的性能和可扩展性，为您的基于Starknet的Validity Rollup链（译"
"者注：如通常意义上的appchain）提供动力。"

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr "已有公共的 Madara 测试网可供部署："

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr "您可以使用以下账户进行部署："

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"

#: src/deployment/remote.md:59
msgid "### Starknet "
msgstr "### Starknet "

#: src/deployment/remote.md:61
msgid "__todo__: add instructions for deploying to remote Starknet"
msgstr "__todo__：添加部署到远程Starknet的说明"

#: src/tutorial/onchain-chess/index.md:1
msgid "# Building a Chess Game"
msgstr "# 构建国际象棋游戏"

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr "_“我刚刚读完Dojo Book。接下来我该做什么？”_"

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""
"对这个问题的回答总是 \"做点什么吧！\"，有时还会列举一些很酷的项目。这对有些人"
"来说是个不错的答案，但有些人可能需要更多的指导。"

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""
"本指南旨在填补指导性较强的初学者教程与项目工作之间的空白。这里的主要目标是让"
"你编写代码。次要目标是让你阅读文档。"

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr "如果您还没有阅读过Dojo Book，强烈建议您在开始此项目之前先阅读一下。"

#: src/tutorial/onchain-chess/index.md:11
msgid "## What are we building?"
msgstr "## 我们在创造什么？"

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""
"我们正在构建一个链上国际象棋游戏合约，让您可以开始新游戏并下棋。本指南并不涵"
"盖国际象棋游戏的所有规则。您将按照以下步骤逐步构建："

#: src/tutorial/onchain-chess/index.md:15
msgid ""
"1. A system to spawn all the chess pieces\n"
"2. A system to make pieces move\n"
"3. Add some functions to check a legal move\n"
"4. Play chess ♟♙ - integration test!"
msgstr ""
"1. 生成所有棋子的系统\n"
"2. 让棋子移动的系统\n"
"3. 加入检查移动合法性的函数\n"
"4. 下棋 ♟♙ - 集成测试！"

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/"
"rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""
"教程的完整代码基于 [这个仓库](https://github.com/rkdud007/chess-dojo/tree/"
"tutorialv2)。"

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""
"如果这看起来太难，不用担心！本指南适合初学者。如果你了解Cairo和Dojo的一些基本"
"知识，那就没问题了。我们不会制作包含所有规则的完整游戏。我们将保持简单。"

#: src/tutorial/onchain-chess/index.md:24
msgid "## What after this guide?"
msgstr "## 这个教程之后是什么？"

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr "我们正在制作另一份教程，以帮助设计前端。这将使我们的棋局更加完整。"

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr "完成全部五章后，我们就可以继续学习前端指南了。"

#: src/tutorial/onchain-chess/0-setup.md:1
msgid "# 0. Setup"
msgstr "# 0.设置"

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-"
"dojo.md) chapter to gain a basic understanding of the Dojo game._"
msgstr ""
"_在开始之前，建议阅读 [`hello-dojo`](../../cairo/hello-dojo.md)一章，以获得"
"对 Dojo 游戏的基本了解。_"

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "## Initializing the Project"
msgstr "## 初始化项目"

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr "创建一个新的 Dojo 项目文件夹。您可以随心所欲地为项目命名。"

#: src/tutorial/onchain-chess/0-setup.md:9
msgid ""
"```sh\n"
"mkdir dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"mkdir dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr "打开项目文件夹。"

#: src/tutorial/onchain-chess/0-setup.md:15
msgid ""
"```sh\n"
"cd dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"cd dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr "然后使用 sozo init 初始化项目。"

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "## Cleaning Up the Boilerplate"
msgstr "## 清理模板"

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""
"该项目带有大量模板代码。请全部清除。确保 `components.cairo` 和 `systems."
"cairo` 文件为空。"

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr "在`lib.cairo`中，仅保留："

#: src/tutorial/onchain-chess/0-setup.md:31
msgid ""
"```rust,ignore\n"
"mod components;\n"
"mod systems;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod components;\n"
"mod systems;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr "用以下命令编译项目："

#: src/tutorial/onchain-chess/0-setup.md:42
msgid "## Basic components"
msgstr "## 基本组件"

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr "虽然有很多种方法使用 ECS 模型设计象棋游戏，但我们将采用这种方法："

#: src/tutorial/onchain-chess/0-setup.md:46
msgid ""
"> Every square of the chess board (e.g., A1) will be treated as an entity. "
"If a piece exists on a square, the square entity will hold that piece."
msgstr ""
"> 棋盘上的每个方格（例如 A1）都将被视为一个实体。如果某个方格上有棋子，则该方"
"格实体将包含该棋子。"

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this [chapter]"
"(../../cairo/components.md)."
msgstr ""
"首先，将这个基本组件添加到`components.cairo`文件中。如果你不熟悉 Dojo 引擎中"
"的组件语法，请回顾这个 [章节](../../cairo/components.md).。"

#: src/tutorial/onchain-chess/0-setup.md:50
msgid ""
"```rust,ignore\n"
"#[derive(Component)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:78
msgid "## Basic systems"
msgstr "## 基本系统"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""
"从下一章节开始，您将在每一章节中依次实现 `initiate` 和 `move` 系统。为了更好"
"地实现模块化，我们会在单独的文件中创建每个系统。"

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""
"在 `src` 创建一个 `systems` 文件夹。在文件夹内创建 `initiate.cairo` 和 `move."
"cairo` 两个文件。每个文件都应包含一个基本的系统结构。"

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr "例如，`initiate.cairo` 看起来像这样："

#: src/tutorial/onchain-chess/0-setup.md:86
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod initiate_system {\n"
"\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod initiate_system {\n"
"\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr "在 `systems.cairo` 中，我们将这样使用 `initiate_system`："

#: src/tutorial/onchain-chess/0-setup.md:95
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"\n"
"use initiate::initiate_system;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod initiate;\n"
"\n"
"use initiate::initiate_system;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr "对其他系统执行同样操作。更新 `systems.cairo` 为："

#: src/tutorial/onchain-chess/0-setup.md:103
msgid ""
"```rust,ignore\n"
"mod initiate;\n"
"mod move;\n"
"\n"
"use initiate::initiate_system;\n"
"use move::move_system;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod initiate;\n"
"mod move;\n"
"\n"
"use initiate::initiate_system;\n"
"use move::move_system;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:111
msgid "## Compile your project"
msgstr "## 编译项目"

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr "现在尝试 `sozo build` 进行构建。是不是遇到了错误？"

#: src/tutorial/onchain-chess/0-setup.md:115
#: src/tutorial/onchain-chess/0-setup.md:179
msgid ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr "您可能会遇到一些trait实现上的错误，您可以像这样通过派生来实现："

#: src/tutorial/onchain-chess/0-setup.md:121
msgid ""
"```rust,ignore\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr "很好！那就让我们来解决这个错误吧。"

#: src/tutorial/onchain-chess/0-setup.md:153
msgid ""
"```sh\n"
"error: Trait has no implementation in context: dojo::serde::SerdeLen::<core::"
"option::Option::<dojo_chess::components::PieceType>>\n"
" --> Square:80:54\n"
"                dojo::SerdeLen::<Option<PieceType>>::len()\n"
"                                                     ^*^\n"
"```"
msgstr ""
"```sh\n"
"error: Trait has no implementation in context: dojo::serde::SerdeLen::<core::"
"option::Option::<dojo_chess::components::PieceType>>\n"
" --> Square:80:54\n"
"                dojo::SerdeLen::<Option<PieceType>>::len()\n"
"                                                     ^*^\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""
"必须明确的一点是，`<Option<PieceType>>` 是我们创建的类型。因此，该类型没有实"
"现 SerdeLen 等基本traits。你需要自己定义实现。"

#: src/tutorial/onchain-chess/0-setup.md:162
msgid ""
"```rust,ignore\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr "修复上述其他问题，以便成功运行 `sozo build` 命令。"

#: src/tutorial/onchain-chess/0-setup.md:173
msgid "## Run test"
msgstr "## 运行测试"

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""
"在进入下一章之前，请记住`sozo build` 与 `sozo test`是确保代码正确的重要步骤。"

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr "运行 sozo 测试。出现错误了吗？"

#: src/tutorial/onchain-chess/0-setup.md:183
msgid ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""
"对于`no implementation`错误，请实现 `PrintTrait` 以成功运行 `sozo test`。对于"
"`not dropped`错误，添加 `Drop` trait。其他错误可通过添加派生或实现来逐一解"
"决。"

#: src/tutorial/onchain-chess/0-setup.md:189
msgid "## Add more components"
msgstr "## 添加更多组件"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr "在继续之前，请添加更多组件，以便在下一章创建系统时使用。"

#: src/tutorial/onchain-chess/0-setup.md:193
msgid "### Requirements"
msgstr "### 要求"

#: src/tutorial/onchain-chess/0-setup.md:195
msgid ""
"- `Color` enum enum with values White and Black\n"
"- `Game` component:"
msgstr ""
"- 具有白色和黑色值的 `Color` 枚举\n"
"- `Game`组件："

#: src/tutorial/onchain-chess/0-setup.md:198
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:205
msgid "- `GameTurn` component:"
msgstr "- `GameTurn`组件："

#: src/tutorial/onchain-chess/0-setup.md:207
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:212
msgid ""
"- We will later set game entity composed of the `Game` and `GameTurn` "
"components.\n"
"- Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""
"- 稍后我们将设置由 `Game` 和 `GameTurn` 组件组成的游戏实体。\n"
"- 运行 `sozo build` 和 `sozo test` 并确保所有测试通过。"

#: src/tutorial/onchain-chess/0-setup.md:215
msgid ""
"Try to solve on your own, and before you move on check the answer below."
msgstr "在进行下一步之前，请试着自己解题并对照下面的答案。"

#: src/tutorial/onchain-chess/0-setup.md:217
msgid ""
"<details>\n"
"<summary>Click to see full `components.cairo` code</summary>"
msgstr ""
"<details>\n"
"<summary>点击查看完整的 `components.cairo` 代码</summary>"

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:397
msgid "</details>"
msgstr "</details>"

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr "恭喜您！您已经完成了构建链上国际象棋游戏的基本设置 🎉"

#: src/tutorial/onchain-chess/1-initiate.md:1
msgid "# 1. Initiate System"
msgstr "# 1. 初始化系统"

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr "本章将讨论 `initiate_system` 的实现，它将生成游戏和包含棋子的方格。"

#: src/tutorial/onchain-chess/1-initiate.md:5
msgid "## What is `initiate_system`?"
msgstr "## 什么是`initiate_system`？"

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""
"要下棋，您需要开始游戏并生成棋子。`initiate_system` 会生成游戏实体，然后将每"
"个棋子放置在适当的位置。确保游戏状态与正确的棋子类型相匹配，并且正确颜色的棋"
"子位于棋盘上的指定位置。"

#: src/tutorial/onchain-chess/1-initiate.md:9
msgid ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" "
"height=\"auto\">"
msgstr ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" "
"height=\"auto\">"

#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
msgid "## Requirements"
msgstr "## 需求"

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"initiate.cairo` file._"
msgstr "_复制下面的单元测试，并将其粘贴到 `systems/initiate.cairo`文件的底部_"

#: src/tutorial/onchain-chess/1-initiate.md:16
msgid ""
"1. Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input.\n"
"2. Implement the game entity, comprised of the `Game` component and "
"`GameTurn` component we created in the previous step.\n"
"3. Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`.\n"
"4. Run `sozo test` and pass all the tests."
msgstr ""
"1. 在系统中编写一个 `execute`函数接受world context， white address， 以及 "
"black address 作为输入。\n"
"2. 实现由我们上一步骤里创建的 `Game` 和 `GameTurn` 组件组成的游戏实体。\n"
"3. 在`Square`组件中实现方格实体，从a1到a8并包含正确的`PieceType`。\n"
"4. 运行 `sozo test` 并通过所有测试。"

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
msgid "## Test Flow"
msgstr "## 测试流程"

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"- Spawn the test world that imports the components and systems used in "
"testing.\n"
"- Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs.\n"
"- Retrieve the game entity and piece entity created during "
"`initiate_system`.\n"
"- Ensure the game has been correctly created.\n"
"- Verify that each `Piece` is located in the correct `Square`."
msgstr ""
"- 生成测试世界并导入测试中使用的组件和系统。\n"
"- 提供黑白玩家的钱包地址作为输入来执行`initiate_system`。\n"
"- 获取`initiate_system`过程中创建的游戏实体以及棋子实体。\n"
"- 确保游戏已正确创建。\n"
"- 确认每个`Piece` 都放在正确的`Square`上。"

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
msgid "## Unit Tests"
msgstr "## 单元测试"

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
msgid "## Need help?"
msgstr "## 需要帮助？"

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community]"
"(https://discord.gg/akd2yfuRS3)!"
msgstr ""
"如果您遇到困难，请随时到 [Dojo 社区](https://discord.gg/akd2yfuRS3) 提问！"

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) for chapter 1 here."
msgstr ""
"您可以在这里找到第 1 章的 [答案](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo)。"

#: src/tutorial/onchain-chess/2-move.md:1
msgid "# 2. Move System"
msgstr "# Move系统"

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr "本章将讨论`move_system`的实现，它用于在棋盘上重新定位棋子。"

#: src/tutorial/onchain-chess/2-move.md:5
msgid "## What is `move_system`?"
msgstr "## `move_system` 是什么？"

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""
"下棋时，玩家必须移动棋盘上的棋子。由于我们用Square实体来表示棋子的位置，因此 "
"`move_system` 会以 (x,y) 的形式获取当前位置。它还会以 (x,y) 的形式获取下一个"
"位置，并将当前位置方格中的棋子视为要移动到下一个位置的目标。"

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"move.cairo` file._"
msgstr "_复制下面的单元测试，并将其粘贴到`systems/move.cairo`文件的底部。_"

#: src/tutorial/onchain-chess/2-move.md:13
msgid "1. Write an `execute` function in the system with the following inputs:"
msgstr "1. 在系统中编写一个`execute`函数，输入如下内容："

#: src/tutorial/onchain-chess/2-move.md:15
msgid ""
"```rust,ignore\n"
" fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    )\n"
"```"
msgstr ""
"```rust,ignore\n"
" fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    )\n"
"```"

#: src/tutorial/onchain-chess/2-move.md:25
msgid ""
"2. Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece.\n"
"\n"
"3. Run `sozo test` and ensure all tests pass."
msgstr ""
"2. 更新带有 `next_position` 的方格，使其包含新棋子，并确保带有 "
"`curr_position` 的方格不再包含棋子。\n"
"\n"
"3. 运行 `sozo test` 并确保所有测试通过。"

#: src/tutorial/onchain-chess/2-move.md:31
msgid ""
"- Follow the same logic as `test_initiate` from the previous chapter.\n"
"- Move the White Knight from (1,0) to (2,2) using the `move_system`.\n"
"- Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""
"- 跟随上一章中`test_initiate`的逻辑。\n"
"- 通过`move_system`把White Knight从(1,0) 移动到 (2,2)\n"
"- 获取更新之后的位置并且验证棋子成功移动到了新位置。"

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:1
msgid "# 3. Check Legal Move"
msgstr "# 3.检查合法移动"

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr "在本章中，我们将编写用于检查的函数："

#: src/tutorial/onchain-chess/3-legal.md:5
msgid ""
"- If the next move goes outside the board.\n"
"- If there's a piece that can be captured.\n"
"- If the next move is allowed for the type of piece.\n"
"- If the user can allow to make a action (based on the piece's color).\n"
"- ... You can also add other custom check functions."
msgstr ""
"- 如果下一步在棋盘之外 \n"
"- 是否有棋子可以被吃掉。 \n"
"- 棋子类型是否允许下一步棋。 \n"
"- 用户是否允许进行操作（基于棋子的颜色）。 \n"
"- ...您还可以添加其他自定义校验功能。"

#: src/tutorial/onchain-chess/3-legal.md:11
msgid "## Make Check Functions"
msgstr "## 编写校验函数"

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""
"我们需要在 `move_system` 中添加一些检查函数。这些函数将有助于确保下一步移动是"
"被允许的。"

#: src/tutorial/onchain-chess/3-legal.md:15
msgid "1. See if the next spot is allowed for the type of piece moving."
msgstr "1. 查看下一个位置该类型的棋子是否可以移动。"

#: src/tutorial/onchain-chess/3-legal.md:17
msgid ""
"```rust,ignore\n"
"  fn is_right_piece_move(\n"
"        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
"next_position: (u32, u32)\n"
"    ) -> bool {}\n"
"```"
msgstr ""
"```rust,ignore\n"
"  fn is_right_piece_move(\n"
"        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
"next_position: (u32, u32)\n"
"    ) -> bool {}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:23
msgid "2. See if the next spot is still on the board."
msgstr "2. 看看下一个位置是否还在棋盘上。"

#: src/tutorial/onchain-chess/3-legal.md:25
msgid ""
"```rust,ignore\n"
"  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
"```"
msgstr ""
"```rust,ignore\n"
"  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:29
msgid ""
"3. See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr "3. 看看尝试这个动作的人是否在正确的时间且以正确的阵营移动棋子。"

#: src/tutorial/onchain-chess/3-legal.md:31
msgid ""
"```rust,ignore\n"
" fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
"game_id: felt252) -> bool{}\n"
"```"
msgstr ""
"```rust,ignore\n"
" fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
"game_id: felt252) -> bool{}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:35
msgid ""
"4. You can also add other check functions to be extra sure the move is "
"allowed."
msgstr "4. 您还可以添加其他检查功能，以额外确保移动是允许的。"

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""
"编写了这些校验函数之后，就可以在主 `move_system` 函数中使用它们。您可以决定如"
"何设置它们以及使用哪些。我们将举例说明："

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //… upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), ‘Should be inside board’);\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            ‘Should be right piece move’\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array![‘Already same color piece exist’])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // … below code is the same\n"
"\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:85
msgid "## Testing Each Function"
msgstr "## 测试每个函数"

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""
"由于我们有不同的校验函数，因此需要对每个函数进行测试。为了方便起见，我们可以"
"在许多测试中使用相同的部分。"

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""
"首先，创建一个名为 `init_world_test` 的辅助函数。这会返回一个 "
"`IWorldDispatcher`，我们可以在移动系统测试中多次使用它。"

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute(‘initiate_system’.into(), calldata);\n"
"        world\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr "这样，我们的主 `test_move` 函数就会变得更简单。"

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""
"现在我们可以进行测试，如果尝试不允许的动作，测试就会显示错误。让我们创建一个 "
"`test_piecetype_illegal` 函数。这将检查你在移动系统中实现的 "
"`is_right_piece_move` 函数是否正常工作。"

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, ‘should be White "
"Knight’);\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece’),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute(‘move_system’.into(), move_calldata);\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr "最后进行测试。这些测试应能发现错误动作并反馈错误信息。"

#: src/tutorial/onchain-chess/3-legal.md:169
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutoralv2/src/systems/move.cairo) for chapter 3 here."
msgstr ""
"您可以在这里找到第 3 章的 [答案](https://github.com/rkdud007/chess-dojo/blob/"
"tutoralv2/src/systems/move.cairo)。"

#: src/tutorial/onchain-chess/4-test.md:1
msgid "# 4. Test Contract"
msgstr "# 4.测试合约"

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr "在本章中，我们将利用所学知识运行一个完整的国际象棋游戏场景。"

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr "下面是我们要做的测试："

#: src/tutorial/onchain-chess/4-test.md:7
msgid ""
"1. Spawn `white_pawn_1` to (0,1)\n"
"2. Move `white_pawn_1` to (0,3)\n"
"3. Move `black_pawn_2` to (1,6)\n"
"4. Move `white_pawn_1` to (0,4)\n"
"5. Move `black_pawn_2` to (1,5)\n"
"6. Move `white_pawn_1` to (1,5)\n"
"7. Capture `black_pawn_2`"
msgstr ""
"1. 让 `white_pawn_1` 出生在 (0,1)\n"
"2. 移动 `white_pawn_1` 到 (0,3)\n"
"3. 移动 `black_pawn_2` 到 (1,6)\n"
"4. 移动 `white_pawn_1` 到 (0,4)\n"
"5. 移动 `black_pawn_2` 到 (1,5)\n"
"6. 移动 `white_pawn_1` 到 (1,5)\n"
"7. 吃掉 `black_pawn_2`"

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""
"要放置棋子，请使用我们的`initiate_system`。要移动棋子，请使用`move_system`。"
"使用 `move_system` 时，请记住检查棋子是否能被吃掉。"

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr "在我们开始编写代码之前，请这样设置集成测试："

#: src/tutorial/onchain-chess/4-test.md:19
msgid ""
"- Copy the test below and add it to your `src/tests.cairo` file.\n"
"- Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""
"- 复制下面的测试并将其添加到你的 `src/tests.cairo` 文件中。\n"
"- 在你的 src 中创建一个 `test.cairo` ，更新 `lib.cairo` 添加 `mod tests;` 。"

#: src/tutorial/onchain-chess/4-test.md:22
msgid "## Full Code"
msgstr "## 完整代码"

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute(‘move_system’.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, “should be WhitePawn  "
"in (1,4)”);\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:143
msgid "## Diving into the Code"
msgstr "## 深入代码"

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr "首先，我们将设置球员及其阵营。"

#: src/tutorial/onchain-chess/4-test.md:147
msgid ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"
msgstr ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""
"我们应以数组形式列出 `Components and Systems` ，每个数组都以 CLASS_HASH 作为"
"元素。"

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr "接下来，我们将创建游戏世界。"

#: src/tutorial/onchain-chess/4-test.md:169
msgid ""
"```rust,ignore\n"
"     let world = spawn_test_world(components, systems);\n"
"```"
msgstr ""
"```rust,ignore\n"
"     let world = spawn_test_world(components, systems);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""
"我们使用 `initiate_system` 将方块棋子放到棋盘上。每个方格放置一个棋子。系统的"
"执行函数需要一些输入，我们将其作为 calldata 提供给它。"

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute(‘initiate_system’.into(), calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""
"让我们检查白方棋子是否位于 (0,1)。请记住，要获取存在于该方格上的棋子，需要使"
"用 `Square` 组件的键，即 `game_id`、`x` 和 `y`。对黑方进行同样的检查。"

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, “should be White Pawn "
"in (0,1)”);\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece in (0,1)),\n"
"        };\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""
"设置好棋盘后，使用 `move_system` 下棋。提供当前位置、下一个位置、玩家地址和游"
"戏 ID。"

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute(‘move_system’.into(), move_calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr "不断移动棋子，检查它们的位置是否正确。"

#: src/tutorial/onchain-chess/4-test.md:212
msgid "## Congratulations!"
msgstr "## 恭喜！"

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""
"您已经使用 Dojo 引擎制作了国际象棋游戏的基本合约！本教程只是一个开始。有很多"
"方法可以让游戏变得更好，例如优化部分、添加检查或考虑特殊情况。如果您想在这个"
"国际象棋游戏中做得更多，请尝试这些挑战："

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"- Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient.\n"
"- Add a checkmate feature. Our game doesn't end now, so decide when it "
"should!\n"
"- Include special moves like castling, En Passant Capture, or Pawn "
"Promotion.\n"
"- Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""
"- 创建一个使用 lazy init 的`initiate_system`。如果你对 lazy init 不确定，[阅"
"读一下](https://en.wikipedia.org/wiki/Lazy_initialization)。这有助于提高游戏"
"操作的效率。\n"
"- 添加将死功能。我们的游戏现在还没有结束，因此请决定何时应该结束！\n"
"- 加入特殊的棋步，如投子、吃子或提卒。\n"
"- 制定自己的国际象棋规则！您甚至可以创建自己版本的 [不朽游戏](https://"
"immortal.game/)"

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo community](https://"
"discord.gg/akd2yfuRS3)!"
msgstr ""
"最后，与 [Dojo 社区](https://discord.gg/akd2yfuRS3) 中的其他人分享您的项目！"

#: src/misc/contributors.md:1
msgid "## Contributing to Dojo Book"
msgstr "## 为《Dojo Book》做贡献"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""
"随着 Dojo 引擎的进步和发展，Dojo 书籍需要跟上这些进展的步伐。对本书进行更新和"
"完善，可以确保它对于那些有兴趣了解和使用最新 Dojo 引擎特性和功能的人来说，本"
"书仍然是一个相关和有价值的资源。欢迎大家提供帮助！"

#: src/misc/contributors.md:5
msgid "### The purpose of the book"
msgstr "### 本书的目的"

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""
"Dojo 一书旨在为不同经验水平的用户提供全面的资源。它既可作为 Dojo 及其辅助软件"
"包新手的入门指南，也可作为经验丰富的用户加深对引擎特性和功能的理解的参考资"
"料。"

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "本书分为几个主要章节："

#: src/misc/contributors.md:11
msgid ""
"- Framework Theory\n"
"- Getting Started\n"
"- Building a World"
msgstr ""
"- 框架理论\n"
"- 入门\n"
"- 构建世界"

#: src/misc/contributors.md:15
msgid "### Code of Conduct"
msgstr "### 代码标准"

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of Conduct](https://www.rust-lang.org/"
"policies/code-of-conduct)."
msgstr ""
"本书遵循 [Rust Code of Conduct](https://www.rust-lang.org/policies/code-of-"
"conduct)。"

#: src/misc/contributors.md:19
msgid "### Ways to contribute"
msgstr "### 贡献方式"

#: src/misc/contributors.md:21
msgid "#### Issues"
msgstr "#### Issues"

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""
"如果您认为某些内容缺失或过时，请随时在git上提出issue。如果您发现有多个内容缺"
"失，请为每个内容单独开立一个issue。"

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""
"你提出issue在之后将被贴上相关的标签，以便其他贡献者更容易找到他们感兴趣的任"
"务。"

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""
"Issue应包含哪些地方缺失了，或哪些地方可以改进，只要你认为有必要，都可以详细说"
"明。"

#: src/misc/contributors.md:29
msgid "#### Pull requests"
msgstr "#### Pull requests"

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""
"欢迎随时通过提交PR请求对本书进行修改--从改写一个句子、修正一个错别字到添加新"
"的段落或章节，我们都欢迎。"

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr "当您的PR开放时，其他贡献者会查看并可能要求你进行一些修正。请不要气馁！"

#: src/misc/contributors.md:35
msgid "### Writing style"
msgstr "### 写作风格"

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr "本节记录了一些贯穿全书的写作标准。"

#: src/misc/contributors.md:39
msgid "#### Chapters start with a second level heading"
msgstr "#### 章节从二级标题开始（译者注：请参考markdown语法）"

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "我们使用："

#: src/misc/contributors.md:43
msgid ""
"```md\n"
"## Some Page\n"
"```"
msgstr ""
"```md\n"
"## Some Page\n"
"```"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr ""
"我们不使用（译者注：此为一级大标题语法，只应该作为页面标题存在而不应该作为页"
"面内的内容标题而存在）："

#: src/misc/contributors.md:49
msgid ""
"```md\n"
"# Some Page\n"
"```"
msgstr ""
"```md\n"
"# Some Page\n"
"```"

#~ msgid "Introduction"
#~ msgstr "介绍"

#~ msgid "Installation"
#~ msgstr "安装"

#~ msgid "Dojo Engine"
#~ msgstr "Dojo引擎"

#~ msgid "Cairo ECS"
#~ msgstr "Cairo ECS"

#~ msgid "Storage"
#~ msgstr "存储"

#~ msgid "Appendix"
#~ msgstr "附录"

#~ msgid "sozo Commands"
#~ msgstr "sozo中的命令"

#~ msgid "Project Commands"
#~ msgstr "项目命令"

#~ msgid "World Commands"
#~ msgstr "世界命令"

#~ msgid ""
#~ "Dojo is a provable game engine with an integrated toolchain, designed for "
#~ "creating onchain games and autonomous worlds using [Cairo 1.0](https://"
#~ "github.com/starkware-libs/cairo). It employs an [entity component system]"
#~ "(https://en.wikipedia.org/wiki/Entity_component_system) and a [diamond "
#~ "pattern](https://eips.ethereum.org/EIPS/eip-2535), facilitating a "
#~ "modular, scalable world. Worlds grow via the addition of Components "
#~ "(state) and Systems (logic). Our architectural design is greatly "
#~ "influenced by the brilliant [Bevy](https://bevyengine.org/) engine."
#~ msgstr ""
#~ "Dojo（译者注：dojo为日文“道場”的罗马字）是一个带有集成工具链的可证明游戏引"
#~ "擎，设计用于使用[Cairo 1.0](https://github.com/starkware-libs/cairo)创建链"
#~ "上游戏和自主世界。它采用了[实体组件系统](https://en.wikipedia.org/wiki/"
#~ "Entity_component_system) 和[钻石模式](https://eips.ethereum.org/EIPS/"
#~ "eip-2535)，促进了一个模块化、可扩展的世界。世界通过添加组件（状态）和系统"
#~ "（逻辑）而成长。我们的架构设计深受出色的[Bevy](https://bevyengine.org/)引"
#~ "擎的影响。"

#~ msgid "#### Key Features"
#~ msgstr "#### 主要功能"

#~ msgid ""
#~ "- Entity Component System (ECS) built on [Cairo 1.0](https://github.com/"
#~ "starkware-libs/cairo)\n"
#~ "- [Sozo](./framework/sozo/overview.md) world migration planner\n"
#~ "- [Torii](./framework/torii/overview.md) networking and indexing stack\n"
#~ "- [Katana](./framework/katana/overview.md) RPC development network\n"
#~ "- Typed SDKs"
#~ msgstr ""
#~ "- 基于 [Cairo 1.0](https://github.com/starkware-libs/cairo) 的实体组件系"
#~ "统 (ECS)\n"
#~ "- [Sozo](./framework/sozo/overview.md) 世界迁移规划器\n"
#~ "- [Torii](./framework/torii/overview.md) 网络和索引堆栈\n"
#~ "- [Katana](./framework/katana/overview.md) RPC 开发用网络\n"
#~ "- 类型化 SDK"

#~ msgid "### Why Cairo & Starknet?"
#~ msgstr "### 为什么选择Cairo & Starknet？"

#~ msgid "### Vision"
#~ msgstr "### 愿景"

#~ msgid ""
#~ "Dojo is a bold work in progress, aimed at empowering developers to "
#~ "construct onchain games and Autonomous Worlds (AWs) within hours, not "
#~ "weeks."
#~ msgstr ""
#~ "Dojo 是一项正在进行中的大胆工程，旨在帮助开发人员在数小时而不是数周内构建"
#~ "链上游戏和自主世界（AW）。"

#~ msgid "Open your terminal and run the following command:"
#~ msgstr "打开终端，运行以下命令："

#~ msgid ""
#~ "Running `dojoup` by itself will install the latest (nightly) [precompiled "
#~ "binaries](#precompiled-binaries): `sozo`, `katana`, and `torii`.\n"
#~ "See `dojoup --help` for more options, like installing from a specific "
#~ "version or commit."
#~ msgstr ""
#~ "运行 `dojoup` 本身将安装最新的（nightly版的）[预编译的二进制文件]"
#~ "(#precompiled-binaries)：`sozo`、`katana` 和 `torii`。\n"
#~ "参见 `dojoup --help` 获取更多选项，例如从特定版本或提交来安装。"

#~ msgid "# Dojo Engine - Getting Started Guide"
#~ msgstr "# Dojo 引擎 - 入门指南"

#~ msgid ""
#~ "This README guides you through the process of setting up your local "
#~ "development environment for Dojo."
#~ msgstr "本 README 将指导您为 Dojo 设置本地开发环境。"

#~ msgid "## Prerequisites"
#~ msgstr "## 先决条件"

#~ msgid "## Clone the Repository"
#~ msgstr "## 克隆Repository"

#~ msgid "First, clone the repository to your local machine:"
#~ msgstr "首先，将Repository克隆到本地计算机上："

#~ msgid ""
#~ "For proper linting and syntax highlighting, you should install the Cairo "
#~ "1.0 extension for Visual Studio Code."
#~ msgstr ""
#~ "要获得适当的语法提示和语法高亮，你需要安装 Visual Studio Code 的 Cairo "
#~ "1.0 扩展。"

#~ msgid ""
#~ "- Clone the Cairo repository somewhere on your machine (make sure not to "
#~ "clone within the Dojo directory)."
#~ msgstr "- 在你的电脑上克隆 Cairo 仓库（注意确保不要克隆到 Dojo 目录中）。"

#~ msgid ""
#~ "```bash\n"
#~ "git clone https://github.com/starkware-libs/cairo.git\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "git clone https://github.com/starkware-libs/cairo.git\n"
#~ "```"

#~ msgid ""
#~ "- Install the Cairo Language Server extension. Here's a step-by-step "
#~ "guide, or you can follow the [official instructions](https://github.com/"
#~ "starkware-libs/cairo/blob/main/vscode-cairo/README.md)."
#~ msgstr ""
#~ "- 安装Cairo语言服务器扩展。这里有一个分步指南，你也可以参照 [官方说明]"
#~ "(https://github.com/starkware-libs/cairo/blob/main/vscode-cairo/README.md)"
#~ "进行安装。"

#~ msgid "Navigate to the vscode-cairo directory:"
#~ msgstr "在终端中导航至 vscode-cairo 目录："

#~ msgid "Install the required packages:"
#~ msgstr "安装所需的包："

#~ msgid ""
#~ "```bash\n"
#~ "sudo npm install --global @vscode/vsce\n"
#~ "npm install\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sudo npm install --global @vscode/vsce\n"
#~ "npm install\n"
#~ "```"

#~ msgid "Package the extension:"
#~ msgstr "打包扩展："

#~ msgid "Install the extension:"
#~ msgstr "安装扩展："

#~ msgid ""
#~ "```bash\n"
#~ "code --install-extension cairo1*.vsix\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "code --install-extension cairo1*.vsix\n"
#~ "```"

#~ msgid ""
#~ "> **Mac Tip:** If you don't have the `code` command, in VSCode do "
#~ "`Cmd+Shift+P` and type 'shell command' to find the Shell Command: Install "
#~ "'code' command in PATH command."
#~ msgstr ""
#~ "> **Mac提示：** 如果没有 \"code \"命令，请在 VSCode 中执行 \"Cmd+Shift+P "
#~ "\"并输入 \"shell command \"以查找需要的Shell命令：Install 'code' command "
#~ "in PATH command."

#~ msgid ""
#~ "The Cairo language server should now be installed globally in your Visual "
#~ "Studio Code. If you have the server enabled, Scarb should automatically "
#~ "pick this up and start linting your Cairo files."
#~ msgstr ""
#~ "现在，Visual Studio 代码中应该已全局安装了 Cairo 语言服务器。如果已启用服"
#~ "务器，Scarb 会自动识别并开始对 Cairo 文件进行校验。"

#~ msgid ""
#~ "- [Overview](./framework/cairo/overview.md)\n"
#~ "- [World](./framework/cairo/world.md)\n"
#~ "- [Components](./framework/cairo/components.md)\n"
#~ "- [Systems](./framework/cairo/systems.md)\n"
#~ "- [Entities](./framework/cairo/entities.md)\n"
#~ "- [Commands](./framework/cairo/commands.md)\n"
#~ "- [Storage](./framework/cairo/storage.md)"
#~ msgstr ""
#~ "- [概览](./framework/cairo/overview.md)\n"
#~ "- [世界](./framework/cairo/world.md)\n"
#~ "- [组件](./framework/cairo/components.md)\n"
#~ "- [系统](./framework/cairo/systems.md)\n"
#~ "- [实体](./framework/cairo/entities.md)\n"
#~ "- [命令](./framework/cairo/commands.md)\n"
#~ "- [存储](./framework/cairo/storage.md)"

#~ msgid ""
#~ "Dojo comes with batteries included to power your games. There are 3 core "
#~ "tools which you will use to build your worlds."
#~ msgstr ""
#~ "Dojo 随附好用的工具，为您的游戏赋能。您将使用 3 种核心工具来构建自己的世"
#~ "界。"

#~ msgid ""
#~ "- [Sozo](./framework/sozo/overview.md)\n"
#~ "- [Katana](./framework/katana/overview.md)\n"
#~ "- [Torii](./framework/torii/overview.md)"
#~ msgstr ""
#~ "- [Sozo](./framework/sozo/overview.md)\n"
#~ "- [Katana](./framework/katana/overview.md)\n"
#~ "- [Torii](./framework/torii/overview.md)"

#~ msgid ""
#~ "The Entity Component System (ECS) forms the backbone of the Dojo engine. "
#~ "Here's an overview of its core elements:"
#~ msgstr "实体组件系统（ECS）是 Dojo 引擎的支柱。以下是其核心元素的概述："

#~ msgid ""
#~ "1. **Entities**: Unique objects that can bear multiple components. They "
#~ "are identifiable through unique IDs.\n"
#~ "2. **Components**: Diverse attributes of an entity, such as geometry, "
#~ "physics, and hit points. Components are exclusively responsible for data "
#~ "storage.\n"
#~ "3. **Systems**: Segments of code that manage entities and alter "
#~ "components.\n"
#~ "4. **Queries**: Utilized by systems to select entities based on the "
#~ "associated components.\n"
#~ "5. **World**: A comprehensive container for entities, components, "
#~ "systems, and queries."
#~ msgstr ""
#~ "1. **实体**：可包含多个组件的唯一对象。它们可通过唯一 ID 进行识别。\n"
#~ "2. **组件**：实体的各种属性，如几何、物理和命中点。组件专门负责数据存"
#~ "储。\n"
#~ "3. **系统**：管理实体和更改组件的代码段。\n"
#~ "4. **查询**：系统根据相关组件选择实体。\n"
#~ "5. **世界**：实体、组件、系统和查询的综合容器。"

#~ msgid "### Building an Autonomous World with Dojo"
#~ msgstr "### 利用 Dojo 构建自主世界"

#~ msgid "Follow these steps to effectively create a Dojo world:"
#~ msgstr "按照以下步骤可高效的创建 Dojo 世界："

#~ msgid ""
#~ "1. **Conceptualize Entities**: Visualize the entities that will populate "
#~ "your world.\n"
#~ "2. **Recognize Shared Attributes**: Determine common characteristics of "
#~ "your entities, such as position, name, or health.\n"
#~ "3. **Construct Reusable Components**: Create versatile components derived "
#~ "from these shared attributes.\n"
#~ "4. **Develop Specialized Systems**: Design systems that are adept at "
#~ "performing a specific task."
#~ msgstr ""
#~ "1. **构想实体**：想象你的世界中将出现的实体。\n"
#~ "2. **识别共同属性**：确定实体的共同特征，如位置、名称或健康值。\n"
#~ "3. **构建可重复使用的组件**：根据这些共享属性创建通用组件。\n"
#~ "4. **开发专用系统**：设计擅长执行特定任务的系统。"

#~ msgid ""
#~ "To illustrate, here's an example of a basic design that utilizes "
#~ "components and systems to create four distinct entities:"
#~ msgstr "下面是一个利用组件和系统创建四个不同实体的基本设计示例："

#~ msgid "ECS"
#~ msgstr "ECS"

#~ msgid "### API"
#~ msgstr "### API"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// World interface\n"
#~ "#[abi]\n"
#~ "trait IWorld {\n"
#~ "    fn initialize(routes: Array<Route>);\n"
#~ "    fn component(name: ShortString) -> ClassHash;\n"
#~ "    fn register_component(class_hash: ClassHash);\n"
#~ "    fn system(name: ShortString) -> ClassHash;\n"
#~ "    fn register_system(class_hash: ClassHash);\n"
#~ "    fn uuid() -> usize;\n"
#~ "    fn execute(name: ShortString, execute_calldata: Span<felt252>) -> "
#~ "Span<felt252>;\n"
#~ "    fn entity(component: ShortString, key: Query, offset: u8, length: "
#~ "usize) -> Span<felt252>;\n"
#~ "    fn set_entity(component: ShortString, key: Query, offset: u8, value: "
#~ "Span<felt252>);\n"
#~ "    fn entities(component: ShortString, partition: u250) -> (Span<u250>, "
#~ "Span<Span<felt252>>);\n"
#~ "    fn set_executor(contract_address: ContractAddress);\n"
#~ "    fn is_authorized(system: ClassHash, component: ClassHash) -> bool;\n"
#~ "    fn is_account_admin() -> bool;\n"
#~ "    fn delete_entity(component: ShortString, query: Query);\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// World interface\n"
#~ "#[abi]\n"
#~ "trait IWorld {\n"
#~ "    fn initialize(routes: Array<Route>);\n"
#~ "    fn component(name: ShortString) -> ClassHash;\n"
#~ "    fn register_component(class_hash: ClassHash);\n"
#~ "    fn system(name: ShortString) -> ClassHash;\n"
#~ "    fn register_system(class_hash: ClassHash);\n"
#~ "    fn uuid() -> usize;\n"
#~ "    fn execute(name: ShortString, execute_calldata: Span<felt252>) -> "
#~ "Span<felt252>;\n"
#~ "    fn entity(component: ShortString, key: Query, offset: u8, length: "
#~ "usize) -> Span<felt252>;\n"
#~ "    fn set_entity(component: ShortString, key: Query, offset: u8, value: "
#~ "Span<felt252>);\n"
#~ "    fn entities(component: ShortString, partition: u250) -> (Span<u250>, "
#~ "Span<Span<felt252>>);\n"
#~ "    fn set_executor(contract_address: ContractAddress);\n"
#~ "    fn is_authorized(system: ClassHash, component: ClassHash) -> bool;\n"
#~ "    fn is_account_admin() -> bool;\n"
#~ "    fn delete_entity(component: ShortString, query: Query);\n"
#~ "}\n"
#~ "```"

#~ msgid "__todo__"
#~ msgstr "__todo__"

#~ msgid ""
#~ "Components serve as the foundation for defining the world's structure, "
#~ "encapsulating state for systems to mutate. For instance, a Position "
#~ "component can be implemented as a struct, exposing `is_zero` and "
#~ "`is_equal` methods. Dojo compiles these components into contracts that "
#~ "can be declared and installed within a world, enabling the creation of "
#~ "diverse and customizable environments."
#~ msgstr ""
#~ "组件是定义世界结构的基础，封装了系统可变的状态。例如，一个 \"位置"
#~ "\"（Position）组件可以作为结构体实现，并向外暴露自己的 `is_zero` 和 "
#~ "`is_equal`方法。Dojo 将这些组件编译成合约，可以在世界中声明和安装，从而创"
#~ "建多样化和可定制的环境。"

#~ msgid ""
#~ "Suppose you plan to create two entities that move around the map and are "
#~ "fundamentally different from each other, except for the fact that they "
#~ "both exist within the world. In this case, you could create a shared "
#~ "Position component for both entities. This demonstrates the power of the "
#~ "Entity Component System (ECS) abstraction: by writing a single component, "
#~ "you can reuse it across multiple diverse entities, promoting modularity "
#~ "and flexibility within your world design."
#~ msgstr ""
#~ "假如您计划创建两个在地图上移动的实体，那么除了它们都存在于世界中这一事实"
#~ "外，它们彼此从根本上是完全不同的。在这种情况下，您可以为这两个实体创建一个"
#~ "共享的位置组件。这展示了实体组件系统（ECS）抽象的强大功能：通过编写一个组"
#~ "件，您可以在多个不同的实体中重复使用它，从而提高世界设计的模块性和灵活性。"

#~ msgid ""
#~ "Systems represent functions that operate on the world state. They take "
#~ "input from the user, retrieve the current state from the world, compute a "
#~ "state transition, and apply it. Each system has a single entry point, the "
#~ "execute function. To streamline interaction with the world, systems can "
#~ "utilize\n"
#~ "commands."
#~ msgstr ""
#~ "系统代表对世界状态进行操作的功能。它们接受用户的输入，从世界中检索当前状"
#~ "态，计算状态转换并加以应用。每个系统都有一个入口点，即执行功能。为了简化与"
#~ "世界的交互，系统可以使用命令。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// The most basic system that creates a new player entity with a given "
#~ "name and 100 health.\n"
#~ "\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Health;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin.into(), (Moves { remaining: 10 }, "
#~ "Position { x: 0, y: 0 }, )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// The most basic system that creates a new player entity with a given "
#~ "name and 100 health.\n"
#~ "\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Health;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin.into(), (Moves { remaining: 10 }, "
#~ "Position { x: 0, y: 0 }, )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "Finally, lets move the character with the `MoveSystem`."
#~ msgstr "最后，让我们使用 `MoveSystem` 移动角色。"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Move {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    #[derive(Serde, Drop)]\n"
#~ "    enum Direction {\n"
#~ "        Left: (),\n"
#~ "        Right: (),\n"
#~ "        Up: (),\n"
#~ "        Down: (),\n"
#~ "    }\n"
#~ "\n"
#~ "    impl DirectionIntoFelt252 of Into<Direction, felt252> {\n"
#~ "        fn into(self: Direction) -> felt252 {\n"
#~ "            match self {\n"
#~ "                Direction::Left(()) => 0,\n"
#~ "                Direction::Right(()) => 1,\n"
#~ "                Direction::Up(()) => 2,\n"
#~ "                Direction::Down(()) => 3,\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute(ctx: Context, direction: Direction) {\n"
#~ "        let (position, moves) = get !(ctx.world, ctx.origin.into(), "
#~ "(Position, Moves));\n"
#~ "        let next = next_position(position, direction);\n"
#~ "        set !(\n"
#~ "            ctx.world,\n"
#~ "            ctx.origin.into(),\n"
#~ "            (Moves { remaining: moves.remaining - 1 }, Position { x: next."
#~ "x, y: next.y }, )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn next_position(position: Position, direction: Direction) -> "
#~ "Position {\n"
#~ "        match direction {\n"
#~ "            Direction::Left(()) => {\n"
#~ "                Position { x: position.x - 1, y: position.y }\n"
#~ "            },\n"
#~ "            Direction::Right(()) => {\n"
#~ "                Position { x: position.x + 1, y: position.y }\n"
#~ "            },\n"
#~ "            Direction::Up(()) => {\n"
#~ "                Position { x: position.x, y: position.y - 1 }\n"
#~ "            },\n"
#~ "            Direction::Down(()) => {\n"
#~ "                Position { x: position.x, y: position.y + 1 }\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Move {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    #[derive(Serde, Drop)]\n"
#~ "    enum Direction {\n"
#~ "        Left: (),\n"
#~ "        Right: (),\n"
#~ "        Up: (),\n"
#~ "        Down: (),\n"
#~ "    }\n"
#~ "\n"
#~ "    impl DirectionIntoFelt252 of Into<Direction, felt252> {\n"
#~ "        fn into(self: Direction) -> felt252 {\n"
#~ "            match self {\n"
#~ "                Direction::Left(()) => 0,\n"
#~ "                Direction::Right(()) => 1,\n"
#~ "                Direction::Up(()) => 2,\n"
#~ "                Direction::Down(()) => 3,\n"
#~ "            }\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute(ctx: Context, direction: Direction) {\n"
#~ "        let (position, moves) = get !(ctx.world, ctx.origin.into(), "
#~ "(Position, Moves));\n"
#~ "        let next = next_position(position, direction);\n"
#~ "        set !(\n"
#~ "            ctx.world,\n"
#~ "            ctx.origin.into(),\n"
#~ "            (Moves { remaining: moves.remaining - 1 }, Position { x: next."
#~ "x, y: next.y }, )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "\n"
#~ "    fn next_position(position: Position, direction: Direction) -> "
#~ "Position {\n"
#~ "        match direction {\n"
#~ "            Direction::Left(()) => {\n"
#~ "                Position { x: position.x - 1, y: position.y }\n"
#~ "            },\n"
#~ "            Direction::Right(()) => {\n"
#~ "                Position { x: position.x + 1, y: position.y }\n"
#~ "            },\n"
#~ "            Direction::Up(()) => {\n"
#~ "                Position { x: position.x, y: position.y - 1 }\n"
#~ "            },\n"
#~ "            Direction::Down(()) => {\n"
#~ "                Position { x: position.x, y: position.y + 1 }\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "// Update an existing entity by setting its components with the provided "
#~ "values.\n"
#~ "// This function takes a storage key representing the entity and a "
#~ "generic type T for the components to be updated.\n"
#~ "set!(world: IWorldDispatcher, storage_key: StorageKey, components: T);\n"
#~ "\n"
#~ "// Retrieve the components of a specific type T for an entity identified "
#~ "by the storage key.\n"
#~ "// This function returns the components as an instance of the generic "
#~ "type T.\n"
#~ "get!(world: IWorldDispatcher, storage_key: StorageKey, components: T) -> "
#~ "T;\n"
#~ "\n"
#~ "// Retrieve all entity IDs that have components matching the provided "
#~ "type T.\n"
#~ "// This function returns an array of entity IDs (felt252) containing the "
#~ "specified components.\n"
#~ "find!(world: IWorldDispatcher, key: StorageKey, components: T);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "// Update an existing entity by setting its components with the provided "
#~ "values.\n"
#~ "// This function takes a storage key representing the entity and a "
#~ "generic type T for the components to be updated.\n"
#~ "set!(world: IWorldDispatcher, storage_key: StorageKey, components: T);\n"
#~ "\n"
#~ "// Retrieve the components of a specific type T for an entity identified "
#~ "by the storage key.\n"
#~ "// This function returns the components as an instance of the generic "
#~ "type T.\n"
#~ "get!(world: IWorldDispatcher, storage_key: StorageKey, components: T) -> "
#~ "T;\n"
#~ "\n"
#~ "// Retrieve all entity IDs that have components matching the provided "
#~ "type T.\n"
#~ "// This function returns an array of entity IDs (felt252) containing the "
#~ "specified components.\n"
#~ "find!(world: IWorldDispatcher, key: StorageKey, components: T);\n"
#~ "```"

#~ msgid "# Storage"
#~ msgstr "# 存储"

#~ msgid ""
#~ "In a Dojo Autonomous World, the `World` contract serves as the central "
#~ "store that manages and maintains the overall state. No state is "
#~ "maintained at the component level, this allows a clean split in logic and "
#~ "state. Most developers will not need to touch the storage methods, every "
#~ "part of the world can just be maintained via the [commands](./commands."
#~ "md)."
#~ msgstr ""
#~ "在 Dojo 自主世界中，`World` 合约是管理和维护整体状态的中心存储。组件级不维"
#~ "护任何状态，这样就可以将逻辑和状态完全分开。大多数开发人员无需接触存储方"
#~ "法，只需通过 [命令](./commands.md)维护世界的每个部分即可。"

#~ msgid "## Detailed overview of Storage"
#~ msgstr "## 存储的详细概述"

#~ msgid ""
#~ "State is maintained via a generated partition when you create a "
#~ "component. The compiler calculates the size of the component along with "
#~ "the key you have used and creates a partition within the world. Think of "
#~ "the partition as a table which can be read from and written to."
#~ msgstr ""
#~ "当你创建一个组件时，会通过生成的分区来维护状态。编译器会计算组件的大小和你"
#~ "使用的键，并在世界中创建一个分区。可以把分区想象成一个可以读取和写入的表"
#~ "格。"

#~ msgid ""
#~ "Torii serves as a comprehensive indexing and networking layer for dojo "
#~ "worlds. It systematically organizes the state of dojo worlds, "
#~ "facilitating efficient querying for clients."
#~ msgstr ""
#~ "Torii （译者注：torii是日文“鳥居”的罗马字）是 dojo 世界的综合索引和网络"
#~ "层。它系统地组织了 dojo 世界的状态，为客户端的高效查询提供了便利。"

#~ msgid "__coming soon__"
#~ msgstr "__即将推出__"

#~ msgid "### Graphql"
#~ msgstr "### Graphql"

#~ msgid "### RPC"
#~ msgstr "### RPC"

#~ msgid ""
#~ "-   [sozo Commands](./sozo/)\n"
#~ "-   [katana Reference](./katana/)"
#~ msgstr ""
#~ "-   [sozo中的命令](./sozo/)\n"
#~ "-   [katana参考资料](./katana/)"

#~ msgid ""
#~ "-   [Project Commands](./project-commands.md)\n"
#~ "-   [World Commands](./world-commands.md)"
#~ msgstr ""
#~ "-   [项目命令](./project-commands.md)\n"
#~ "-   [世界命令](./world-commands.md)"

#~ msgid ""
#~ "-   [init]()\n"
#~ "-   [build]()\n"
#~ "-   [test]()\n"
#~ "-   [migrate]()"
#~ msgstr ""
#~ "-   [init]()\n"
#~ "-   [build]()\n"
#~ "-   [test]()\n"
#~ "-   [migrate]()"

#~ msgid ""
#~ "-   [execute]()\n"
#~ "-   [register]()\n"
#~ "-   [system]()\n"
#~ "-   [component]()"
#~ msgstr ""
#~ "-   [execute]()\n"
#~ "-   [register]()\n"
#~ "-   [system]()\n"
#~ "-   [component]()"

#~ msgid "## katana"
#~ msgstr "## katana"

#~ msgid "### SYNOPSIS"
#~ msgstr "### 概要"

#~ msgid ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Allow transaction max fee to be zero"
#~ msgstr ""
#~ "`--allow-zero-max-fee`  \n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; 允许交易最高费用为零"

#~ msgid "1. Set the number of accounts to 15 and allow zero fee transaction"
#~ msgstr "1. 将账户数量设为 15 个，并允许零费用交易"
