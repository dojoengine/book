msgid ""
msgstr ""
"Project-Id-Version: Dojo: The Provable Game Engine\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 3.4\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "Introducción"

#: src/SUMMARY.md:4
msgid "What is Dojo?"
msgstr "¿Qué es Dojo?"

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "Teoría AW"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "Ecosistema de Cairo"

#: src/SUMMARY.md:7
msgid "FAQs"
msgstr "Preguntas Frecuentes"

#: src/SUMMARY.md:9
msgid "Getting Started"
msgstr "Primeros Pasos"

#: src/SUMMARY.md:11
msgid "Quick Start"
msgstr "Inicio Rápido"

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr "Manual de Instalación"

#: src/SUMMARY.md:13
msgid "Development Setup"
msgstr "Configuración de Desarrollo"

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr "Colaboradores"

#: src/SUMMARY.md:16
msgid "Community"
msgstr "Comunidad"

#: src/SUMMARY.md:18
msgid "Get Started"
msgstr "Primeros Pasos"

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr "Arquitectura"

#: src/SUMMARY.md:22 src/SUMMARY.md:45
msgid "Overview"
msgstr "Descripción General"

#: src/SUMMARY.md:23
msgid "World"
msgstr "World"

#: src/SUMMARY.md:24
msgid "Systems"
msgstr "Systems"

#: src/SUMMARY.md:25
msgid "Models"
msgstr "Models"

#: src/SUMMARY.md:26
msgid "Commands"
msgstr "Comandos"

#: src/SUMMARY.md:27
msgid "Config"
msgstr "Configuración"

#: src/SUMMARY.md:28
msgid "Events"
msgstr "Eventos"

#: src/SUMMARY.md:29
msgid "Authorization"
msgstr "Autorización"

#: src/SUMMARY.md:30
msgid "Migration"
msgstr "Migración"

#: src/SUMMARY.md:31
msgid "0.2.0 -> 0.3.0"
msgstr "0.2.0 -> 0.3.0"

#: src/SUMMARY.md:32
msgid "ECS in 15 minutes"
msgstr "ECS en 15 minutos"

#: src/SUMMARY.md:34
msgid "Entities"
msgstr "Entities"

#: src/SUMMARY.md:35
msgid "Testing"
msgstr "Pruebas"

#: src/SUMMARY.md:37
msgid "Modules"
msgstr "Módulos"

#: src/SUMMARY.md:38
msgid "ERC20"
msgstr "ERC20"

#: src/SUMMARY.md:39
msgid "ERC721"
msgstr "ERC721"

#: src/SUMMARY.md:40
msgid "ERC1155"
msgstr "ERC1155"

#: src/SUMMARY.md:41
msgid "DeFi"
msgstr "DeFi"

#: src/SUMMARY.md:43
msgid "Client SDKs"
msgstr "Client SDKs"

#: src/SUMMARY.md:46
msgid "JS"
msgstr "JS"

#: src/SUMMARY.md:47
msgid "Core"
msgstr "Core"

#: src/SUMMARY.md:48
msgid "torii"
msgstr "torii"

#: src/SUMMARY.md:50
msgid "Toolchain"
msgstr "Herramientas"

#: src/SUMMARY.md:52
msgid "Dojoup"
msgstr "Dojoup"

#: src/SUMMARY.md:53
msgid "Sozo"
msgstr "Sozo"

#: src/SUMMARY.md:54 src/SUMMARY.md:66 src/SUMMARY.md:68
msgid "Reference"
msgstr "Referencias"

#: src/SUMMARY.md:55
msgid "init"
msgstr "init"

#: src/SUMMARY.md:56
msgid "build"
msgstr "build"

#: src/SUMMARY.md:57
msgid "test"
msgstr "test"

#: src/SUMMARY.md:58
msgid "migrate"
msgstr "migrate"

#: src/SUMMARY.md:59
msgid "execute"
msgstr "execute"

#: src/SUMMARY.md:60
msgid "register"
msgstr "register"

#: src/SUMMARY.md:61
msgid "system"
msgstr "system"

#: src/SUMMARY.md:62
msgid "component"
msgstr "component"

#: src/SUMMARY.md:63
msgid "events"
msgstr "events"

#: src/SUMMARY.md:64
msgid "auth"
msgstr "auth"

#: src/SUMMARY.md:65
msgid "Katana"
msgstr "Katana"

#: src/SUMMARY.md:67
msgid "Torii"
msgstr "Torii"

#: src/SUMMARY.md:69
msgid "Graphql"
msgstr "Graphql"

#: src/SUMMARY.md:71
msgid "Deploying"
msgstr "Desplegando"

#: src/SUMMARY.md:73
msgid "Locally"
msgstr "Localmente"

#: src/SUMMARY.md:74
msgid "Remote"
msgstr "Remoto"

#: src/SUMMARY.md:76
msgid "Tutorial"
msgstr "Tutorial"

#: src/SUMMARY.md:78
msgid "Onchain Chess"
msgstr "Onchain Chess"

#: src/SUMMARY.md:79
msgid "0. Setup"
msgstr "0. Configuración"

#: src/SUMMARY.md:80
msgid "1. Initiate"
msgstr "1. Iniciar"

#: src/SUMMARY.md:81
msgid "2. Move"
msgstr "2. Mover"

#: src/SUMMARY.md:82
msgid "3. Check Legal Move"
msgstr "3. Comprobar Movimiento Legal"

#: src/SUMMARY.md:83
msgid "4. Test Chess"
msgstr "4. Test Chess"

#: src/SUMMARY.md:87
msgid "Contributors"
msgstr "Colaboradores"

#: src/index.md:1
msgid "Dojo"
msgstr "Dojo"

#: src/index.md:3
msgid ""
"> Dojo is an open-source project, currently in its early development phase, and warmly welcomes "
"contributors. For additional resources, join the community on [Discord](https://discord.gg/vUN4Xq9Qv6) "
"and check out the [contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo es un proyecto de código abierto, actualmente en su fase inicial de desarrollo, y da una calurosa "
"bienvenida a los contribuyentes. Para obtener recursos adicionales, únase a la comunidad en [Discord]"
"(https://discord.gg/vUN4Xq9Qv6) y consulte la [guía de contribución](./misc/contributors.md)."

#: src/index.md:7
msgid "## Dojo: The Provable Game Engine"
msgstr "## Dojo: El Provable Game Engine"

#: src/index.md:9
msgid ""
"Dojo is a provable game engine built using [Cairo](https://github.com/starkware-libs/cairo). It "
"establishes a standard for game development via smart contracts, blending best practices with "
"streamlined development and deployment tools. With Dojo by your side, you can evolve from initial "
"concept to a fully realized game in days, not weeks."
msgstr ""
"Dojo es un provable game engine (motor de juego demostrable) creado con [Cairo](https://github.com/"
"starkware-libs/cairo). Establece un estándar para el desarrollo de juegos a través de smart contract, "
"combinando las mejores prácticas con herramientas de desarrollo e implementación optimizadas. Con Dojo a "
"tu lado, puedes evolucionar desde el concepto inicial hasta un juego completamente realizado en días, no "
"semanas."

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the potential of Provable games. A "
"special section on the [Theory](./theory/autonomous-worlds.md) elucidates this emergent concept of "
"autonomous worlds and Provable games."
msgstr ""
"Este libro está dedicado a familiarizarte con el Dojo engine y el potencial de los Provable games. Una "
"sección especial sobre la [Teoría](./theory/autonomous-worlds.md) elucida este concepto emergente de "
"Autonomous Worlds  y Provable games."

#: src/index.md:13
msgid ""
"- [Quickstart](./getting-started/quick-start.md)\n"
"- [What is Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""
"- [Inicio Rápido](./getting-started/quick-start.md)\n"
"- [¿Qué es Dojo? ](./theory/what-is-dojo.md)\n"
"- [Explorar la Arquitectura](./cairo/hello-dojo.md)"

#: src/index.md:18
msgid "### Explainer"
msgstr "### Explicación"

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://twitter.com/tarrenceva) "
"explaining how Dojo works at the 2023 [Autonomous Anonymous Summit](https://twitter.com/pet3rpan_/"
"status/1666764726427353091):"
msgstr ""
"Aquí tienes un video de [Cartridge](https://cartridge.gg/) donde [Tarrence](https://twitter.com/"
"tarrenceva) explicando cómo funciona Dojo en la [Autonomous Anonymous Summit 2023](https://twitter.com/"
"pet3rpan_/status/1666764726427353091):"

#: src/index.md:22
msgid ""
"<video controls poster=\"https://gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa.arweave.net/kW-"
"uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"
msgstr ""
"<video controls poster=\"https://gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
"MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
"  <source src=\"https://sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa.arweave.net/kW-"
"uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/mp4\">\n"
"  Your browser does not support the video tag.\n"
"</video>"

#: src/index.md:30
msgid "### Organizational Structure"
msgstr "### Estructura Organizativa"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under Apache 2.0, dedicated to promoting and advancing the "
"concept of Autonomous Worlds (AWs). It is spearheaded by [Cartridge](https://cartridge.gg/), [Realms & "
"BibliothecaDAO](https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many more "
"[contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojo es una iniciativa de código abierto, con licencia Apache 2.0, dedicada a promover y hacer avanzar "
"el concepto de Autonomous Worlds  (AWs). Está encabezado por [Cartridge](https://cartridge.gg/), [Realms "
"& BibliothecaDAO](https://bibliothecadao.xyz/), [briq](https://briq.construction/) y muchos más. "
"[colaboradores](https://github.com/orgs/dojoengine/people)."

#: src/index.md:33
msgid "### How do I get involved?"
msgstr "### ¿Cómo puedo involucrarme?"

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://twitter.com/dojostarknet), "
"[Discord](https://discord.gg/vUN4Xq9Qv6) and [contribution guide](https://book.dojoengine.org/misc/"
"contributors.html)"
msgstr ""
"Consulte nuestro [Github](https://github.com/dojoengine), nuestro [Twitter](https://twitter.com/"
"dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) y [guía de contribución](https://book.dojoengine."
"org/misc/contributors.html)."

#: src/theory/what-is-dojo.md:1
msgid "# What is Dojo?"
msgstr "## ¿Qué es Dojo?"

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [onchain games](https://naavik.co/"
"digest/primer-fully-on-chain-gaming), an emerging sector in the gaming industry. Any developer who has "
"endeavored to build an on-chain game recognizes the inherent engineering hurdles - a realization that "
"drove us to create Dojo. Just as you wouldn't recreate Unity every time you develop a new game, the same "
"principle applies here. Dojo is designed to handle the complex infrastructure, allowing developers to "
"focus on the unique aspects of their games."
msgstr ""
"Dojo es la culminación de las lecciones aprendidas en los intentos de crear [juegos on-chain](https://"
"naavik.co/digest/primer-fully-on-chain-gaming), un sector emergente en la industria del juego. Cualquier "
"desarrollador que haya intentado crear un juego on-chain reconoce los obstáculos inherentes a la "
"ingeniería, algo que nos impulsó a crear Dojo. Del mismo modo que no recrearías Unity cada vez que "
"desarrollas un nuevo juego, aquí se aplica el mismo principio. Dojo está diseñado para manejar la "
"compleja infraestructura, permitiendo a los desarrolladores centrarse en los aspectos únicos de sus "
"juegos."

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is radically open-source, and all "
"contributions are welcome."
msgstr ""
"Dojo aspira a convertirse en la herramienta de referencia para crear Provable games. Es radicalmente de "
"código abierto, y todas las contribuciones son bienvenidas."

#: src/theory/what-is-dojo.md:9
msgid "## Stop building infrastructure; start building games"
msgstr "## Deja de construir infraestructuras; empieza a construir juegos"

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-chain games. It includes:"
msgstr ""
"El conjunto de herramientas de Dojo elimina la complejidad de la infraestructura para crear juegos en la "
"cadena. Incluye:"

#: src/theory/what-is-dojo.md:13
msgid "### Entity Component System (ECS)"
msgstr "### Entity Component System (ECS)"

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. Recognizing the intricacies of "
"game design, Dojo simplifies the development process, allowing creators to focus on gameplay logic. This "
"standardization paves the way for an interconnected network of worlds, streamlining developer expertise "
"and promoting game integration."
msgstr ""
"Dojo ofrece un enfoque estandarizado para crear juegos con smart contracs. Al reconocer las "
"complejidades del diseño de juegos, Dojo simplifica el proceso de desarrollo, permitiendo a los "
"creadores centrarse en la lógica del juego. Esta estandarización allana el camino para una red "
"interconectada de Worlds, optimizando la experiencia de los desarrolladores y promoviendo la integración "
"de juegos."

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo effectively manages the state "
"and behavior of Autonomous Worlds (AWs). This model revolves around systems acting on entities, which "
"are collections of pure data components. Systems efficiently determine which entities to process based "
"on persistent queries over these components."
msgstr ""
"Utilizando el ECS (Entity Component System) como arquitectura central, Dojo gestiona eficazmente el "
"estado y el comportamiento de los Autonomous Worlds  (AWs). Este Model gira en torno a Systems que "
"actúan sobre entidades, que son colecciones de componentes de datos puros. Los Systems determinan "
"eficientemente qué entidades procesar basándose en consultas persistentes sobre estos componentes."

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr "Lea información detallada sobre el [Dojo ECS](../cairo/overview.md)."

#: src/theory/what-is-dojo.md:21
msgid "### [Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr "### [Torii](/crates/torii/README.md) - Indexador Starknet"

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of indexing on-chain state. However, "
"Dojo standardizes contract states to mirror traditional relational databases. This setup enables the "
"[Torii Indexer](../toolchain/torii/overview.md) to auto-index all contract states, ensuring efficient "
"and streamlined queries. Torii then exposes these states via a GraphQL API or gRPC (coming soon), "
"allowing developers to easily query and retrieve data."
msgstr ""
"Construir juegos on-chain a menudo implica enfrentarse al reto de indexar el estado on-chain. "
"Sin embargo, Dojo estandariza los estados de los contratos para reflejar las bases de datos relacionales "
"tradicionales. Esta configuración permite al [Torii Indexer](../toolchain/torii/overview.md) indexar "
"automáticamente todos los estados del contrato, garantizando consultas eficientes y racionalizadas. "
"Torii luego expone estos estados a través de una API GraphQL o gRPC (próximamente), permitiendo a los "
"desarrolladores consultar y recuperar datos fácilmente."

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-chain games. It also eliminates "
"the need to manually create indexers, which can be a tedious and error-prone process."
msgstr ""
"El uso de Torii reduce drásticamente el tiempo y el esfuerzo necesarios para crear juegos on-chain. "
"También elimina la necesidad de crear manualmente indexadores, que puede ser un proceso tedioso y "
"propenso a errores."

#: src/theory/what-is-dojo.md:27
msgid "### [Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr "### [Katana](/crates/katana/README.md) - Red de desarrollo rapidísima"

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast and allows you to iterate on "
"your game logic swiftly."
msgstr ""
"Katana es una red de desarrollo Starknet personalizable. Es rapidísima y te permite iterar sobre la "
"lógica de tu juego con rapidez."

#: src/theory/what-is-dojo.md:31
msgid "### [Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr "### [Sozo CLI](/crates/sozo/README.md) - Herramienta de Gestión CLI"

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a CLI tool that assists you in "
"managing your worlds. It enables you to create, build, test, and deploy your worlds. Additionally, you "
"can craft new components and systems and register them with your world."
msgstr ""
"Los Worlds Dojo están a punto de convertirse en algunos de los mayores contratos. Sozo es una "
"herramienta CLI que te ayuda a gestionar tus Worlds. Te permite crear, construir, probar y desplegar tus "
"Worlds. Además, puedes crear nuevos componentes y Systems y registrarlos en tu World."

#: src/theory/what-is-dojo.md:35
msgid "### What Dojo doesn't give you"
msgstr "### Que no te ofrece Dojo"

#: src/theory/what-is-dojo.md:37
msgid ""
"1. Visual graphics - While Dojo provides networking and contracts, it doesn't offer graphical engines. "
"You can bring your graphics of choice! Integrate your Dojo world with Unreal, Godot, or Unity."
msgstr ""
"1. Gráficos visuales - Aunque Dojo proporciona redes y contratos, no ofrece motores gráficos. ¡Puedes "
"traer los gráficos de tu elección! Integra tu World Dojo con Unreal, Godot o Unity."

#: src/theory/what-is-dojo.md:39
msgid "## Understanding the Dojo Workflow: A Visual Guide"
msgstr "## Entendiendo el Workflow de Dojo: Una Guía Visual"

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that outlines the flow of "
"execution using the powerful sozo tool and the katana development network."
msgstr ""
"Para ayudarle a entender cómo funciona `Sozo`, hemos creado una guía visual que describe el flujo de "
"ejecución utilizando la potente herramienta sozo y la red de desarrollo katana."

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of working with Dojo, guiding you "
"through the process of creating and managing your on-chain games."
msgstr ""
"Esta representación visual le ayudará a comprender los pasos fundamentales del trabajo con Dojo, "
"guiándole a través del proceso de creación y gestión de sus juegos on-chain."

#: src/theory/what-is-dojo.md:45
msgid "Dojo Sozo Workflow"
msgstr "Dojo Sozo Workflow"

#: src/theory/autonomous-worlds.md:1
msgid "## Autonomous Worlds"
msgstr "## Autonomous Worlds"

#: src/theory/autonomous-worlds.md:3
msgid ""
"> \"Autonomous worlds represent persistent, permissionless, and decentralized open environments that "
"users can freely interact with and contribute to.\""
msgstr ""
"> \"Los Autonomous Worlds  representan entornos abiertos persistentes, sin permisos y descentralizados "
"con los que los usuarios pueden interactuar y contribuir libremente\"."

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, as it is more of an abstract "
"concept that has yet to be fully crystallized. Lattice first [introduced](https://0xparc.org/blog/"
"autonomous-worlds) the terminology in 2022, but the notion of open worlds operating on the blockchain "
"has been around for a while. The abstraction introduced by MUD served as a catalyst for the market to "
"recognize the potential of these worlds."
msgstr ""
"La definición precisa de Autonomous Worlds (AWs) sigue siendo algo difícil de alcanzar, ya que es más "
"bien un concepto abstracto que aún no se ha cristalizado por completo. Lattice [introdujo]"
"(https://0xparc.org/blog/autonomous-worlds) la terminología por primera vez en 2022, pero la noción de "
"Worlds abiertos operando en blockchain existe desde hace un tiempo. La abstracción introducida por la "
"MUD sirvió de catalizador para que el mercado reconociera el potencial de estos Worlds."

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their fundamental nature. Once "
"established, they persist, maintaining their state throughout the lifespan of the chain. Players can "
"join or leave, and developers can expand these worlds by deploying features in a permissionless manner, "
"much like how contracts are added to a chain. While there is no universally accepted definition for an "
"Autonomous World, we believe that a game must possess at least the following two essential features to "
"be considered as such:"
msgstr ""
"Los Autonomous Worlds  comparten similitudes destacadas con las cadenas de bloques en su naturaleza "
"fundamental. Una vez establecidos, persisten y mantienen su estado a lo largo de la vida útil de la "
"cadena. Los jugadores pueden unirse o salir, y los desarrolladores pueden ampliar estos Worlds "
"desplegando características de manera sin permisos, de manera similar a cómo se añaden contratos a una "
"cadena. Aunque no existe una definición universalmente aceptada para un Autonomous Worlds, creemos que "
"un juego debe poseer al menos las siguientes dos características esenciales para ser considerado como "
"tal:"

#: src/theory/autonomous-worlds.md:9
msgid ""
"1. Decentralized data availability layer: While the state execution may reside on a centralized layer, "
"it is crucial that the state can be reconstructed if the execution layer ceases to exist. Rollups offer "
"a solution, providing increased capacity execution layers while ensuring data is permanently settled on "
"Ethereum. This guarantees the world's perpetual persistence.\n"
"\n"
"2. Permissionless entry point for expanding the world: The World contract must be capable of accepting "
"new systems and components without requiring permission. While this doesn't imply that every component "
"and system will be utilized, they must adhere to this pattern, ensuring open and unrestricted access for "
"potential enhancements."
msgstr ""
"1. Capa de disponibilidad de datos descentralizada: Si bien la ejecución del estado puede residir en una "
"capa centralizada, es crucial que el estado pueda reconstruirse si la capa de ejecución deja de existir. "
"Los rollups ofrecen una solución que proporciona capas de ejecución de mayor capacidad y al mismo tiempo "
"garantiza que los datos se establezcan permanentemente en Ethereum. Esto garantiza la persistencia "
"perpetua del World.\n"
"\n"
"2. Punto de entrada permissionless para expandir el World: El contrato del World debe ser capaz de "
"aceptar nuevos Systems y componentes sin necesidad de permiso. Si bien esto no implica que se utilizarán "
"todos los componentes y Systems, deben cumplir con este patrón, garantizando un acceso abierto y sin "
"restricciones para posibles mejoras."

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalyze the exploration of novel forms "
"in the medium provided by zk proofs and blockchain technology. This is not only about games, but also "
"about new forms of artwork, coordination, fun, emerging from tinkering and radical innovation, "
"eventually questioning the very notion of \"play\" in this brave new decentralized and trustless world."
msgstr ""
"Creemos firmemente en el potencial de los Autonomous Worlds  para catalizar la exploración de formas "
"novedosas en el medio proporcionado por las pruebas zk y la tecnología blockchain. No se trata sólo de "
"juegos, sino también de nuevas formas de arte, coordinación y diversión que surgen de la innovación "
"radical y los retoques, y que eventualmente cuestionan la noción misma de \"jugar\" en este nuevo y "
"valiente World descentralizado y sin confianza."

#: src/theory/autonomous-worlds.md:15
msgid "### Homework"
msgstr "### Tarea"

#: src/theory/autonomous-worlds.md:16
msgid ""
"- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-worlds-aim-to-free-online-"
"games-from-corporate-control/)\n"
"- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-worlds)\n"
"- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack.com/p/the-strongest-crypto-"
"gaming-thesis)\n"
"- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/mud-an-engine-for-autonomous-"
"worlds)\n"
"- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/composable-engineering)\n"
"- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-worlds/)\n"
"- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-chain-realities-and-"
"autonomous-worlds)"
msgstr ""
"- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-worlds-aim-to-free-online-"
"games-from-corporate-control/)\n"
"- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-worlds)\n"
"- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack.com/p/the-strongest-crypto-"
"gaming-thesis)\n"
"- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/mud-an-engine-for-autonomous-"
"worlds)\n"
"- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
"- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/composable-engineering)\n"
"- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-worlds/)\n"
"- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-chain-realities-and-"
"autonomous-worlds)"

#: src/theory/cairo.md:1
msgid "# Provable games"
msgstr "# Juegos probables"

#: src/theory/cairo.md:3
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-knowledge-proofs/) properties for "
"efficient scaling and verification of computations. [Cairo](https://book.starknet.io/chapter_1/"
"what_is_cairo.html) addresses this need by providing a generalized language, eliminating the complexity "
"of creating circuits to incorporate [SNARKs](https://consensys.net/blog/developers/introduction-to-zk-"
"snarks/). "
msgstr ""
"Los Provable games requieren propiedades de [zero-knowledge](https://ethereum.org/en/zero-knowledge-"
"proofs/)(ZK) para una escalabilidad eficiente y verificación de cálculos. [Cairo](https://book.starknet."
"io/chapter_1/what_is_cairo.html) aborda esta necesidad proporcionando un lenguaje generalizado, "
"eliminando la complejidad de crear circuitos para incorporar [SNARKs](https://consensys.net/blog/"
"developers/introduction-to-zk-snarks/). "

#: src/theory/cairo.md:5
msgid "**You can simply program in Cairo and your applications become automatically provable**. "
msgstr ""
"**Puedes simplemente programar en Cairo y tus aplicaciones se vuelven automáticamente demostrables**. "

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine](https://medium.com/starkware/cairo-"
"welcome-on-board-1cf3487554f) (CVM), which is compatible with Starknet's Layer 2, Starknet appchains, "
"and even in-browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK primitives to "
"fuel your game development."
msgstr ""
"Además, puede implementar sus programas en la [Máquina Virtual de Cairo](https://medium.com/starkware/"
"cairo-welcome-on-board-1cf3487554f) (CVM), que es compatible con la Capa 2 de Starknet, las cadenas de "
"aplicaciones de Starknet, ¡E incluso en el navegador a través de WebAssembly (WASM)! Dojo tiene como "
"objetivo proporcionar primitivas ZK sencillas para impulsar el desarrollo de su juego."

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the [Starknet & Cairo book]"
"(https://book.starknet.io/)."
msgstr ""
"Para obtener más información sobre Starknet, Cairo y su stack tecnológico, visita el [libro de Starknet "
"y Cairo](https://book.starknet.io/)."

#: src/theory/cairo.md:11
msgid "## Cairo"
msgstr "## Cairo"

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed by Starkware, designed to "
"power the Validity Rollup Starknet. The language enables highly expressive and verifiable computation, "
"making it well-suited for building scalable and secure applications, including decentralized finance "
"(DeFi) projects."
msgstr ""
"Cairo es un lenguaje de smart contract de código abierto y Turing completo, desarrollado por Starkware, "
"diseñado para impulsar el Validity Rollup Starknet. El lenguaje permite una computación altamente "
"expresiva y verificable, lo que lo hace adecuado para construir aplicaciones escalables y seguras, "
"incluidos proyectos de finanzas descentralizadas (DeFi)"

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous Worlds (AWs). By leveraging "
"the capabilities of Cairo, Dojo aims to streamline the development process, improve maintainability, and "
"enhance the performance of AWs."
msgstr ""
"Dojo se basa en Cairo al crear un framework para desarrollar Autonomous Worlds  (AWs). Al aprovechar las "
"capacidades de Cairo, Dojo tiene como objetivo agilizar el proceso de desarrollo, mejorar la "
"mantenibilidad y mejorar el rendimiento de AWs."

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/commands.md). Commands are a "
"design pattern that helps to reduce boilerplate code, resulting in cleaner and more maintainable "
"applications. They achieve this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Una característica clave del framework Dojo es el uso de [comandos](../cairo/commands.md). Los comandos "
"son un patrón de diseño que ayuda a reducir el código repetitivo, dando lugar a aplicaciones más limpias "
"y fáciles de mantener. Esto se consigue encapsulando acciones u operaciones específicas en unidades "
"autocontenidas y reutilizables."

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler takes care of inlining the "
"appropriate functions. "
msgstr ""
"Los desarrolladores pueden escribir comandos libremente dentro de los Systems, y el compilador de Cairo "
"se encarga de enlazar las funciones apropiadas. "

#: src/theory/cairo.md:21
msgid "#### Essential Reading"
msgstr "#### Lectura Esencial"

#: src/theory/cairo.md:22
msgid ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"
msgstr ""
"- [Cairo book](https://cairo-book.github.io/)\n"
"- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
"- [Starknet Book](https://book.starknet.io/)"

#: src/theory/cairo.md:26
msgid "### Starknet as an L2"
msgstr "### Starknet como una L2"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale Ethereum. It operates by offering "
"high transaction throughput and low gas costs while maintaining the same level of security as Ethereum "
"Layer 1 (L1). The strategy it uses is akin to solving a sudoku puzzle: verifying a solution is easier "
"than finding the solution from scratch. Similarly, Starknet replaces heavy and costly L1 computation "
"with cheaper L1 verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknet es una solución de Capa 2 (L2) de Validity Rollup diseñada para escalar Ethereum. Opera "
"ofreciendo una alta capacidad de transacciones y bajos costos de gas, manteniendo el mismo nivel de "
"seguridad que Ethereum Capa 1 (L1). La estrategia que utiliza es similar a resolver un rompecabezas "
"Sudoku: verificar una solución es más fácil que encontrar la solución desde cero. De manera similar, "
"Starknet reemplaza la computación pesada y costosa en L1 con una verificación más económica en L1 "
"mediante el uso de pruebas STARK calculadas fuera de la cadena."

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also known as a \"ZK-Rollup\") "
"that supports general computation and currently runs as an L2 network over Ethereum. The network's L1 "
"security is guaranteed by its utilization of the STARK cryptographic proof system, which is considered "
"one of the safest and most scalable."
msgstr ""
"En términos más técnicos, Starknet es un Validity Rollup sin permisos (también conocido como \"ZK-Rollup"
"\") que admite computación general y actualmente funciona como una red L2 sobre Ethereum. La seguridad "
"de la red L1 está garantizada por su utilización del sistema de prueba criptográfica STARK, que se "
"considera uno de los más seguros y escalables."

#: src/theory/cairo.md:32
msgid "### Starknet as an Appchain"
msgstr "### Starknet como una Appchain"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-Knowledge (ZK) proofs. It's the "
"driving force behind Starknet, Starkex, and appchains. Remarkably, you can also run it in WebAssembly "
"(WASM) to generate proofs on the client-side! The Dojo team is working closely with the [Madara](https://"
"github.com/keep-starknet-strange/madara) team to enable Starknet appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairo es un lenguaje isomórfico de propósito general, optimizado para pruebas de conocimiento cero (ZK). "
"Es la fuerza impulsora detrás de Starknet, Starkex y las appchains. Sorprendentemente, también se puede "
"ejecutar en WebAssembly (WASM) para generar pruebas en el lado del cliente! El equipo de Dojo está "
"trabajando en estrecha colaboración con el equipo de [Madara](https://github.com/keep-starknet-strange/"
"madara) para permitir que las appchains de Starknet ejecuten sin problemas los Worlds de Dojo."

#: src/theory/faqs.md:1
msgid "# FAQs"
msgstr "# Preguntas Frecuentes"

#: src/theory/faqs.md:3
msgid "#### Who owns Dojo?"
msgstr "#### ¿Quién es el propietario de Dojo?"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use Dojo for free, and anyone "
"can contribute to the project."
msgstr ""
"Dojo es estrictamente open-source y utiliza la licencia Apache 2.0. Cualquiera puede utilizar Dojo de "
"forma gratuita, y cualquiera puede contribuir al proyecto."

#: src/theory/faqs.md:7
msgid "#### Why Dojo?"
msgstr "### ¿Por qué Dojo?"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain games. It standardizes the "
"process of building such games and provides a suite of tools to make it easier."
msgstr ""
"Dojo se creó para resolver los problemas a los que se enfrentaban sus fundadores a la hora de crear "
"juegos on-chain. Estandariza el proceso de creación de este tipo de juegos y ofrece un conjunto de "
"herramientas para facilitarlo."

#: src/theory/faqs.md:11
msgid "#### What is the Dojo roadmap?"
msgstr "#### ¿Cuál es el roadmap de Dojo?"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github](https://github.com/dojoengine/"
"dojo/issues) and join the [Discord](https://discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas "
"for the project, please open an issue."
msgstr ""
"Dojo evoluciona rápidamente. Puedes encontrar temas abiertos en [Dojo Github](https://github.com/"
"dojoengine/dojo/issues) y unirte a [Discord](https://discord.gg/vUN4Xq9Qv6) para participar. Si tienes "
"ideas para el proyecto, abre una incidencia."

#: src/theory/faqs.md:15
msgid "#### What is an onchain game?"
msgstr "#### ¿Qué es un juego onchain?"

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; all states and logic are "
"onchain. Clients (like web browsers) do not exist on the chain but exist purely to interact with and "
"interpret the onchain state."
msgstr ""
"Los juegos onchain son juegos que existen enteramente en una red pública blockchain; todos los estados y "
"la lógica son onchain. Los clientes (como los navegadores web) no existen on-chain, sino únicamente "
"para interactuar con el estado onchain e interpretarlo."

#: src/theory/faqs.md:19
msgid "#### What is an autonomous world?"
msgstr "#### ¿Qué es un Autonomous Worlds?"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled by any single entity but is "
"instead governed by the rules set within that world. Dive deeper into the topic here: [Autonomous Worlds]"
"(../theory/autonomous-worlds.md)."
msgstr ""
"Un Autonomous Worlds es aquel que existe completamente on chain. No está controlado por ninguna entidad "
"única, sino que se rige por las reglas establecidas dentro de ese World. Profundice en el tema aquí: "
"[Autonomous Worlds](../theory/autonomous-worlds.md)."

#: src/theory/faqs.md:23
msgid "#### What is Cairo?"
msgstr "#### ¿Qué es Cairo?"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a Turing-complete language meant "
"for general-purpose computation. It's a low-level language designed to compile to the Cairo Virtual "
"Machine. Learn more about it here: [Cairo](../theory/cairo.md)."
msgstr ""
"Cairo es un lenguaje de programación de código abierto inventado por Starkware. Es un lenguaje Turing-"
"completo pensado para computación de propósito general. Es un lenguaje de bajo nivel diseñado para "
"compilar en la máquina virtual Cairo. Más información aquí: [Cairo](../theory/cairo.md)."

#: src/theory/faqs.md:27
msgid "#### What is a provable game?"
msgstr "#### ¿Qué es un provable game?"

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair by verifying a zk proof "
"created off-chain. But what does that entail? Consider a game of chess. We aim for an experience where "
"players trust each other's moves. In a straightforward approach — and given the simple rules of chess — "
"if this were in a blockchain environment, every move would be a transaction on the blockchain. This is "
"costly. We just want to know the winner, not every move."
msgstr ""
"Gracias a la magia de las zero-knowledge proofs, podemos asegurarnos de que un juego es justo "
"verificando una prueba zk creada fuera de la cadena. Pero, ¿qué implica eso? Pensemos en una partida de "
"ajedrez. Nuestro objetivo es que los jugadores confíen en las jugadas de los demás. En un enfoque "
"directo — y dadas las sencillas reglas del ajedrez — si esto fuera en un entorno de cadena de bloques, "
"cada jugada sería una transacción bloques on-chain. Esto es costoso. Sólo queremos saber quién es "
"el ganador, no cada jugada."

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state channel, sharing moves off-chain "
"and ensuring their validity. At the end, a zk proof can be submitted to the blockchain to confirm the "
"game's fairness. This constitutes a provable game."
msgstr ""
"Con las pruebas zk y las comunicaciones cliente, los jugadores pueden establecer un canal de estado, "
"compartiendo movimientos fuera de la cadena y garantizando su validez. Al final, se puede enviar una "
"prueba zk a la cadena de bloques para confirmar la equidad del juego. Esto constituye un provable game."

#: src/getting-started/quick-start.md:1
msgid "## Quick Start"
msgstr "## Inicio Rápido"

#: src/getting-started/quick-start.md:3
msgid ""
"> It is worth reading [theory](../theory/autonomous-worlds.md) to familiarize yourself with the concept "
"of Autonomous Worlds (AWs) and the [Cairo ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""
"> Merece la pena leer [teoría](../theory/autonomous-worlds.md) para familiarizarse con el concepto de "
"Autonomous Worlds (AWs) y el [ecosistema de Cairo](../theory/cairo.md) antes de sumergirse en el código."

#: src/getting-started/quick-start.md:6
msgid "### Install Dojoup"
msgstr "### Instalando Dojoup"

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. Install them all easily with "
"Dojoup. You can find detailed information about Dojoup [here](https://github.com/dojoengine/dojo/blob/"
"master/dojoup/README.md)."
msgstr ""
"Dojo está construido alrededor de un conjunto de herramientas de desarrollo - Katana, Torii y Sozo. "
"Instálalas todas fácilmente con Dojoup. Puedes encontrar información detallada sobre Dojoup [aquí]"
"(https://github.com/dojoengine/dojo/blob/master/dojoup/README.md)."

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"

#: src/getting-started/quick-start.md:14
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen,\n"
"which will make the `dojoup` command available in your CLI."
msgstr ""
"Esto instalará Dojoup, luego simplemente sigue las instrucciones que aparecen en pantalla,\n"
"lo que hará que el comando `dojoup` esté disponible en tu línea de comandos (CLI)."

#: src/getting-started/quick-start.md:17 src/toolchain/dojoup.md:15
msgid ""
"```sh\n"
"dojoup\n"
"```"
msgstr ""
"```sh\n"
"dojoup\n"
"```"

#: src/getting-started/quick-start.md:21
msgid "For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup.md)."
msgstr "Para una referencia completa y depuración de `dojoup` ver [Dojoup](../toolchain/dojoup.md)."

#: src/getting-started/quick-start.md:23
msgid "### Next steps"
msgstr "### Próximos Pasos"

#: src/getting-started/quick-start.md:25
msgid "> Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo world."
msgstr "> Dirígete a [Hello Dojo](../cairo/hello-dojo.md) para crear tu primer World Dojo."

#: src/getting-started/from-source.md:1
msgid "## Building from source"
msgstr "## Construyendo desde el origen"

#: src/getting-started/from-source.md:3
msgid ""
"> If you are just wanting to play with the toolchain, we strongly suggest following the [Quick Start](./"
"quick-start.md) guide."
msgstr ""
"> Si sólo quieres jugar con la cadena de herramientas, te recomendamos encarecidamente que sigas la guía "
"[Quick Start](./quick-start.md)."

#: src/getting-started/from-source.md:5
msgid "#### Prerequisites"
msgstr "#### Requisitos Previos"

#: src/getting-started/from-source.md:7
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust package manager.\n"
"The easiest way to install both is with [`rustup.rs`](https://rustup.rs/)."
msgstr ""
"Necesitarás el compilador de [Rust](https://rust-lang.org) y Cargo, el gestor de paquetes de Rust.\n"
"La forma más sencilla de instalar ambos es utilizando [`rustup.rs`](https://rustup.rs/)."

#: src/getting-started/from-source.md:10
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://visualstudio.microsoft.com/"
"downloads/),\n"
"installed with the \"Desktop Development With C++\" Workloads option."
msgstr ""
"En Windows, también necesitarás una versión reciente de [Visual Studio](https://visualstudio.microsoft."
"com/downloads/),\n"
"instalada con la opción \"Desarrollo de escritorio con C++\" en las cargas de trabajo."

#: src/getting-started/from-source.md:13
msgid "#### Building"
msgstr "#### Construyendo"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "Puedes utilizar las diferentes opciones de [Dojoup](#using-dojoup):"

#: src/getting-started/from-source.md:17
msgid ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch master\n"
"dojoup --path path/to/dojo\n"
"```"

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "O bien, utilizando un solo comando de Cargo:"

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana torii\n"
"```"
msgstr ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana torii\n"
"```"

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://github.com/dojoengine/dojo):"
msgstr ""
"O bien, construyendo manualmente desde una copia local del [repositorio de Dojo](https://github.com/"
"dojoengine/dojo):"

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"

#: src/getting-started/setup.md:1
msgid "# Development Setup"
msgstr "# Configuración de Desarrollo"

#: src/getting-started/setup.md:3
msgid ""
"> This article is a guide to setting up a development environment for Dojo. It is not suggested to "
"follow this guide if you are just wanting to play with the toolchain. We strongly suggest following the "
"[Quick Start](../getting-started/quick-start.md) guide."
msgstr ""
"> Este artículo es una guía para configurar un entorno de desarrollo para Dojo. No se sugiere seguir "
"esta guía si sólo quieres jugar con la cadena de herramientas. Sugerimos encarecidamente seguir la guía "
"[Quick Start](../getting-started/quick-start.md)."

#: src/getting-started/setup.md:5
msgid "### Prerequisites"
msgstr "#### Requisitos Previos"

#: src/getting-started/setup.md:7
msgid ""
"- Rust\n"
"- Cairo"
msgstr ""
"- Rust\n"
"- Cairo"

#: src/getting-started/setup.md:12
msgid "## Guide"
msgstr "## Guía"

#: src/getting-started/setup.md:14
msgid "### Clone"
msgstr "### Clonar"

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"

#: src/getting-started/setup.md:20
msgid "### Linux & Mac"
msgstr "### Linux & Mac"

#: src/getting-started/setup.md:22
msgid "#### 1. Install Rust and Dependencies"
msgstr "#### 1. Instalar Rust y Dependencias"

#: src/getting-started/setup.md:24
msgid "Start by installing Rust and running the test suite to confirm your setup:"
msgstr "Comienza instalando Rust y ejecutando el conjunto de pruebas para confirmar la configuración:"

#: src/getting-started/setup.md:26
msgid ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"
msgstr ""
"```sh\n"
"rustup override set stable && rustup update && cargo test\n"
"```"

#: src/getting-started/setup.md:30
msgid ""
"> Note: Depending on your Linux distribution, you may need to install additional dependencies. Make sure "
"to install any suggested or missing dependencies that arise during the setup process."
msgstr ""
"> Nota: Dependiendo de la distribución de Linux que estés usando, es posible que necesites instalar "
"dependencias adicionales. Asegúrate de instalar todas las dependencias sugeridas o faltantes que surjan "
"durante el proceso de configuración."

#: src/getting-started/setup.md:32
msgid "#### 2. Install Scarb Package Manager"
msgstr "#### 2. Instalar el Administrador de Paquetes Scarb"

#: src/getting-started/setup.md:34
msgid "Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager by running:"
msgstr ""
"Luego, instala el gestor de paquetes [Scarb](https://docs.swmansion.com/scarb) ejecutando el siguiente "
"comando:"

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"
msgstr ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"

#: src/getting-started/setup.md:40
msgid "#### 3. Add the Cairo 1.0 VSCode Extension"
msgstr "#### 3. Configura la extensión de Cairo para VSCode"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1) extension "
"for Visual Studio Code."
msgstr ""
"Instale la extensión [Cairo 1.0](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1) "
"para Visual Studio Code."

#: src/getting-started/setup.md:45
msgid "### Windows"
msgstr "### Windows"

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "_Próximamente_"

#: src/getting-started/setup.md:49
msgid "### Container"
msgstr "### Contenedor"

#: src/getting-started/contributing.md:1
msgid "# Contributing to the Core"
msgstr "# Contribuyendo al Core"

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, and warmly welcomes "
"contributors."
msgstr ""
"Dojo es un proyecto de open-source, actualmente en su fase inicial de desarrollo, y da una calurosa "
"bienvenida a los colaboradores."

#: src/getting-started/contributing.md:5
msgid "## How to Contribute"
msgstr "### Formas de Contribuir"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open issues, if you see an issue "
"that is unassigned, please request in the comments to be assigned to it. If you have an idea for a new "
"feature, please create an issue with the `enhancement` tag."
msgstr ""
"Dirígete a [Github](https://github.com/dojoengine/dojo/issues) para ver las incidencias abiertas, si ves "
"una incidencia que no está asignada, por favor solicita en los comentarios que te la asignen. Si tienes "
"una idea para una nueva funcionalidad, crea una incidencia con la etiqueta `enhancement`."

#: src/community/get-started.md:1
msgid "## Get Started"
msgstr "## Primeros Pasos"

#: src/community/get-started.md:3
msgid ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr ""
"-   [Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [Discord](https://discord.gg/KG9w9BmDrV)\n"
"-   [Twitter](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"

#: src/cairo/overview.md:1
msgid ""
"> You should have a good understanding of Cairo before proceeding. If you're unfamiliar with Cairo, we "
"recommend you read the [Cairo documentation](https://book.cairo-lang.org/title-page.html) first."
msgstr ""
"> Debe tener un buen conocimiento de Cairo antes de continuar. Si no está familiarizado con El Cairo, le "
"recomendamos que lea primero la [documentación de El Cairo] (https://book.cairo-lang.org/title-page."
"html)."

#: src/cairo/overview.md:3
msgid "## A New Approach to Game Development"
msgstr "## Un Nuevo Enfoque Para el Desarrollo de Juegos"

#: src/cairo/overview.md:5
msgid ""
"Dojo provides an advanced abstraction layer over Cairo, mirroring React's relationship with JavaScript. "
"Its specialized architecture simplifies game design and development. By leveraging Dojo, developers can "
"use succinct commands that transform into comprehensive queries at compile time. This chapter delves "
"deeper into Dojo's unique architecture."
msgstr ""
"Dojo proporciona una capa de abstracción avanzada sobre Cairo, reflejando la relación de React con "
"JavaScript. Su arquitectura especializada simplifica el diseño y desarrollo de juegos. Al aprovechar "
"Dojo, los desarrolladores pueden utilizar comandos concisos que se transforman en consultas completas en "
"tiempo de compilación. Este capítulo profundiza en la arquitectura única de Dojo."

#: src/cairo/overview.md:7
msgid "#### Delving into the Architecture"
msgstr "#### Profundizando en la Arquitectura"

#: src/cairo/overview.md:9
msgid ""
"Dojo efficiently encapsulates boilerplate contracts within the compiler, letting developers concentrate "
"on the distinct aspects of their game or app."
msgstr ""
"Dojo encapsula de manera eficiente contratos repetitivos dentro del compilador, lo que permite a los "
"desarrolladores concentrarse en los distintos aspectos de su juego o aplicación."

#: src/cairo/overview.md:11
msgid "Consider this as the most basic Dojo world setup:"
msgstr "Considere esto como la configuración de un World Dojo más básica:"

#: src/cairo/overview.md:13
msgid ""
"```rust,ignore\n"
"- src\n"
"  - main.cairo\n"
"  - lib.cairo\n"
"- Scarb.toml\n"
"```"
msgstr ""
"```rust,ignore\n"
"- src\n"
"  - main.cairo\n"
"  - lib.cairo\n"
"- Scarb.toml\n"
"```"

#: src/cairo/overview.md:20
msgid ""
"While seemingly simple, behind the scenes Dojo generates foundational contracts, setting the stage for "
"you to focus purely on data and logic. "
msgstr ""
"Si bien parece simple, detrás de escena, Dojo genera contratos fundamentales, preparando el escenario "
"para que usted se concentre únicamente en los datos y la lógica. "

#: src/cairo/overview.md:22
msgid "Lets take a look at the `main.cairo`:"
msgstr "Echemos un vistazo al `main.cairo`:"

#: src/cairo/overview.md:24
msgid ""
"```rust,ignore\n"
"use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"use starknet::ContractAddress;\n"
"\n"
"// dojo data models\n"
"#[derive(Model, Copy, Drop, Print, Serde)]\n"
"struct Position {\n"
"    #[key] // primary key\n"
"    player: ContractAddress,\n"
"    vec: Vec2,\n"
"}\n"
"\n"
"// regular cairo struct\n"
"#[derive(Copy, Drop, Serde, Print, Introspect)]\n"
"struct Vec2 {\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// interface\n"
"#[starknet::interface]\n"
"trait IPlayerActions<TContractState> {\n"
"    fn spawn(self: @TContractState, world: IWorldDispatcher);\n"
"}\n"
"\n"
"// contract\n"
"#[starknet::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"    use super::{Position, Vec2};\n"
"    use super::IPlayerActions;\n"
"\n"
"    // note the is no storage here - it's in the world contract\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        // \n"
"        // NOTICE: we pass the world dispatcher as an argument to every function. \n"
"        // This is how we interact with the world contract.\n"
"        //\n"
"        fn spawn(self: @ContractState, world: IWorldDispatcher) {\n"
"            // get player address\n"
"            let player = get_caller_address();\n"
"\n"
"            // dojo command - get player position\n"
"            let position = get!(world, player, (Position));\n"
"\n"
"            // dojo command - set player position\n"
"            set!(world, (Position { player, vec: Vec2 { x: 10, y: 10 } }));\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"use starknet::ContractAddress;\n"
"\n"
"// dojo data models\n"
"#[derive(Model, Copy, Drop, Print, Serde)]\n"
"struct Position {\n"
"    #[key] // primary key\n"
"    player: ContractAddress,\n"
"    vec: Vec2,\n"
"}\n"
"\n"
"// regular cairo struct\n"
"#[derive(Copy, Drop, Serde, Print, Introspect)]\n"
"struct Vec2 {\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// interface\n"
"#[starknet::interface]\n"
"trait IPlayerActions<TContractState> {\n"
"    fn spawn(self: @TContractState, world: IWorldDispatcher);\n"
"}\n"
"\n"
"// contract\n"
"#[starknet::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"    use super::{Position, Vec2};\n"
"    use super::IPlayerActions;\n"
"\n"
"    // note the is no storage here - it's in the world contract\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        // \n"
"        // NOTICE: we pass the world dispatcher as an argument to every function. \n"
"        // This is how we interact with the world contract.\n"
"        //\n"
"        fn spawn(self: @ContractState, world: IWorldDispatcher) {\n"
"            // get player address\n"
"            let player = get_caller_address();\n"
"\n"
"            // dojo command - get player position\n"
"            let position = get!(world, player, (Position));\n"
"\n"
"            // dojo command - set player position\n"
"            set!(world, (Position { player, vec: Vec2 { x: 10, y: 10 } }));\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/cairo/overview.md:81
msgid "### Breakdown"
msgstr "### Descomponer"

#: src/cairo/overview.md:83
msgid "This just a regular Cairo contract, with some specifics."
msgstr "Este es sólo un contrato normal y corriente de Cairo, con algunos detalles."

#: src/cairo/overview.md:85
msgid "#### `Position` struct"
msgstr "#### Estructura `Position`"

#: src/cairo/overview.md:87
msgid ""
"In a Dojo world, state is defined using models. These are structs marked with the `#[derive(Model)]` "
"attribute, functioning similarly to a keypair store. The primary key for a model is indicated using the "
"`#[key]` attribute; for instance, the `player` field serves as the primary key in this context."
msgstr ""
"En un World Dojo, el estado se define mediante Models. Estas son estructuras marcadas con el atributo "
"`#[derive(Model)]`, que funcionan de manera similar a un almacén de pares de claves. La clave principal "
"de un Model se indica mediante el atributo `#[key]`; por ejemplo, el campo `player` sirve como clave "
"principal en este contexto."

#: src/cairo/overview.md:89
msgid "Read more about models [here](./models.md)."
msgstr "Lea más sobre los Models [aquí](./models.md)."

#: src/cairo/overview.md:91
msgid "#### `spawn` function - a dojo system"
msgstr "#### Función `spawn`- Un sistema dojo"

#: src/cairo/overview.md:93
msgid ""
"In the `spawn` function, take note of the second parameter: the `IWorldDispatcher` interface. This "
"provides a gateway to the world contract. By integrating it into the function, it enables the `get!` and "
"`set!` macros to interface directly with the world contract. "
msgstr ""
"En la función `spawn`, tome nota del segundo parámetro: la interfaz `IWorldDispatcher`. Esto proporciona "
"una puerta de entrada al contrato de World. Al integrarlo en la función, permite que las macros `get!` y "
"`set!` interactúen directamente con el contrato World. "

#: src/cairo/overview.md:95
msgid "Commands, a significant innovation in Dojo, are further explored [here](./commands.md)."
msgstr "Los comandos, una innovación significativa en Dojo, se exploran más a fondo [aquí](./commands.md)."

#: src/cairo/overview.md:97
msgid "#### `#[storage]` attribute"
msgstr "#### Atributo `#[storage]`"

#: src/cairo/overview.md:99
msgid ""
"You will notice there is no storage in the contract. This is because the storage is in the world "
"contract. You can however use this attribute to store data in the System contract itself, but we suggest "
"you use the world contract for storage."
msgstr ""
"Notarás que no hay almacenamiento en el contrato. Esto se debe a que el almacenamiento está en el "
"contrato del World. Sin embargo, puede utilizar este atributo para almacenar datos en el contrato del "
"sistema, pero le sugerimos que utilice el contrato de World para el almacenamiento."

#: src/cairo/overview.md:101
msgid "### High level transaction flow of a world"
msgstr "### Flujo de transacciones de alto nivel de un World"

#: src/cairo/overview.md:103
msgid ""
"To call a Dojo world you invoke a system, which then calls the [world](./world.md) and does the "
"necessary state changes."
msgstr ""
"Para llamar a un World Dojo, se invoca un sistema, que luego llama al [World](./world.md) y realiza los "
"cambios de estado necesarios."

#: src/cairo/overview.md:105
msgid "Dojo World"
msgstr "Dojo World"

#: src/cairo/world.md:1
msgid ""
"> **To think about:** Consider Autonomous Worlds as sovereign blockchains residing within another "
"blockchain - a nested blockchain, so to speak. Just as you can deploy contracts onto Ethereum to enhance "
"its functionality, you can similarly introduce systems into the World contract to enrich its features. "
"While anyone can contribute to the World, akin to Ethereum, authorization is required to interact with "
"model state. There is a dedicated topic to [Authorisation](./authorization.md)."
msgstr ""
"> **Para pensar:** Considere los Autonomous Worlds  como cadenas de bloques soberanas que residen dentro "
"de otra cadena de bloques: una cadena de bloques anidada, por así decirlo. Así como puedes implementar "
"contratos en Ethereum para mejorar su funcionalidad, también puedes introducir Systems en el contrato "
"del World para enriquecer sus características. Si bien cualquiera puede contribuir al World, al igual "
"que Ethereum, se requiere autorización para interactuar con el estado Model. Hay un tema dedicado a "
"[Autorización](./autorización.md)."

#: src/cairo/world.md:3
msgid "## The World Contract"
msgstr "## El Contrato del World"

#: src/cairo/world.md:5
msgid ""
"The world contract functions as a central store for the world models and systems. Every contract that "
"interacts with the world, must use the world contract address as the first parameter. This is how the "
"world contract is able to manage the state of the world."
msgstr ""
"El contrato del World funciona como un almacén central para los Models y Systems mundiales. Todo "
"contrato que interactúe con el World debe utilizar la dirección del contrato World como primer "
"parámetro. Así es como el contrato del World puede gestionar el estado del World."

#: src/cairo/world.md:7
msgid ""
"Although we suggest strongly to structure your world around an ECS pattern you are not required to do "
"so. You can simply use the dojo-models as a keypair store along with the supporting infrastructure."
msgstr ""
"Aunque sugerimos encarecidamente estructurar su World en torno a un patrón ECS, no está obligado a "
"hacerlo. Simplemente puede utilizar los Models dojo como almacén de pares de claves junto con la "
"infraestructura de soporte."

#: src/cairo/world.md:9
msgid ""
"> Dojo core abstracts the world contract away, you do not write it and it is not meant to be altered "
"when building a world. However, it's important to understand how it works and how it interacts with the "
"rest of the system."
msgstr ""
"> El núcleo del Dojo abstrae el contrato World, no lo escribes y no debe modificarse al construir un "
"World. Sin embargo, es importante comprender cómo funciona y cómo interactúa con el resto del sistema."

#: src/cairo/world.md:11
msgid "### The `uuid()` command"
msgstr "### El comando `uuid()`"

#: src/cairo/world.md:13
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can be used to generate a unique "
"ID."
msgstr ""
"A menudo es útil generar IDs únicos para las entidades. La función `uuid()` puede utilizarse para "
"generar un ID único."

#: src/cairo/world.md:15
msgid "Use it like this:"
msgstr "Úsalo así:"

#: src/cairo/world.md:17
msgid ""
"```rust,ignore\n"
"let game_id = world.uuid();\n"
"```"
msgstr ""
"```rust,ignore\n"
"let game_id = world.uuid();\n"
"```"

#: src/cairo/world.md:22
msgid "### Full World API"
msgstr "### Full API World"

#: src/cairo/world.md:24
msgid "The world exposes an interface which can be interacted with by any client."
msgstr "El World expone una interfaz con la que puede interactuar cualquier cliente."

#: src/cairo/world.md:26
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"

#: src/cairo/systems.md:1
msgid "## Systems"
msgstr "## Systems"

#: src/cairo/systems.md:3
msgid ""
"> **IMPORTANT:** Before defining your systems, prioritize permissions. Plan carefully to ensure proper "
"access and security."
msgstr ""
"> **IMPORTANTE:** Antes de definir sus Systems, priorice los permisos. Planifique cuidadosamente para "
"garantizar el acceso y la seguridad adecuados."

#: src/cairo/systems.md:5 src/cairo/models.md:6
msgid "**_TL;DR_**"
msgstr "**_TL;DR_**"

#: src/cairo/systems.md:6
msgid ""
"- Systems function as contract methods.\n"
"- Contracts containing Systems gain permissions to write to models.\n"
"- Systems pass a `world` address as their first parameter unless utilizing the [`#[dojo::contract]`]"
"(#the-dojocontract-decorator) decorator.\n"
"- Systems engage the world contract to alter models' state.\n"
"- The world contract is invoked through systems.\n"
"- Systems ought to be concise and specific.\n"
"- In most scenarios, systems are stateless."
msgstr ""
"- Los Systems funcionan como métodos de contrato.\n"
"- Los contratos que contienen Systems obtienen permisos para escribir en Models.\n"
"- Los Systems pasan una dirección `world` como primer parámetro a menos que utilicen el decorador "
"[`#[dojo::contract]`](#the-dojocontract-decorator).\n"
"- Los Systems participan en el contrato World para alterar el estado de los Models.\n"
"- El contrato World se invoca a través de Systems.\n"
"- Los Systems deben ser concisos y específicos.\n"
"- En la mayoría de los escenarios, los Systems no tienen estado."

#: src/cairo/systems.md:14
msgid "### What are Systems?"
msgstr "### ¿Qué son los Systems?"

#: src/cairo/systems.md:16
msgid "Within dojo we define systems as functions within a Contract that act on the world."
msgstr "Dentro del dojo definimos Systems como funciones dentro de un Contrato que actúan sobre el World."

#: src/cairo/systems.md:18
msgid ""
"Systems play a pivotal role in your world's logic, directly mutating its component states. It's "
"important to understand that to enact these mutations, a system needs explicit permission from the "
"[`models`](./models.md) owner."
msgstr ""
"Los Systems desempeñan un papel fundamental en la lógica de su World, mutando directamente los estados "
"que lo componen. Es importante comprender que para implementar estas mutaciones, un sistema necesita un "
"permiso explícito del propietario de [`models`](./models.md)."

#: src/cairo/systems.md:20
msgid "### System Permissions"
msgstr "### Permisos del Sistema"

#: src/cairo/systems.md:22
msgid ""
"Since the whole contract is giving write access to the model, it is important to be careful when "
"defining systems. A simple way to think about it is:"
msgstr ""
"Dado que todo el contrato otorga acceso de escritura al Model, es importante tener cuidado al definir "
"los Systems. Una forma sencilla de pensarlo es:"

#: src/cairo/systems.md:24
msgid "System Permissions"
msgstr "Permisos del Sistema"

#: src/cairo/systems.md:26
msgid "### System Structure"
msgstr "### Estructura del Sistema"

#: src/cairo/systems.md:28
msgid ""
"Every system function starts with a [`world`](./world.md) address as its initial parameter. This design "
"permits these functions to alter the world's state. Notably, this structure also makes systems adaptable "
"and reusable across multiple worlds!"
msgstr ""
"Cada función del sistema comienza con una dirección [`world`](./world.md) como parámetro inicial. Este "
"diseño permite que estas funciones alteren el estado del World. En particular, esta estructura también "
"hace que los Systems sean adaptables y reutilizables en múltiples Worlds"

#: src/cairo/systems.md:30
msgid "Let's look at the simplest possible system which mutates the state of the `Moves` component."
msgstr "Veamos el sistema más simple posible que muta el estado del componente `Moves`."

#: src/cairo/systems.md:32
msgid ""
"```rust,ignore\n"
"#[starknet::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"    use dojo_examples::components::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IPlayerActions;\n"
"\n"
"    // no storage\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    // implementation of the PlayerActions interface\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        fn spawn(self: @ContractState, world: IWorldDispatcher) {\n"
"            let player = get_caller_address();\n"
"            let position = get!(world, player, (Position));\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves {\n"
"                        player,\n"
"                        remaining: 10,\n"
"                        last_direction: Direction::None(())\n"
"                    }\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[starknet::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"    use dojo_examples::components::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IPlayerActions;\n"
"\n"
"    // no storage\n"
"    #[storage]\n"
"    struct Storage {}\n"
"\n"
"    // implementation of the PlayerActions interface\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        fn spawn(self: @ContractState, world: IWorldDispatcher) {\n"
"            let player = get_caller_address();\n"
"            let position = get!(world, player, (Position));\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves {\n"
"                        player,\n"
"                        remaining: 10,\n"
"                        last_direction: Direction::None(())\n"
"                    }\n"
"                )\n"
"            );\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:66
msgid "## Breaking it down"
msgstr "## Descomponiéndolo"

#: src/cairo/systems.md:68 src/cairo/hello-dojo.md:157
msgid "#### System is a contract"
msgstr "#### El Sistema es un contrato"

#: src/cairo/systems.md:70
msgid ""
"As you can see a System is like a regular Starknet contract. It can include storage, and it can "
"implement interfaces."
msgstr ""
"Como puede ver, un sistema es como un contrato normal de Starknet. Puede incluir almacenamiento y puede "
"implementar interfaces."

#: src/cairo/systems.md:72
msgid "#### `Spawn` function"
msgstr "#### Función `Spawn`"

#: src/cairo/systems.md:74
msgid ""
"The spawn function is currently the only function that exists in this system. It is called when a player "
"spawns into the world. It is responsible for setting up the player's initial state."
msgstr ""
"La función de spawn es actualmente la única función que existe en este sistema. Se llama cuando un "
"jugador aparece en el World. Es responsable de configurar el estado inicial del jugador."

#: src/cairo/systems.md:76
msgid "### The `#[dojo::contract]` Decorator"
msgstr "### El Decorador `# [dojo :: contract]`"

#: src/cairo/systems.md:78
msgid ""
"All StarkNet contracts are defined using the `#[starknet::contract]` decorator, ensuring accurate "
"compilation. In this context, Dojo introduces the `#[dojo::contract]` decorator, which aims to minimize "
"boilerplate in contract writing. It’s imperative to acknowledge that utilizing this decorator is "
"entirely optional."
msgstr ""
"Todos los contratos de StarkNet se definen utilizando el decorador `#[starknet::contract]`, lo que "
"garantiza una compilación precisa. En este contexto, Dojo presenta el decorador `#[dojo::contract]`, "
"cuyo objetivo es minimizar el texto repetitivo en la redacción del contrato. Es imperativo reconocer que "
"utilizar este decorador es completamente opcional."

#: src/cairo/systems.md:80
msgid ""
"The `#[dojo::contract]` decorator allows developers to omit including `world: IWorldDispatcher` as a "
"parameter. Behind the scenes, it injects the world into the contract and eliminates some imports, "
"thereby streamlining the development process."
msgstr ""
"El decorador `#[dojo::contract]` permite a los desarrolladores omitir incluir `world: IWorldDispatcher` "
"como parámetro. Entre bastidores, inyecta el World en el contrato y elimina algunas importaciones, "
"agilizando así el proceso de desarrollo."

#: src/cairo/systems.md:82
msgid ""
"```rust,ignore\n"
"#[dojo::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo_examples::models::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IPlayerActions;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Moved: Moved,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Moved {\n"
"        player: ContractAddress,\n"
"        direction: Direction\n"
"    }\n"
"\n"
"    // impl: implement functions specified in trait\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        // ContractState is defined by system decorator expansion\n"
"        fn spawn(self: @ContractState) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let player = get_caller_address();\n"
"            let position = get!(world, player, (Position));\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves { player, remaining: 10, last_direction: Direction::None(()) },\n"
"                    Position { player, vec: Vec2 { x: 10, y: 10 } },\n"
"                )\n"
"            );\n"
"        }\n"
"\n"
"        fn move(self: @ContractState, direction: Direction) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let player = get_caller_address();\n"
"            let (mut position, mut moves) = get!(world, player, (Position, Moves));\n"
"            moves.remaining -= 1;\n"
"            moves.last_direction = direction;\n"
"            let next = next_position(position, direction);\n"
"            set!(world, (moves, next));\n"
"            emit!(world, Moved { player, direction });\n"
"            return ();\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[dojo::contract]\n"
"mod player_actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo_examples::models::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IPlayerActions;\n"
"\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Moved: Moved,\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Moved {\n"
"        player: ContractAddress,\n"
"        direction: Direction\n"
"    }\n"
"\n"
"    // impl: implement functions specified in trait\n"
"    #[external(v0)]\n"
"    impl PlayerActionsImpl of IPlayerActions<ContractState> {\n"
"        // ContractState is defined by system decorator expansion\n"
"        fn spawn(self: @ContractState) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let player = get_caller_address();\n"
"            let position = get!(world, player, (Position));\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves { player, remaining: 10, last_direction: Direction::None(()) },\n"
"                    Position { player, vec: Vec2 { x: 10, y: 10 } },\n"
"                )\n"
"            );\n"
"        }\n"
"\n"
"        fn move(self: @ContractState, direction: Direction) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let player = get_caller_address();\n"
"            let (mut position, mut moves) = get!(world, player, (Position, Moves));\n"
"            moves.remaining -= 1;\n"
"            moves.last_direction = direction;\n"
"            let next = next_position(position, direction);\n"
"            set!(world, (moves, next));\n"
"            emit!(world, Moved { player, direction });\n"
"            return ();\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:135
msgid "> To interact with Systems read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr ""
"> Para interactuar con los Systems, lea más en los documentos [sozo](../toolchain/sozo/overview.md)."

#: src/cairo/models.md:1
msgid "## Models"
msgstr "## Models"

#: src/cairo/models.md:3
msgid "> Models = Data"
msgstr "> Models = Data"

#: src/cairo/models.md:7
msgid ""
"- Models store structured data in your world.\n"
"- Models are Cairo structs with additional features.\n"
"- Models can implement traits.\n"
"- Use the `#[derive(Model)]` decorator to define them.\n"
"- Custom enums and types are supported.\n"
"- Define the primary key using the `#[key]` attribute."
msgstr ""
"- Los Models almacenan datos estructurados en tu World.\n"
"- Los Models son estructuras de Cairo con características adicionales.\n"
"- Los Models pueden implementar traits.\n"
"- Utilice el decorador `#[derive(Model)]` para definirlos.\n"
"- Se admiten enumeraciones y tipos personalizados.\n"
"- Defina la clave principal utilizando el atributo `#[key]`."

#: src/cairo/models.md:14
msgid "### Models are Structs"
msgstr "### Los Models son Structs"

#: src/cairo/models.md:16
msgid ""
"Models are structs annotated with the `#[derive(Model)]` attribute. Consider these models as a key-value "
"store, where the `#[key]` attribute is utilized to define the primary key. While models can contain any "
"number of fields, adhering to best practices in Entity-Component-System (ECS) design involves "
"maintaining small, isolated models. This approach fosters modularity and composability, enabling you to "
"reuse models across various entity types."
msgstr ""
"Los Models son estructuras anotadas con el atributo `#[derive(Model)]`. Considere estos Models como un "
"almacén de valores clave, donde el atributo `#[key]` se utiliza para definir la clave principal. Si bien "
"los Models pueden contener cualquier cantidad de campos, cumplir con las mejores prácticas en el Entity "
"Component System (ECS) implica mantener Models pequeños y aislados. Este enfoque fomenta la modularidad "
"y la componibilidad, lo que le permite reutilizar Models en varios tipos de entidades."

#: src/cairo/models.md:18
msgid ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"```"

#: src/cairo/models.md:27
msgid "#### The #[key] attribute"
msgstr "#### El atributo #[key]"

#: src/cairo/models.md:29
msgid ""
"The `#[key]` attribute indicates to Dojo that this model is indexed by the `player` field. You need to "
"define a key for each model, as this is how you query the model. However, you can create composite keys "
"by defining multiple fields as keys. "
msgstr ""
"El atributo `#[key]` indica a Dojo que este Model está indexado por el campo `player`. Debe definir una "
"clave para cada Model, ya que así es como se consulta el Model. Sin embargo, puede crear claves "
"compuestas definiendo varios campos como claves. "

#: src/cairo/models.md:31
msgid ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Resource {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    #[key]\n"
"    location: ContractAddress,\n"
"    balance: u8,\n"
"}\n"
"```"

#: src/cairo/models.md:42
msgid "In this case you then would set the model with both the player and location fields:"
msgstr "En este caso, entonces configurarías el Model con los campos de jugador y de ubicación:"

#: src/cairo/models.md:44
msgid ""
"```rust,ignore\n"
"set!(\n"
"    world,\n"
"    (\n"
"        Resource {\n"
"            player: caller,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"set!(\n"
"    world,\n"
"    (\n"
"        Resource {\n"
"            player: caller,\n"
"            location: 12,\n"
"            balance: 10\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/models.md:57
msgid "#### Implementing Traits"
msgstr "#### Implementación de Traits"

#: src/cairo/models.md:59
msgid ""
"Models can implement traits. This is useful for defining common functionality across models. For "
"example, you may want to define a `Position` model that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used when accessing the model."
msgstr ""
"Los Models pueden implementar traits. Esto es útil para definir una funcionalidad común entre Models. "
"Por ejemplo, es posible que desee definir un Model `Position` que implemente un traits `PositionTrait`. "
"Este traits podría definir funciones como `is_zero` y `is_equal` que podrían usarse al acceder al Model."

#: src/cairo/models.md:61
msgid ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"trait PositionTrait {\n"
"    fn is_zero(self: Position) -> bool;\n"
"    fn is_equal(self: Position, b: Position) -> bool;\n"
"}\n"
"\n"
"impl PositionImpl of PositionTrait {\n"
"    fn is_zero(self: Position) -> bool {\n"
"        if self.x - self.y == 0 {\n"
"            return true;\n"
"        }\n"
"        false\n"
"    }\n"
"\n"
"    fn is_equal(self: Position, b: Position) -> bool {\n"
"        self.x == b.x && self.y == b.y\n"
"    }\n"
"}\n"
"```"

#: src/cairo/models.md:81
msgid "#### Custom Setting models"
msgstr "#### Models de Configuración Personalizada"

#: src/cairo/models.md:83
msgid ""
"Suppose we need a place to keep a global value with the flexibility to modify it in the future. Take, "
"for instance, a global `combat_cool_down` parameter that defines the duration required for an entity to "
"be primed for another attack. To achieve this, we can craft a model dedicated to storing this value, "
"while also allowing for its modification via a decentralized governance model."
msgstr ""
"Supongamos que necesitamos un lugar para mantener un valor global con la flexibilidad de modificarlo en "
"el futuro. Tomemos, por ejemplo, un parámetro global `combat_cool_down` que define la duración requerida "
"para que una entidad esté preparada para otro ataque. Para lograr esto, podemos diseñar un Model "
"dedicado a almacenar este valor y al mismo tiempo permitir su modificación a través de un Model de "
"gobernanza descentralizada."

#: src/cairo/models.md:85
msgid ""
"To establish these models, you'd follow the usual creation method. However, when initializing them, "
"employ a constant identifier, such as GAME_SETTINGS_ID."
msgstr ""
"Para establecer estos Models, seguirías el método de creación habitual. Sin embargo, al inicializarlos, "
"emplee un identificador constante, como GAME_SETTINGS_ID."

#: src/cairo/models.md:87
msgid ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(model, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "
msgstr ""
"```rust,ignore\n"
"const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
"\n"
"#[derive(model, Copy, Drop, Serde, SerdeLen)]\n"
"struct GameSettings {\n"
"    #[key]\n"
"    game_settings_id: u32,\n"
"    combat_cool_down: u32,\n"
"}\n"
"``` "

#: src/cairo/models.md:98
msgid "#### Types"
msgstr "#### Tipos"

#: src/cairo/models.md:100
msgid "Support model types:"
msgstr "Tipos de Models que soporta:"

#: src/cairo/models.md:102
msgid ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`\n"
"-   Enums\n"
"-   Custom Types"
msgstr ""
"-   `u8`\n"
"-   `u16`\n"
"-   `u32`\n"
"-   `u64`\n"
"-   `u128`\n"
"-   `u256`\n"
"-   `ContractAddress`\n"
"-   Enums\n"
"-   Custom Types"

#: src/cairo/models.md:112
msgid "It is currently not possible to use Arrays."
msgstr "Actualmente no es posible utilizar Arrays."

#: src/cairo/models.md:114
msgid "#### Custom Types + Enums "
msgstr "#### Tipos Personalizados + Enums "

#: src/cairo/models.md:115 src/cairo/migration/0.3.0.md:27
msgid "For models containing complex types, it's crucial to implement the `SchemaIntrospection` trait."
msgstr "Para Models que contienen tipos complejos, es crucial implementar el trait `SchemaIntrospection`."

#: src/cairo/models.md:117 src/cairo/migration/0.3.0.md:29
msgid "Consider the model below:"
msgstr "Considere el siguiente Model:"

#: src/cairo/models.md:119
msgid ""
"```rust,ignore\n"
"struct Card {\n"
"    #[key]\n"
"    token_id: u256,\n"
"    /// The card's designated role.\n"
"    role: Roles,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct Card {\n"
"    #[key]\n"
"    token_id: u256,\n"
"    /// The card's designated role.\n"
"    role: Roles,\n"
"}\n"
"```"

#: src/cairo/models.md:128 src/cairo/migration/0.3.0.md:41
msgid ""
"For complex types, like `Roles` in the above example, you need to implement `SchemaIntrospection`. "
"Here's how:"
msgstr ""
"Para tipos complejos, como `Roles` en el ejemplo anterior, es necesario implementar "
"`SchemaIntrospection`. Así es cómo:"

#: src/cairo/models.md:130 src/cairo/migration/0.3.0.md:43
msgid ""
"```rust,ignore\n"
"impl RolesSchemaIntrospectionImpl for SchemaIntrospection<Roles> {\n"
"    #[inline(always)]\n"
"    fn size() -> usize {\n"
"        1 // Represents the byte size of the enum.\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn layout(ref layout: Array<u8>) {\n"
"        layout.append(8); // Specifies the layout byte size;\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn ty() -> Ty {\n"
"        Ty::Enum(\n"
"            Enum {\n"
"                name: 'Roles',\n"
"                attrs: array![].span(),\n"
"                children: array![\n"
"                    ('Goalkeeper', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Defender', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Midfielder', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Attacker', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                ]\n"
"                .span()\n"
"            }\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"impl RolesSchemaIntrospectionImpl for SchemaIntrospection<Roles> {\n"
"    #[inline(always)]\n"
"    fn size() -> usize {\n"
"        1 // Represents the byte size of the enum.\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn layout(ref layout: Array<u8>) {\n"
"        layout.append(8); // Specifies the layout byte size;\n"
"    }\n"
"\n"
"    #[inline(always)]\n"
"    fn ty() -> Ty {\n"
"        Ty::Enum(\n"
"            Enum {\n"
"                name: 'Roles',\n"
"                attrs: array![].span(),\n"
"                children: array![\n"
"                    ('Goalkeeper', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Defender', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Midfielder', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                    ('Attacker', serialize_member_type(@Ty::Tuple(array![].span()))),\n"
"                ]\n"
"                .span()\n"
"            }\n"
"        )\n"
"    }\n"
"}\n"
"```"

#: src/cairo/models.md:161
msgid "### In practice with modularity in mind"
msgstr "### En la práctica teniendo en cuenta la modularidad"

#: src/cairo/models.md:163
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess intrinsic differences, they share "
"common traits, such as having a position and health. However, humans possess an additional model. "
"Furthermore, we introduce a Counter model, a distinct feature that tallies the numbers of humans and "
"goblins."
msgstr ""
"Considere una analogía tangible: Humanos y Duendes. Si bien poseen diferencias intrínsecas, comparten "
"rasgos comunes, como tener una posición y salud. Sin embargo, los humanos poseen un Model adicional. "
"Además, presentamos un Model de contador, una característica distintiva que cuenta el número de humanos "
"y duendes."

#: src/cairo/models.md:165
msgid ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter model\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter model\n"
"#[derive(Model, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"

#: src/cairo/models.md:198
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` model, and the Goblin will have a `Health` "
"and `Position` model. By doing we save having to create Health and Position models for each entity type."
msgstr ""
"Entonces el Humano tendrá un Model de `Potions`, `Health` y `Position`, y el Duende tendrá un Model de "
"`Health` y `Position`. Al hacerlo nos ahorramos tener que crear Models de Salud y Posición para cada "
"tipo de entidad."

#: src/cairo/models.md:200
msgid "So then a system would look like this:"
msgstr "Entonces un sistema quedaría así:"

#: src/cairo/models.md:202
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::models::Position;\n"
"    use dojo_examples::models::Health;\n"
"    use dojo_examples::models::Potions;\n"
"    use dojo_examples::models::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This pattern is useful for "
"settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position.y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position.y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::models::Position;\n"
"    use dojo_examples::models::Health;\n"
"    use dojo_examples::models::Potions;\n"
"    use dojo_examples::models::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This pattern is useful for "
"settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position.y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position.y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/models.md:270
msgid "> A complete example can be found in the [Dojo Starter](https://github.com/dojoengine/dojo-starter)"
msgstr ""
"> Puede encontrar un ejemplo completo en [Dojo Starter](https://github.com/dojoengine/dojo-starter)"

#: src/cairo/commands.md:1
msgid "## Commands"
msgstr "## Comandos"

#: src/cairo/commands.md:3
msgid "_tldr_"
msgstr "_tldr_"

#: src/cairo/commands.md:4
msgid ""
"- Commands are shorthand ways to write function calls\n"
"- Commands abstract complex queries into shorthands\n"
"- Commands are similar to rust macros"
msgstr ""
"- Los Comandos son formas abreviadas de escribir llamadas a funciones.\n"
"- Los Comandos abstraen consultas complejas en taquigrafías\n"
"- Los Comandos son similares a las macros de Rust"

#: src/cairo/commands.md:8
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them heavily within the systems "
"you design."
msgstr ""
"Comprender los comandos es clave para entender Dojo. Los aprovechará en gran medida dentro de los "
"Systems que diseñe."

#: src/cairo/commands.md:10
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time to facilitate system "
"execution. They provide a convenient way for systems to interact with the world state by abstracting "
"common operations, such as retrieving or updating models, and generating unique IDs. By leveraging these "
"commands, developers can streamline their system implementations and improve code readability."
msgstr ""
"Los comandos en Dojo son funciones generalizadas que se expanden en tiempo de compilación para facilitar "
"la ejecución del sistema. Proporcionan una forma conveniente para que los Systems interactúen con el "
"estado del World abstrayendo operaciones comunes, como recuperar o actualizar Models, y generar "
"identificaciones únicas. Al aprovechar estos comandos, los desarrolladores pueden optimizar las "
"implementaciones de sus Systems y mejorar la legibilidad del código."

#: src/cairo/commands.md:13
msgid "### Using commands"
msgstr "### Usando comandos"

#: src/cairo/commands.md:15
msgid ""
"Commands are used within systems to interact with the world state. They are called using the following "
"syntax:"
msgstr ""
"Los comandos se utilizan dentro de los Systems para interactuar con el estado del World. Se llaman "
"usando la siguiente sintaxis:"

#: src/cairo/commands.md:17
msgid "### The `get!` command"
msgstr "### El comando `get!`"

#: src/cairo/commands.md:19
msgid "The `get!` command is used to retrieve models from the world state:"
msgstr "El comando `get!` se utiliza para recuperar Models del estado del World:"

#: src/cairo/commands.md:21
msgid ""
"```rust,ignore\n"
"// world = calling world\n"
"// caller = key of the entity that called the system\n"
"// (Position, Moves) = tuple of models to retrieve\n"
"let (position, moves) = get!(world, caller, (Position, Moves));\n"
"```"
msgstr ""
"```rust,ignore\n"
"// world = calling world\n"
"// caller = key of the entity that called the system\n"
"// (Position, Moves) = tuple of models to retrieve\n"
"let (position, moves) = get!(world, caller, (Position, Moves));\n"
"```"

#: src/cairo/commands.md:28
msgid ""
"Here we are retrieving the `Position` and `Moves` models from the world state. We are also using the "
"`caller` to retrieve the models for the current entity."
msgstr ""
"Aquí estamos recuperando los Models de `Position` y `Moves` del estado del World. También estamos usando "
"`caller` para recuperar los Models de la entidad actual."

#: src/cairo/commands.md:30
msgid "You can then use `position` and `moves` as you would as any other Cairo struct."
msgstr "Luego puede usar `position` y `moves` como lo haría con cualquier otra estructura de Cairo."

#: src/cairo/commands.md:32
msgid "### The `set!` command"
msgstr "### El comando `set!`"

#: src/cairo/commands.md:34
msgid "The `set!` command is used to update models state."
msgstr "El comando `set!` se utiliza para actualizar el estado de los Models."

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(world, (\n"
"    Moves {\n"
"        player: caller, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: caller, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(world, (moves, position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"set !(world, (\n"
"    Moves {\n"
"        player: caller, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: caller, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(world, (moves, position));\n"
"```"

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` models in the world state using the `caller` as the "
"entity id."
msgstr ""
"Aquí estamos actualizando los Models `Moves` y `Position` en el estado de World utilizando`caller` como "
"el id de entidad."

#: src/cairo/commands.md:52
msgid "### The `emit!` command"
msgstr "### El comando `emit!`"

#: src/cairo/commands.md:54
msgid ""
"The `emit!` command is used to emit custom events. These events are indexed by [torii](../toolchain/"
"torii/overview.md)"
msgstr ""
"El comando `emitir!` se utiliza para emitir eventos personalizados. Estos eventos están indexados por "
"[torii](../toolchain/torii/overview.md)"

#: src/cairo/commands.md:56
msgid ""
"```rust,ignore\n"
"emit!(world, Moved { address: caller, direction });\n"
"```"
msgstr ""
"```rust,ignore\n"
"emit!(world, Moved { address: caller, direction });\n"
"```"

#: src/cairo/commands.md:60
msgid ""
"This will emit these values which could be captured by a client or you could query these via [torii](../"
"toolchain/torii/overview.md)"
msgstr ""
"Esto emitirá estos valores que podrían ser capturados por un cliente o usted podría consultarlos a "
"través de [torii](../toolchain/torii/overview.md)"

#: src/cairo/config.md:1
msgid "# Config"
msgstr "# Configuración"

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a regular [Scarb](https://docs.swmansion."
"com/scarb/) file which is an excellent Cairo package manager and project manager."
msgstr ""
"Los Worlds Dojo se definen en sus archivos Scarb.toml. Este es solo un archivo [Scarb](https://docs."
"swmansion.com/scarb/) normal que es un excelente administrador de paquetes y administrador de proyectos "
"de Cairo."

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr "Ejemplo completo de un archivo Scarb.toml:"

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.3.0\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"# IMPORTANT: Dojo should be pinned to a specific version or else your world might not compile\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\", rev=\"v0.3.0\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"# local katana devnet\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = \"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = \"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = \"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.3.0\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"# IMPORTANT: Dojo should be pinned to a specific version or else your world might not compile\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\", rev=\"v0.3.0\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"# local katana devnet\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = \"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = \"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = \"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"

#: src/cairo/events.md:1
msgid "## Events"
msgstr "## Eventos"

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every time there's an update to a "
"`Model`, the `World` contract emits these events. What's even more exciting is that you can craft your "
"own custom events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/overview.md), "
"all these events are seamlessly indexed, ensuring easy and efficient querying."
msgstr ""
"Los eventos juegan un papel fundamental en la decodificación de la dinámica de un World en Dojo. Cada "
"vez que hay una actualización de un `Model`, el contrato `World` emite estos eventos. ¡Lo que es aún más "
"emocionante es que puedes crear tus propios eventos personalizados para satisfacer necesidades "
"específicas! Además, gracias a [Torii](../toolchain/torii/overview.md), todos estos eventos se indexan "
"perfectamente, lo que garantiza una consulta fácil y eficiente."

#: src/cairo/events.md:6
msgid "### Component Events"
msgstr "### Eventos de Componentes"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` model:"
msgstr "Considere este ejemplo de un Model `Moves`:"

#: src/cairo/events.md:10
msgid ""
"```rust,ignore\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct Moves {\n"
"    #[key]\n"
"    player: Address,\n"
"    remaining: u32,\n"
"}\n"
"```"

#: src/cairo/events.md:18
msgid ""
"When this component is updated, the `World` contract will emit an event with the following structure:"
msgstr ""
"Cuando se actualice este componente, el contrato `World` emitirá un evento con la siguiente estructura:"

#: src/cairo/events.md:20
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // offset for the value in the table\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // offset for the value in the table\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"

#: src/cairo/events.md:30
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and indexed for querying. This "
"will allow you to then reconstruct the state of your world."
msgstr ""
"Esto luego será capturado por [Torii](../toolchain/torii/overview.md) y indexado para realizar "
"consultas. Esto te permitirá luego reconstruir el estado de tu World."

#: src/cairo/events.md:32
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an event with the following "
"structure:"
msgstr ""
"De manera similar, cuando se elimina un componente, el contrato `World` emitirá un evento con la "
"siguiente estructura:"

#: src/cairo/events.md:34
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreDelRecord {\n"
"    table: felt252,\n"
"    keys: Span<felt252>,\n"
"}\n"
"```"

#: src/cairo/events.md:42
msgid "### World Events"
msgstr "### Eventos de World"

#: src/cairo/events.md:44
msgid ""
"The `World` contract also emits events when it's initialized and when new components and systems are "
"registered. These events are emitted with the following structures:"
msgstr ""
"El contrato `World` también emite eventos cuando se inicializa y cuando se registran nuevos componentes "
"y Systems. Estos eventos se emiten con las siguientes estructuras:"

#: src/cairo/events.md:46
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct WorldSpawned {\n"
"    address: ContractAddress,\n"
"    caller: ContractAddress\n"
"}\n"
"```"

#: src/cairo/events.md:54
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct ComponentRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:62
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct SystemRegistered {\n"
"    name: felt252,\n"
"    class_hash: ClassHash\n"
"}\n"
"```"

#: src/cairo/events.md:70
msgid "These events are also captured by [Torii](../toolchain/torii/overview.md) and indexed for querying."
msgstr ""
"Estos eventos también son capturados por [Torii](../toolchain/torii/overview.md) y indexados para "
"consultas."

#: src/cairo/events.md:73
msgid "### Custom Events"
msgstr "### Eventos Personalizados"

#: src/cairo/events.md:75
msgid ""
"Within your systems, emitting custom events can be highly beneficial. Fortunately, there's a handy `emit!"
"` macro that lets you release events directly from your world. These events are indexed by [torii](../"
"toolchain/torii/overview.md)"
msgstr ""
"Dentro de sus Systems, la emisión de eventos personalizados puede resultar muy beneficiosa. "
"Afortunadamente, existe una útil macro `emit!` que te permite liberar eventos directamente desde tu "
"World. Estos eventos están indexados por [torii](../toolchain/torii/overview.md)"

#: src/cairo/events.md:77
msgid "Use it like so:"
msgstr "Úselo así:"

#: src/cairo/events.md:79
msgid ""
"```rust,ignore\n"
"emit!(world, Moved { address, direction });\n"
"```"
msgstr ""
"```rust,ignore\n"
"emit!(world, Moved { address, direction });\n"
"```"

#: src/cairo/events.md:83
msgid "Include this in your system and it will emit an event with the following structure:"
msgstr "Incluya esto en su sistema y emitirá un evento con la siguiente estructura:"

#: src/cairo/events.md:85
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct Moved {\n"
"    address: felt252,\n"
"    direction: felt252,\n"
"}\n"
"```"

#: src/cairo/events.md:93
msgid "Now a full example using a custom event: "
msgstr "Ahora un ejemplo completo usando un evento personalizado: "

#: src/cairo/events.md:95
msgid ""
"```rust,ignore\n"
"fn move(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(world, caller, (Position, Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(world, (moves, next));\n"
"    emit !(world, Moved { address: caller, direction });\n"
"    return ();\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"fn move(ctx: Context, direction: Direction) {\n"
"    let (mut position, mut moves) = get !(world, caller, (Position, Moves));\n"
"    moves.remaining -= 1;\n"
"\n"
"    let next = next_position(position, direction);\n"
"    \n"
"    set !(world, (moves, next));\n"
"    emit !(world, Moved { address: caller, direction });\n"
"    return ();\n"
"}\n"
"```"

#: src/cairo/events.md:108
msgid "> Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr "> Nota: Lea acerca de las macros `get!` y `set!` en [Comandos](./commands.md)."

#: src/cairo/authorization.md:1
msgid "## Authorization"
msgstr "## Autorización"

#: src/cairo/authorization.md:3
msgid ""
"> Authorization is crucial to a world, just like how authorization is crucial to any smart contract."
msgstr ""
"> La autorización es crucial para un World, al igual que la autorización es crucial para cualquier "
"smart contrac."

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) function as sovereign chains "
"nested within a public blockchain. These Worlds are also open to the public. This structure allows "
"anyone to enhance a World by deploying models or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a model's state within a System requires "
"the appropriate authorization from the model owner."
msgstr ""
"Como se analiza en el capítulo [World](./world.md), los Autonomous Worlds  (AWs) funcionan como cadenas "
"soberanas anidadas dentro de una cadena de bloques pública. Estos Worlds también están abiertos al "
"público. Esta estructura permite a cualquiera mejorar un World mediante el despliegue de Models o "
"Systems. Sin embargo, esta apertura también introduce consideraciones de seguridad. De manera similar a "
"Ethereum, interactuar con el estado de un Model dentro de un Sistema requiere la autorización adecuada "
"del propietario del Model."

#: src/cairo/authorization.md:7
msgid "### Auth Architecture"
msgstr "### Arquitectura de Auth"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the `System` has authorization to "
"update the model state. Only when the `System` possesses the necessary authorization, the `set!` is "
"executed. The following diagram illustrates the authorization architecture."
msgstr ""
"Cada vez que se llama a un `set!` en un `System`, el World verifica si el `System` tiene autorización "
"para actualizar el estado del Model. Sólo cuando el `System` posee la autorización necesaria, se ejecuta "
"el `set!`. El siguiente diagrama ilustra la arquitectura de autorización."

#: src/cairo/authorization.md:11
msgid "Authorization Architecture"
msgstr "Arquitectura de Autorización"

#: src/cairo/authorization.md:13
msgid "### Providing Authorization"
msgstr "### Proporcionar Autorización"

#: src/cairo/authorization.md:15
msgid ""
"> The deployer of the model is its initial owner. A model owner is able to grant the `owner` and "
"`writer` roles. Only owners can grant a System the `writer` role which allows it to update the model."
msgstr ""
"> El implementador del Model es su propietario inicial. Un propietario de Model puede otorgar los roles "
"de `owner` y `writer`. Solo los propietarios pueden otorgarle a un sistema la función de `writer`que le "
"permite actualizar el Model."

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr "`sozo` ofrece una herramienta conveniente para autorizar Systems."

#: src/cairo/authorization.md:19
msgid ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"
msgstr ""
"```shell\n"
"sozo auth writer Moves spawn\n"
"```"

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system to update the `Moves` model."
msgstr ""
"Este comando generará una autorización de `writer` para que el sistema `spawn` actualice el Model "
"`Moves`."

#: src/cairo/migration.md:1
msgid "## Migration"
msgstr "## Migración"

#: src/cairo/migration.md:3
msgid "[0.2.0 -> 0.3.0](./migration/0.3.0.md)"
msgstr "[0.2.0 -> 0.3.0](./migration/0.3.0.md)"

#: src/cairo/migration/0.3.0.md:1
msgid "## Migration Guide to 0.3.0"
msgstr "## Guía de Migración a 0.3.0"

#: src/cairo/migration/0.3.0.md:3
msgid ""
"0.3.0 introduced some breaking changes to Systems and Models which requires reworking of your worlds."
msgstr ""
"0.3.0 introdujo algunos cambios importantes en los Systems y Models que requieren una reelaboración de "
"sus Worlds."

#: src/cairo/migration/0.3.0.md:5
msgid ""
"- [Components](#components-to-models)\n"
"- [Systems](#systems-update)\n"
"- [Events](#events)\n"
"- [Npm](#npm)"
msgstr ""
"- [Componentes](#componentes-a-Models)\n"
"- [Systems](#actualización-de-Systems)\n"
"- [Eventos](#eventos)\n"
"- [Npm](#npm)"

#: src/cairo/migration/0.3.0.md:10
msgid "### Components to Models"
msgstr "### Componentes de Models"

#: src/cairo/migration/0.3.0.md:12
msgid ""
"In version 0.3.0, \"components\" have been renamed to \"models\". This has been done due to Cairo "
"introducing the concept of Components natively."
msgstr ""
"En la versión 0.3.0, se cambió el nombre de `components` a `models`. Esto se ha hecho debido a que Cairo "
"introdujo el concepto de Components de forma nativa."

#: src/cairo/migration/0.3.0.md:14
msgid "You must:"
msgstr "Usted debe:"

#: src/cairo/migration/0.3.0.md:16
msgid ""
"- Replace `#[component]` with `#[model]`.\n"
"- Update `#[derive(Component)]` to `#[derive(Model)]` throughout your code."
msgstr ""
"- Reemplace `#[component]` por `#[model]`.\n"
"- Actualice `#[derive(Component)]` a `#[derive(Model)]` en todo el código."

#: src/cairo/migration/0.3.0.md:19
msgid "**Note**: Ensure all related files and imports are updated accordingly."
msgstr ""
"**Nota**: Asegúrese de que todos los archivos relacionados y las importaciones se actualicen en "
"consecuencia."

#: src/cairo/migration/0.3.0.md:21
msgid "### Changes in Model Implementation"
msgstr "### Cambios en la Implementación del Model"

#: src/cairo/migration/0.3.0.md:23
msgid ""
"The trait `SerdeLen` is no longer implemented for models. If you relied on this previously, you should "
"now use `SchemaIntrospection`."
msgstr ""
"El trait `SerdeLen` ya no se implementa para los Models. Si confiaba en esto anteriormente, ahora "
"debería usar `SchemaIntrospection`."

#: src/cairo/migration/0.3.0.md:25
msgid "### Schema Introduction"
msgstr "### Introducción al Esquema"

#: src/cairo/migration/0.3.0.md:31
msgid ""
"```rust,ignore\n"
"struct Card {\n"
"\n"
"    #[key]\n"
"    token_id: u256,\n"
"    /// The card's designated role.\n"
"    role: Roles,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"struct Card {\n"
"\n"
"    #[key]\n"
"    token_id: u256,\n"
"    /// The card's designated role.\n"
"    role: Roles,\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:74
msgid "**Key Takeaways from custom types**:"
msgstr "**Conclusiones clave de los tipos personalizados**:"

#: src/cairo/migration/0.3.0.md:76
msgid ""
"- **size**: Defines the byte size of the type.\n"
"- **layout**: Outlines the byte structure/layout for the type. Validate and adjust as necessary.\n"
"- **ty**: Details the specific type, attributes, and subcomponents. For enums, like `Roles`, you need to "
"specify each member and its type."
msgstr ""
"- **size**: Define el tamaño en bytes del tipo.\n"
"- **layout**: Describe la estructura/diseño de bytes para el tipo. Validar y ajustar según sea "
"necesario.\n"
"- **ty**: Detalla el tipo, los atributos y los subcomponentes específicos. Para enumeraciones, como "
"`Roles`, debe especificar cada miembro y su tipo."

#: src/cairo/migration/0.3.0.md:80
msgid "### Systems Update"
msgstr "### Actualización de Systems"

#: src/cairo/migration/0.3.0.md:82
msgid ""
"Systems in 0.3.0 are very similar now to Cairo Contracts. You can write your systems just like regular "
"contracts, and each dojo contract can contain mulitple systems."
msgstr ""
"Los Systems en 0.3.0 ahora son muy similares a los Contratos de El Cairo. Puede escribir sus Systems "
"como si fueran contratos normales, y cada contrato de dojo puede contener varios Systems."

#: src/cairo/migration/0.3.0.md:84
msgid "Important high level changes:"
msgstr "Cambios importantes de alto nivel:"

#: src/cairo/migration/0.3.0.md:85
msgid ""
"- Systems are now starknet contracts\n"
"- Define [Interfaces](#interface-creation) for each system contract\n"
"- New optional `#[dojo::contract]` decorator defining systems\n"
"- Multiple systems per dojo contract, rather than singular\n"
"- `execute` is no longer required system selector name"
msgstr ""
"- Los Systems ahora son contratos starknet.\n"
"- Definir [Interfaces](#interface-creation) para cada contrato del sistema\n"
"- Nuevos Systems opcionales de definición de decoradores `#[dojo::contract]`\n"
"- Múltiples Systems por contrato de dojo, en lugar de singulares\n"
"- `execute` ya no es necesario el nombre del selector del sistema"

#: src/cairo/migration/0.3.0.md:92
msgid "#### Interface Creation"
msgstr "#### Creación de Interfaz"

#: src/cairo/migration/0.3.0.md:94
msgid ""
"System management has been revamped. Start by defining an interface for each system, which specifies its "
"implementation:"
msgstr ""
"La gestión del sistema ha sido renovada. Comience por definir una interfaz para cada sistema, que "
"especifica su implementación:"

#: src/cairo/migration/0.3.0.md:96
msgid ""
"```rust,ignore\n"
"#[starknet::interface]\n"
"trait ICreateCard<TContractState> {\n"
"    fn create_card(\n"
"        self: @TContractState,\n"
"        world: IWorldDispatcher,\n"
"        token_id: u256,\n"
"        dribble: u8,\n"
"        defense: u8,\n"
"        cost: u8,\n"
"        role: Roles,\n"
"        is_captain: bool\n"
"    );\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[starknet::interface]\n"
"trait ICreateCard<TContractState> {\n"
"    fn create_card(\n"
"        self: @TContractState,\n"
"        world: IWorldDispatcher,\n"
"        token_id: u256,\n"
"        dribble: u8,\n"
"        defense: u8,\n"
"        cost: u8,\n"
"        role: Roles,\n"
"        is_captain: bool\n"
"    );\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:112
msgid "Ensure the trait is typed with `TContractState`."
msgstr "Asegúrese de que el trait esté escrito con`TContractState`."

#: src/cairo/migration/0.3.0.md:114
msgid ""
"**Note**: Earlier versions required functions within the system to be named `execute`. This is no longer "
"the case."
msgstr ""
"**Nota**: Las versiones anteriores requerían que las funciones dentro del sistema se denominaran "
"`execute`. Este ya no es el caso."

#: src/cairo/migration/0.3.0.md:116
msgid "#### Interface Implementation"
msgstr "#### Implementación de la Interfaz"

#: src/cairo/migration/0.3.0.md:118
msgid "To implement the interface:"
msgstr "Para implementar la interfaz:"

#: src/cairo/migration/0.3.0.md:120
msgid ""
"1. Add `#[external(v0)]` before each method.\n"
"2. Ensure to reference the created interface in the module with `use super::ICreateCard;`."
msgstr ""
"1. Agregue `#[external(v0)]` antes de cada método.\n"
"2. Asegúrese de hacer referencia a la interfaz creada en el módulo con `use super::ICreateCard;`."

#: src/cairo/migration/0.3.0.md:123
msgid ""
"```rust,ignore\n"
"#[external(v0)]\n"
"impl CreateCardImpl for ICreateCard<ContractState> {\n"
"    fn create_card(\n"
"        self: @ContractState,\n"
"        world: IWorldDispatcher,\n"
"        token_id: u256,\n"
"        dribble: u8,\n"
"        defense: u8,\n"
"        cost: u8,\n"
"        role: Roles,\n"
"        is_captain: bool\n"
"    ) {\n"
"        // your logic here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[external(v0)]\n"
"impl CreateCardImpl for ICreateCard<ContractState> {\n"
"    fn create_card(\n"
"        self: @ContractState,\n"
"        world: IWorldDispatcher,\n"
"        token_id: u256,\n"
"        dribble: u8,\n"
"        defense: u8,\n"
"        cost: u8,\n"
"        role: Roles,\n"
"        is_captain: bool\n"
"    ) {\n"
"        // your logic here\n"
"    }\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:141
msgid "This then allows the `create_card` to be called just like a regular starknet function."
msgstr "Esto permite llamar a `create_card` como una función normal de Starknet."

#: src/cairo/migration/0.3.0.md:143
msgid "#### `#[dojo::contract]` decorator"
msgstr "#### Decorador `#[dojo::contract]`"

#: src/cairo/migration/0.3.0.md:145
msgid ""
"0.3.0 introduces a new optional decorator `#[dojo::contract]` which indicates to the compiler to inject "
"imports and the world dispatcher. This allows for minimal boilerplate."
msgstr ""
"0.3.0 introduce un nuevo decorador opcional `#[dojo::contract]` que indica al compilador que inyecte "
"importaciones y el world dispatcher. Esto permite un texto repetitivo mínimo."

#: src/cairo/migration/0.3.0.md:147
msgid ""
"```rust,ignore\n"
"#[dojo::contract]\n"
"mod move {\n"
"....code TODO\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[dojo::contract]\n"
"mod move {\n"
"....code TODO\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:154
msgid "### Events"
msgstr "### Eventos"

#: src/cairo/migration/0.3.0.md:156
msgid "Events should now reside within the models. Here's an example of how to migrate your events:"
msgstr ""
"Los eventos ahora deberían residir dentro de los Models. A continuación se muestra un ejemplo de cómo "
"migrar sus eventos:"

#: src/cairo/migration/0.3.0.md:158
msgid "**Previous Format**:"
msgstr "**Formato Anterior**:"

#: src/cairo/migration/0.3.0.md:159
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event, Copy)]\n"
"struct DeckCreated {\n"
"    player: ContractAddress,\n"
"    token_list: Span<u256>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event, Copy)]\n"
"struct DeckCreated {\n"
"    player: ContractAddress,\n"
"    token_list: Span<u256>,\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:167
msgid "**New Format**:"
msgstr "**Nuevo Formato**:"

#: src/cairo/migration/0.3.0.md:168
msgid ""
"```rust,ignore\n"
"#[event]\n"
"#[derive(Copy, Drop, starknet::Event)]\n"
"enum Event {\n"
"    DeckCreated(DeckCreated)\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Event)]\n"
"struct DeckCreated {\n"
"    player: ContractAddress,\n"
"    token_list: Span<u256>,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[event]\n"
"#[derive(Copy, Drop, starknet::Event)]\n"
"enum Event {\n"
"    DeckCreated(DeckCreated)\n"
"}\n"
"\n"
"#[derive(Copy, Drop, starknet::Event)]\n"
"struct DeckCreated {\n"
"    player: ContractAddress,\n"
"    token_list: Span<u256>,\n"
"}\n"
"```"

#: src/cairo/migration/0.3.0.md:182
msgid "### Testing Changes"
msgstr "### Testing de Cambios"

#: src/cairo/migration/0.3.0.md:184
msgid "#### Setup"
msgstr "#### Configuración"

#: src/cairo/migration/0.3.0.md:186
msgid ""
"Testing has seen significant changes with the change to systems as Contracts. Instead of using `world."
"execute`, use the dispatcher."
msgstr ""
"Las pruebas han visto cambios significativos con el cambio a Systems como Contratos. En lugar de "
"utilizar `world.execute`, utilice el dispatcher."

#: src/cairo/migration/0.3.0.md:188
msgid "1. Import necessary modules and traits:"
msgstr "1. Importe los módulos y traits necesarios:"

#: src/cairo/migration/0.3.0.md:190
msgid ""
"```rust,ignore\n"
"use dojo::test_utils::deploy_contract;\n"
"use tsubasa::systems::{ICreateCardDispatcher, ICreateCardDispatcherTrait};\n"
"```"
msgstr ""
"```rust,ignore\n"
"use dojo::test_utils::deploy_contract;\n"
"use tsubasa::systems::{ICreateCardDispatcher, ICreateCardDispatcherTrait};\n"
"```"

#: src/cairo/migration/0.3.0.md:195
msgid "2. Deploy the contract and instantiate the dispatcher:"
msgstr "2. Implementar el contrato y crear una instancia del dispatcher:"

#: src/cairo/migration/0.3.0.md:197
msgid ""
"```rust,ignore\n"
"let contract_create_card = deploy_contract(\n"
"    create_card_system::TEST_CLASS_HASH, array![].span()\n"
");\n"
"let create_card_system = ICreateCardDispatcher { contract_address: contract_create_card };\n"
"```"
msgstr ""
"```rust,ignore\n"
"let contract_create_card = deploy_contract(\n"
"    create_card_system::TEST_CLASS_HASH, array![].span()\n"
");\n"
"let create_card_system = ICreateCardDispatcher { contract_address: contract_create_card };\n"
"```"

#: src/cairo/migration/0.3.0.md:204
msgid "#### Function Testing"
msgstr "#### Función Testing"

#: src/cairo/migration/0.3.0.md:206
msgid "With the contract deployed and the dispatcher instantiated, proceed to test your functions:"
msgstr "Con el contrato implementado y el dispatcher creado, proceda a probar sus funciones:"

#: src/cairo/migration/0.3.0.md:208
msgid ""
"```rust,ignore\n"
"// ... (previous setup code)\n"
"\n"
"let result = create_card_system.create_card(\n"
"    // ... provide necessary parameters here\n"
");\n"
"\n"
"// Assert or validate the 'result' as per your test conditions\n"
"```"
msgstr ""
"```rust,ignore\n"
"// ... (previous setup code)\n"
"\n"
"let result = create_card_system.create_card(\n"
"    // ... provide necessary parameters here\n"
");\n"
"\n"
"// Assert or validate the 'result' as per your test conditions\n"
"```"

#: src/cairo/hello-dojo.md:1
msgid "# Hello Dojo"
msgstr "# Hola Dojo"

#: src/cairo/hello-dojo.md:3
msgid ""
"> This section assumes that you have already installed the Dojo toolchain and are familiar with Cairo. "
"If not, please refer to the [Getting Started](../getting-started/quick-start.md) section."
msgstr ""
"> Esta sección asume que ya ha instalado la cadena de herramientas Dojo y está familiarizado con Cairo. "
"De lo contrario, consulte la sección [Introducción] (../getting-started/quick-start.md)."

#: src/cairo/hello-dojo.md:5
msgid "## Dojo as an ECS in 15 Minutes"
msgstr "## Dojo como ECS en 15 Minutos"

#: src/cairo/hello-dojo.md:7
msgid ""
"Although Dojo isn't exclusively an Entity Component System (ECS) framework, we recommend adopting this "
"robust design pattern. In this context, systems shape the environment's logic, while components ([models]"
"(./models.md)) mirror the state of the world. By taking this route, you'll benefit from a structured and "
"modular framework that promises both flexibility and scalability in a continuously evolving world. If "
"this seems a bit intricate at first, hang tight; we'll delve into the details shortly."
msgstr ""
"Aunque Dojo no es exclusivamente un marco de Entity Component System (ECS), recomendamos adoptar este "
"sólido patrón de diseño. En este contexto, los Systems dan forma a la lógica del entorno, mientras que "
"los componentes ([models](./models.md)) reflejan el estado del World. Al tomar esta ruta, se beneficiará "
"de un marco estructurado y modular que promete flexibilidad y escalabilidad en un World en continua "
"evolución. Si esto parece un poco complicado al principio, espera; profundizaremos en los detalles en "
"breve."

#: src/cairo/hello-dojo.md:9
msgid "To start, let's set up a project to run locally on your machine. From an empty directory, execute:"
msgstr ""
"Para comenzar, configuremos un proyecto para que se ejecute localmente en su máquina. Desde un "
"directorio vacío, ejecute:"

#: src/cairo/hello-dojo.md:11
msgid ""
"```console\n"
"sozo init\n"
"```"
msgstr ""
"```console\n"
"sozo init\n"
"```"

#: src/cairo/hello-dojo.md:15
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a `dojo-starter` project in "
"your current directory. It's the ideal starting point for a new project and equips you with everything "
"you need to begin."
msgstr ""
"¡Felicidades! Ahora tienes un proyecto Dojo local. Este comando crea un proyecto `dojo-starter` en su "
"directorio actual. Es el punto de partida ideal para un nuevo proyecto y te proporciona todo lo que "
"necesitas para empezar."

#: src/cairo/hello-dojo.md:17
msgid "#### Anatomy of a Dojo Project"
msgstr "#### Anatomía de un proyecto Dojo"

#: src/cairo/hello-dojo.md:19
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the following structure (excluding "
"the non-Cairo files):"
msgstr ""
"Inspeccione el contenido del proyecto `dojo-starter` y notará la siguiente estructura (excluyendo los "
"archivos que no son de Cairo):"

#: src/cairo/hello-dojo.md:21
msgid ""
"```bash\n"
"src\n"
"  - actions.cairo\n"
"  - lib.cairo\n"
"  - models.cairo\n"
"  - utils.cairo\n"
"Scarb.toml\n"
"```"
msgstr ""
"```bash\n"
"src\n"
"  - actions.cairo\n"
"  - lib.cairo\n"
"  - models.cairo\n"
"  - utils.cairo\n"
"Scarb.toml\n"
"```"

#: src/cairo/hello-dojo.md:30
msgid ""
"Dojo projects bear a strong resemblance to typical Cairo projects. The primary difference is the "
"inclusion of a special attribute tag used to define your data models. In this context, we'll refer to "
"these models as components."
msgstr ""
"Los proyectos de dojo guardan un gran parecido con los proyectos típicos de Cairo. La principal "
"diferencia es la inclusión de una etiqueta de atributo especial que se utiliza para definir sus Models "
"de datos. En este contexto, nos referiremos a estos Models como componentes."

#: src/cairo/hello-dojo.md:32
msgid ""
"As we're crafting an ECS, we'll adhere to the specific terminology associated with Entity Component "
"Systems."
msgstr ""
"Mientras elaboramos un ECS, nos adheriremos a la terminología específica asociada con Entity Component "
"Systems."

#: src/cairo/hello-dojo.md:34
msgid "Open the `src/models.cairo` file to continue."
msgstr "Abra el archivo `src/models.cairo` para continuar."

#: src/cairo/hello-dojo.md:36
msgid ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"    last_direction: Direction\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Serde, Print, Introspect)]\n"
"struct Vec2 {\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Print, Serde)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    vec: Vec2,\n"
"}\n"
"\n"
"...rest of code\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Model, Copy, Drop, Serde)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"    last_direction: Direction\n"
"}\n"
"\n"
"#[derive(Copy, Drop, Serde, Print, Introspect)]\n"
"struct Vec2 {\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"#[derive(Model, Copy, Drop, Print, Serde)]\n"
"struct Position {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    vec: Vec2,\n"
"}\n"
"\n"
"...rest of code\n"
"```"

#: src/cairo/hello-dojo.md:61
msgid ""
"Notice the `#[derive(Model, Copy, Drop, Serde)]` attributes. For a model to be recognized, we _must_ "
"include `Model`. This signals to the Dojo compiler that this struct should be treated as a model."
msgstr ""
"Observe los atributos `#[derive(Model, Copy, Drop, Serde)]`. Para que un Model sea reconocido, _debemos_ "
"incluir `Model`. Esto le indica al compilador Dojo que esta estructura debe tratarse como un Model."

#: src/cairo/hello-dojo.md:63
msgid ""
"Our `Moves` model houses a `player` field. At the same tine, we have the `#[key]` attribute, it informs "
"Dojo that this model is indexed by the `player` field. If this is unfamiliar to you, we'll clarify its "
"importance later in the chapter. Essentially, it implies that you can query this component using the "
"`player` field. Our `Moves` model also contains the `remaining` and `last_direction` fields"
msgstr ""
"Nuestro Model `Moves` alberga un campo de`player`. Al mismo tiempo, tenemos el atributo `#[key]`, le "
"informa a Dojo que este Model está indexado por el campo `player`. Si esto no le resulta familiar, "
"aclararemos su importancia más adelante en este capítulo. Esencialmente, implica que puedes consultar "
"este componente usando el campo `player`. Nuestro Model `Moves` también contiene los campos `remaining` "
"y `last_direction`"

#: src/cairo/hello-dojo.md:65
msgid ""
"In a similar vein, we have a `Position` component that have a Vec2 data structure. Vec holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""
"De manera similar, tenemos un componente `Position` que tiene una estructura de datos Vec2. Vec tiene "
"valores `x` e `y`. Una vez más, este componente está indexado por el campo `player`."

#: src/cairo/hello-dojo.md:67
msgid "Now, let's examine the `src/actions.cairo` file:"
msgstr "Ahora, examinemos el archivo `src/actions.cairo`:"

#: src/cairo/hello-dojo.md:69
msgid ""
"```rust,ignore\n"
"// dojo decorator\n"
"#[dojo::contract]\n"
"mod actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo_examples::models::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IActions;\n"
"\n"
"    // declaring custom event struct\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Moved: Moved,\n"
"    }\n"
"\n"
"    // declaring custom event struct\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Moved {\n"
"        player: ContractAddress,\n"
"        direction: Direction\n"
"    }\n"
"\n"
"    // impl: implement functions specified in trait\n"
"    #[external(v0)]\n"
"    impl ActionsImpl of IActions<ContractState> {\n"
"        // ContractState is defined by system decorator expansion\n"
"        fn spawn(self: @ContractState) {\n"
"            // Access the world dispatcher for reading.\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            // Get the address of the current caller, possibly the player's address.\n"
"            let player = get_caller_address();\n"
"\n"
"            // Retrieve the player's current position from the world.\n"
"            let position = get!(world, player, (Position));\n"
"\n"
"            // Retrieve the player's move data, e.g., how many moves they have left.\n"
"            let moves = get!(world, player, (Moves));\n"
"\n"
"            // Update the world state with the new data.\n"
"            // 1. Increase the player's remaining moves by 10.\n"
"            // 2. Move the player's position 10 units in both the x and y direction.\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves {\n"
"                        player, remaining: moves.remaining + 10, last_direction: Direction::None(())\n"
"                    },\n"
"                    Position {\n"
"                        player, vec: Vec2 { x: position.vec.x + 10, y: position.vec.y + 10 }\n"
"                    },\n"
"                )\n"
"            );\n"
"        }\n"
"\n"
"        // Implementation of the move function for the ContractState struct.\n"
"        fn move(self: @ContractState, direction: Direction) {\n"
"            // Access the world dispatcher for reading.\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            // Get the address of the current caller, possibly the player's address.\n"
"            let player = get_caller_address();\n"
"\n"
"            // Retrieve the player's current position and moves data from the world.\n"
"            let (mut position, mut moves) = get!(world, player, (Position, Moves));\n"
"\n"
"            // Deduct one from the player's remaining moves.\n"
"            moves.remaining -= 1;\n"
"\n"
"            // Update the last direction the player moved in.\n"
"            moves.last_direction = direction;\n"
"\n"
"            // Calculate the player's next position based on the provided direction.\n"
"            let next = next_position(position, direction);\n"
"\n"
"            // Update the world state with the new moves data and position.\n"
"            set!(world, (moves, next));\n"
"\n"
"            // Emit an event to the world to notify about the player's move.\n"
"            emit!(world, Moved { player, direction });\n"
"        }\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// dojo decorator\n"
"#[dojo::contract]\n"
"mod actions {\n"
"    use starknet::{ContractAddress, get_caller_address};\n"
"    use dojo_examples::models::{Position, Moves, Direction, Vec2};\n"
"    use dojo_examples::utils::next_position;\n"
"    use super::IActions;\n"
"\n"
"    // declaring custom event struct\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Moved: Moved,\n"
"    }\n"
"\n"
"    // declaring custom event struct\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Moved {\n"
"        player: ContractAddress,\n"
"        direction: Direction\n"
"    }\n"
"\n"
"    // impl: implement functions specified in trait\n"
"    #[external(v0)]\n"
"    impl ActionsImpl of IActions<ContractState> {\n"
"        // ContractState is defined by system decorator expansion\n"
"        fn spawn(self: @ContractState) {\n"
"            // Access the world dispatcher for reading.\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            // Get the address of the current caller, possibly the player's address.\n"
"            let player = get_caller_address();\n"
"\n"
"            // Retrieve the player's current position from the world.\n"
"            let position = get!(world, player, (Position));\n"
"\n"
"            // Retrieve the player's move data, e.g., how many moves they have left.\n"
"            let moves = get!(world, player, (Moves));\n"
"\n"
"            // Update the world state with the new data.\n"
"            // 1. Increase the player's remaining moves by 10.\n"
"            // 2. Move the player's position 10 units in both the x and y direction.\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Moves {\n"
"                        player, remaining: moves.remaining + 10, last_direction: Direction::None(())\n"
"                    },\n"
"                    Position {\n"
"                        player, vec: Vec2 { x: position.vec.x + 10, y: position.vec.y + 10 }\n"
"                    },\n"
"                )\n"
"            );\n"
"        }\n"
"\n"
"        // Implementation of the move function for the ContractState struct.\n"
"        fn move(self: @ContractState, direction: Direction) {\n"
"            // Access the world dispatcher for reading.\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            // Get the address of the current caller, possibly the player's address.\n"
"            let player = get_caller_address();\n"
"\n"
"            // Retrieve the player's current position and moves data from the world.\n"
"            let (mut position, mut moves) = get!(world, player, (Position, Moves));\n"
"\n"
"            // Deduct one from the player's remaining moves.\n"
"            moves.remaining -= 1;\n"
"\n"
"            // Update the last direction the player moved in.\n"
"            moves.last_direction = direction;\n"
"\n"
"            // Calculate the player's next position based on the provided direction.\n"
"            let next = next_position(position, direction);\n"
"\n"
"            // Update the world state with the new moves data and position.\n"
"            set!(world, (moves, next));\n"
"\n"
"            // Emit an event to the world to notify about the player's move.\n"
"            emit!(world, Moved { player, direction });\n"
"        }\n"
"    }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:155
msgid "### Breaking it down"
msgstr "### Desglosándolo"

#: src/cairo/hello-dojo.md:159
msgid ""
"As you can see a `System` is like a dojo(starknet) contract. It imports the Models we defined earlier "
"and exposes two functions `spawn` and `move`. These functions are called when a player spawns into the "
"world and when they move respectively."
msgstr ""
"Como puede ver, un `System` es como un contrato de dojo (starknet). Importa los Models que definimos "
"anteriormente y expone dos funciones `spawn` y `move`. Estas funciones se llaman cuando un jugador "
"aparece en el World y cuando se mueve, respectivamente."

#: src/cairo/hello-dojo.md:161
msgid ""
"```rust,ignore\n"
"// Retrieve the player's current position from the world.\n"
"let position = get!(world, player, (Position));\n"
"\n"
"// Retrieve the player's move data, e.g., how many moves they have left.\n"
"let moves = get!(world, player, (Moves));\n"
"```"
msgstr ""
"```rust,ignore\n"
"// Retrieve the player's current position from the world.\n"
"let position = get!(world, player, (Position));\n"
"\n"
"// Retrieve the player's move data, e.g., how many moves they have left.\n"
"let moves = get!(world, player, (Moves));\n"
"```"

#: src/cairo/hello-dojo.md:169
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` and `Moves` model for the "
"`player` entity, which is the address of the caller."
msgstr ""
"Aquí usamos `get!` [comando](./commands.md) para recuperar el Model `Position` y `Moves` para la entidad "
"`player`, que es la dirección de la persona que llama."

#: src/cairo/hello-dojo.md:171
msgid "Now the next line:"
msgstr "Ahora la siguiente línea:"

#: src/cairo/hello-dojo.md:173
msgid ""
"```rust,ignore\n"
"// Update the world state with the new data.\n"
"// 1. Increase the player's remaining moves by 10.\n"
"// 2. Move the player's position 10 units in both the x and y direction.\n"
"set!(\n"
"    world,\n"
"    (\n"
"        Moves {\n"
"            player, remaining: moves.remaining + 10, last_direction: Direction::None(())\n"
"        },\n"
"        Position {\n"
"            player, vec: Vec2 { x: position.vec.x + 10, y: position.vec.y + 10}\n"
"        },\n"
"    )\n"
");\n"
"```"
msgstr ""
"```rust,ignore\n"
"// Update the world state with the new data.\n"
"// 1. Increase the player's remaining moves by 10.\n"
"// 2. Move the player's position 10 units in both the x and y direction.\n"
"set!(\n"
"    world,\n"
"    (\n"
"        Moves {\n"
"            player, remaining: moves.remaining + 10, last_direction: Direction::None(())\n"
"        },\n"
"        Position {\n"
"            player, vec: Vec2 { x: position.vec.x + 10, y: position.vec.y + 10}\n"
"        },\n"
"    )\n"
");\n"
"```"

#: src/cairo/hello-dojo.md:190
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and `Position` models for the "
"`player` entity."
msgstr ""
"Aquí usamos el [comando](./commands.md) `set!` para configurar los Models `Moves` y `Position` para la "
"entidad `player`."

#: src/cairo/hello-dojo.md:192
msgid "We covered a lot here in a short time. Let's recap:"
msgstr "Cubrimos mucho aquí en poco tiempo. Recapitulemos:"

#: src/cairo/hello-dojo.md:194
msgid ""
"- Explained the anatomy of a Dojo project\n"
"- Explained the importance of the `#[derive(Model)]`attribute\n"
"- Explained the `execute` function\n"
"- Explained the `Context` struct\n"
"- Touched on the `get!` and `set!` commands"
msgstr ""
"- Explicó la anatomía de un proyecto Dojo.\n"
"- Explicó la importancia del atributo `#[derive(Model)]`\n"
"- Explicó la función `execute`.\n"
"- Explicó la estructura `Context`.\n"
"- Se tocaron los comandos `get!` y `set!`"

#: src/cairo/hello-dojo.md:200
msgid "### Run it locally!"
msgstr "### ¡Ejecútalo localmente!"

#: src/cairo/hello-dojo.md:202
msgid "Now that we've covered some theory, let's build the Dojo project! In your primary terminal:"
msgstr "Ahora que hemos cubierto algo de teoría, ¡construyamos el proyecto Dojo! En su terminal principal:"

#: src/cairo/hello-dojo.md:204 src/deployment/locally.md:29
msgid ""
"```bash\n"
"sozo build\n"
"```"
msgstr ""
"```bash\n"
"sozo build\n"
"```"

#: src/cairo/hello-dojo.md:208
msgid "That compiled the components and system into an artifact that can be deployed! Simple as that!"
msgstr ""
"¡Eso compiló los componentes y el sistema en un artefacto que se puede implementar! ¡Simple como eso!"

#: src/cairo/hello-dojo.md:210
msgid ""
"Now, let's deploy it to [Katana](../toolchain/katana/overview.md)! First, we need to get Katana running. "
"Open a second terminal and execute:"
msgstr ""
"¡Ahora, implementémoslo en [Katana](../toolchain/katana/overview.md)! Primero, necesitamos hacer "
"funcionar a Katana. Abra una segunda terminal y ejecute:"

#: src/cairo/hello-dojo.md:212 src/deployment/locally.md:13
msgid ""
"```bash\n"
"katana --disable-fee\n"
"```"
msgstr ""
"```bash\n"
"katana --disable-fee\n"
"```"

#: src/cairo/hello-dojo.md:216
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running locally on your machine. Now, "
"let's deploy! In your primary terminal, execute:"
msgstr ""
"¡Éxito! [Katana](../toolchain/katana/overview.md) ahora debería estar ejecutándose localmente en su "
"máquina. ¡Ahora, implementemos! En su terminal principal, ejecute:"

#: src/cairo/hello-dojo.md:218 src/deployment/locally.md:23
msgid ""
"```bash\n"
"sozo migrate --name test\n"
"```"
msgstr ""
"```bash\n"
"sozo migrate --name test\n"
"```"

#: src/cairo/hello-dojo.md:222
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). You should see terminal "
"output similar to this:"
msgstr ""
"Esto implementará el artefacto en [Katana](../toolchain/katana/overview.md). Deberías ver una salida de "
"terminal similar a esta:"

#: src/cairo/hello-dojo.md:224
msgid ""
"```bash\n"
"Migration account: 0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\n"
"\n"
"World name: test\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 5\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (5): New 5 Update 0\n"
"\n"
"# Executor\n"
"  > Contract address: 0x5c3494b21bc92d40abdc40cdc54af66f22fb92bf876665d982c765a2cc0e06a\n"
"# Base Contract\n"
"  > Class Hash: 0x7aec2b7d7064c1294a339cd90060331ff704ab573e4ee9a1b699be2215c11c9\n"
"# World\n"
"  > Contract address: 0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"# Models (2)\n"
"Moves\n"
"  > Class hash: 0xb37482a660983dfbf65968caa26eab260d3e1077986454b52ac06e58ae20c4\n"
"Position\n"
"  > Class hash: 0x6ffc643cbc4b2fb9c424242b18175a5e142269b45f4463d1cd4dddb7a2e5095\n"
"  > Registered at: 0x3e74b09d320ceb5d4401842bec805489019c04202bc23bc67a385f6e537dce0\n"
"# Contracts (1)\n"
"actions\n"
"  > Contract address: 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a\n"
"\n"
"🎉 Successfully migrated World at address "
"0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"\n"
"✨ Updating manifest.json...\n"
"\n"
"✨ Done.\n"
"\n"
"```"
msgstr ""
"```bash\n"
"Migration account: 0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\n"
"\n"
"World name: test\n"
"\n"
"[1] 🌎 Building World state....\n"
"  > No remote World found\n"
"[2] 🧰 Evaluating Worlds diff....\n"
"  > Total diffs found: 5\n"
"[3] 📦 Preparing for migration....\n"
"  > Total items to be migrated (5): New 5 Update 0\n"
"\n"
"# Executor\n"
"  > Contract address: 0x5c3494b21bc92d40abdc40cdc54af66f22fb92bf876665d982c765a2cc0e06a\n"
"# Base Contract\n"
"  > Class Hash: 0x7aec2b7d7064c1294a339cd90060331ff704ab573e4ee9a1b699be2215c11c9\n"
"# World\n"
"  > Contract address: 0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"# Models (2)\n"
"Moves\n"
"  > Class hash: 0xb37482a660983dfbf65968caa26eab260d3e1077986454b52ac06e58ae20c4\n"
"Position\n"
"  > Class hash: 0x6ffc643cbc4b2fb9c424242b18175a5e142269b45f4463d1cd4dddb7a2e5095\n"
"  > Registered at: 0x3e74b09d320ceb5d4401842bec805489019c04202bc23bc67a385f6e537dce0\n"
"# Contracts (1)\n"
"actions\n"
"  > Contract address: 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a\n"
"\n"
"🎉 Successfully migrated World at address "
"0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"\n"
"✨ Updating manifest.json...\n"
"\n"
"✨ Done.\n"
"\n"
"```"

#: src/cairo/hello-dojo.md:260
msgid "Your 🌎 is now deployed at `0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c`!"
msgstr ""
"¡Su 🌎 ahora está implementado en `0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c`!"

#: src/cairo/hello-dojo.md:262
msgid "This establishes the world address for your project."
msgstr "Esto establece la dirección del World de su proyecto."

#: src/cairo/hello-dojo.md:264
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains environment variables that make "
"running CLI commands in your project a breeze. (Read more about it [here](./config.md)). Make sure your "
"file specifies the version of Dojo you have installed!. In this case version `v0.3.0`"
msgstr ""
"Analicemos el archivo `Scarb.toml` en el proyecto. Este archivo contiene variables de entorno que "
"facilitan la ejecución de comandos CLI en su proyecto. (Lea más sobre esto [aquí](./config.md)). "
"¡Asegúrese de que su archivo especifique la versión de Dojo que ha instalado! En este caso versión "
"`v0.3.0`"

#: src/cairo/hello-dojo.md:266
msgid ""
"```toml\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\", rev = \"v0.3.0\" }\n"
"```"
msgstr ""
"```toml\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\", rev = \"v0.3.0\" }\n"
"```"

#: src/cairo/hello-dojo.md:271
msgid "### Indexing"
msgstr "### Indexación"

#: src/cairo/hello-dojo.md:273
msgid ""
"With your local world address established, let's delve into indexing. You can index the entire world. "
"Open a new terminal and input this simple command:"
msgstr ""
"Una vez establecida su dirección del World local, profundicemos en la indexación. Puedes indexar el "
"World entero. Abra una nueva terminal e ingrese este simple comando:"

#: src/cairo/hello-dojo.md:275
msgid ""
"```bash\n"
"torii --world 0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"```"
msgstr ""
"```bash\n"
"torii --world 0x1af130f7b9027f3748c1e3b10ca4a82ac836a30ac4f2f84025e83a99a922a0c\n"
"```"

#: src/cairo/hello-dojo.md:279
msgid ""
"Running the command mentioned above starts a Torii server on your local machine. This server uses SQLite "
"as its database and is accessible at http://0.0.0.0:8080/graphql. Torii will automatically organize your "
"data into tables, making it easy for you to perform queries using GraphQL. When you run the command, "
"you'll see terminal output that looks something like this:"
msgstr ""
"Al ejecutar el comando mencionado anteriormente se inicia un servidor Torii en su máquina local. Este "
"servidor utiliza SQLite como base de datos y se puede acceder a él en http://0.0.0.0:8080/graphql. Torii "
"organizará automáticamente sus datos en tablas, lo que le facilitará realizar consultas utilizando "
"GraphQL. Cuando ejecute el comando, verá una salida de terminal similar a esta:"

#: src/cairo/hello-dojo.md:281
msgid ""
"```bash\n"
"2023-10-18T06:49:48.184233Z  INFO torii::server: 🚀 Torii listening at http://0.0.0.0:8080\n"
"2023-10-18T06:49:48.184244Z  INFO torii::server: Graphql playground: http://0.0.0.0:8080/graphql\n"
"\n"
"2023-10-18T06:49:48.185648Z  INFO torii_core::engine: processed block: 0\n"
"2023-10-18T06:49:48.186129Z  INFO torii_core::engine: processed block: 1\n"
"2023-10-18T06:49:48.186720Z  INFO torii_core::engine: processed block: 2\n"
"2023-10-18T06:49:48.187202Z  INFO torii_core::engine: processed block: 3\n"
"2023-10-18T06:49:48.187674Z  INFO torii_core::engine: processed block: 4\n"
"2023-10-18T06:49:48.188215Z  INFO torii_core::engine: processed block: 5\n"
"2023-10-18T06:49:48.188611Z  INFO torii_core::engine: processed block: 6\n"
"2023-10-18T06:49:48.188985Z  INFO torii_core::engine: processed block: 7\n"
"2023-10-18T06:49:48.199592Z  INFO torii_core::processors::register_model: Registered model: Moves\n"
"2023-10-18T06:49:48.210032Z  INFO torii_core::processors::register_model: Registered model: Position\n"
"2023-10-18T06:49:48.210571Z  INFO torii_core::engine: processed block: 8\n"
"2023-10-18T06:49:48.211678Z  INFO torii_core::engine: processed block: 9\n"
"2023-10-18T06:49:48.212335Z  INFO torii_core::engine: processed block: 10\n"
"\n"
"```"
msgstr ""
"```bash\n"
"2023-10-18T06:49:48.184233Z  INFO torii::server: 🚀 Torii listening at http://0.0.0.0:8080\n"
"2023-10-18T06:49:48.184244Z  INFO torii::server: Graphql playground: http://0.0.0.0:8080/graphql\n"
"\n"
"2023-10-18T06:49:48.185648Z  INFO torii_core::engine: processed block: 0\n"
"2023-10-18T06:49:48.186129Z  INFO torii_core::engine: processed block: 1\n"
"2023-10-18T06:49:48.186720Z  INFO torii_core::engine: processed block: 2\n"
"2023-10-18T06:49:48.187202Z  INFO torii_core::engine: processed block: 3\n"
"2023-10-18T06:49:48.187674Z  INFO torii_core::engine: processed block: 4\n"
"2023-10-18T06:49:48.188215Z  INFO torii_core::engine: processed block: 5\n"
"2023-10-18T06:49:48.188611Z  INFO torii_core::engine: processed block: 6\n"
"2023-10-18T06:49:48.188985Z  INFO torii_core::engine: processed block: 7\n"
"2023-10-18T06:49:48.199592Z  INFO torii_core::processors::register_model: Registered model: Moves\n"
"2023-10-18T06:49:48.210032Z  INFO torii_core::processors::register_model: Registered model: Position\n"
"2023-10-18T06:49:48.210571Z  INFO torii_core::engine: processed block: 8\n"
"2023-10-18T06:49:48.211678Z  INFO torii_core::engine: processed block: 9\n"
"2023-10-18T06:49:48.212335Z  INFO torii_core::engine: processed block: 10\n"
"\n"
"```"

#: src/cairo/hello-dojo.md:301
msgid ""
"You can observe that our `Moves` and `Position` models have been successfully registered.\n"
"Next, let's use the GraphiQL IDE to retrieve data from the `Moves` model. In your web browser, navigate "
"to `http://0.0.0.0:8080/graphql`, and enter the following query:"
msgstr ""
"Puede observar que nuestros Models `Moves` y `Position` se han registrado correctamente.\n"
"A continuación, usemos el IDE GraphiQL para recuperar datos del Model `Moves`. En su navegador web, "
"navegue hasta `http://0.0.0.0:8080/graphql` e ingrese la siguiente consulta:"

#: src/cairo/hello-dojo.md:304
msgid ""
"```graphql\n"
"query {\n"
"  model(id: \"Moves\") {\n"
"    id\n"
"    name\n"
"    class_hash\n"
"    transaction_hash\n"
"    created_at\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"query {\n"
"  model(id: \"Moves\") {\n"
"    id\n"
"    name\n"
"    class_hash\n"
"    transaction_hash\n"
"    created_at\n"
"  }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:316 src/toolchain/torii/graphql.md:41 src/toolchain/torii/graphql.md:73
msgid "After you run the query, you will receive an output like this:"
msgstr "Después de ejecutar la consulta, recibirá un resultado como este:"

#: src/cairo/hello-dojo.md:318
msgid ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"model\": {\n"
"      \"id\": \"Moves\",\n"
"      \"name\": \"Moves\",\n"
"      \"class_hash\": \"0xb37482a660983dfbf65968caa26eab260d3e1077986454b52ac06e58ae20c4\",\n"
"      \"transaction_hash\": \"\",\n"
"      \"created_at\": \"2023-10-18 06:49:48\"\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"model\": {\n"
"      \"id\": \"Moves\",\n"
"      \"name\": \"Moves\",\n"
"      \"class_hash\": \"0xb37482a660983dfbf65968caa26eab260d3e1077986454b52ac06e58ae20c4\",\n"
"      \"transaction_hash\": \"\",\n"
"      \"created_at\": \"2023-10-18 06:49:48\"\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:332
msgid ""
"Awesome, now let's work with subscriptions to get real-time updates. Let's clean up your workspace on "
"the GraphiQL IDE and input the following subscription:"
msgstr ""
"Genial, ahora trabajemos con las suscripciones para obtener actualizaciones en tiempo real. Limpiemos su "
"espacio de trabajo en GraphiQL IDE e ingresemos la siguiente suscripción:"

#: src/cairo/hello-dojo.md:334
msgid ""
"```graphql\n"
"subscription {\n"
"  entityUpdated {\n"
"    id\n"
"    keys\n"
"    model_names\n"
"    event_id\n"
"    created_at\n"
"    updated_at\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"subscription {\n"
"  entityUpdated {\n"
"    id\n"
"    keys\n"
"    model_names\n"
"    event_id\n"
"    created_at\n"
"    updated_at\n"
"  }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:347
msgid ""
"Once you execute the subscription, you will receive notifications whenever new entities are updated or "
"created. For now, don't make any changes to it and proceed to create a new entity."
msgstr ""
"Una vez que ejecute la suscripción, recibirá notificaciones cada vez que se actualicen o creen nuevas "
"entidades. Por ahora, no le hagas ningún cambio y procede a crear una nueva entidad."

#: src/cairo/hello-dojo.md:349
msgid "To accomplish this, we have to go back to our primary terminal and check the contracts section."
msgstr "Para ello tenemos que volver a nuestro terminal principal y consultar el apartado de contratos."

#: src/cairo/hello-dojo.md:351
msgid ""
"```bash\n"
"# Contracts (1)\n"
"actions\n"
"  > Contract address: 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a\n"
"```"
msgstr ""
"```bash\n"
"# Contracts (1)\n"
"actions\n"
"  > Contract address: 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a\n"
"```"

#: src/cairo/hello-dojo.md:357
msgid ""
"We have to use `actions` contract address to start to create entities. In your main local terminal, run "
"the following command:"
msgstr ""
"Tenemos que usar la dirección del contrato de `actions` para comenzar a crear entidades. En su terminal "
"local principal, ejecute el siguiente comando:"

#: src/cairo/hello-dojo.md:359
msgid ""
"```bash\n"
"sozo execute 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a spawn\n"
"```"
msgstr ""
"```bash\n"
"sozo execute 0x69a474a39b11d05c07bb9090fd1961b8e1c87aa5643e7b97087cb0c7620356a spawn\n"
"```"

#: src/cairo/hello-dojo.md:363
msgid ""
"By running this command, you've activated the spawn system, resulting in the creation of a new entity. "
"This action establishes a local world that you can interact with."
msgstr ""
"Al ejecutar este comando, ha activado el sistema de generación, lo que resulta en la creación de una "
"nueva entidad. Esta acción establece un World local con el que puedes interactuar."

#: src/cairo/hello-dojo.md:365
msgid ""
"Now, go back to your GraphiQL IDE, and you will notice that you have received the subscription's "
"results, which should look something like this:"
msgstr ""
"Ahora, regrese a su IDE GraphiQL y notará que ha recibido los resultados de la suscripción, que deberían "
"verse así:"

#: src/cairo/hello-dojo.md:367
msgid ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves\",\n"
"      \"event_id\": "
"\"0x000000000000000000000000000000000000000000000000000000000000000b:0x0000:0x0000\",\n"
"      \"created_at\": \"2023-10-18 06:53:12\",\n"
"      \"updated_at\": \"2023-10-18 06:53:12\"\n"
"    }\n"
"  }\n"
"}\n"
"--------------------------------------------------------------------------------------------------------\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves,Position\",\n"
"      \"event_id\": "
"\"0x000000000000000000000000000000000000000000000000000000000000000b:0x0000:0x0001\",\n"
"      \"created_at\": \"2023-10-18 06:53:12\",\n"
"      \"updated_at\": \"2023-10-18 06:53:12\"\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves\",\n"
"      \"event_id\": "
"\"0x000000000000000000000000000000000000000000000000000000000000000b:0x0000:0x0000\",\n"
"      \"created_at\": \"2023-10-18 06:53:12\",\n"
"      \"updated_at\": \"2023-10-18 06:53:12\"\n"
"    }\n"
"  }\n"
"}\n"
"--------------------------------------------------------------------------------------------------------\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves,Position\",\n"
"      \"event_id\": "
"\"0x000000000000000000000000000000000000000000000000000000000000000b:0x0000:0x0001\",\n"
"      \"created_at\": \"2023-10-18 06:53:12\",\n"
"      \"updated_at\": \"2023-10-18 06:53:12\"\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:399
msgid ""
"In the GraphiQL IDE, by clicking the `DOCS`-button on the right, you can open the API documentation. "
"This documentation is auto-generated based on our schema definition and displays all API operations and "
"data types of our schema.. In order to know more about query and subscription, you can jump to [GraphQL]"
"(../toolchain/torii/graphql.md) section.\n"
"We've covered quite a bit! Here's a recap:"
msgstr ""
"En GraphiQL IDE, al hacer clic en el botón `DOCS` a la derecha, puede abrir la documentación de la API. "
"Esta documentación se genera automáticamente en función de nuestra definición de esquema y muestra todas "
"las operaciones API y tipos de datos de nuestro esquema. Para saber más sobre consultas y suscripción, "
"puede ir a [GraphQL](../toolchain/torii/graphql .md) sección.\n"
"¡Hemos cubierto bastante! Aquí hay un resumen:"

#: src/cairo/hello-dojo.md:402
msgid ""
"- Built a Dojo world\n"
"- Deployed the project to Katana\n"
"- Indexed the world with Torii\n"
"- Ran the spawn system locally\n"
"- Interacted with GraphQL"
msgstr ""
"- Construyó un World en Dojo\n"
"- Implementé el proyecto en Katana.\n"
"- Indexado el World con Torii.\n"
"- Ejecuté el sistema de generación localmente.\n"
"- Interactuado con GraphQL"

#: src/cairo/hello-dojo.md:408
msgid "### Next Steps"
msgstr "### Próximos pasos"

#: src/cairo/hello-dojo.md:410
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the potential of these worlds is "
"vast! Designed to manage hundreds of systems and components, Dojo is equipped for expansive creativity. "
"So, what will you craft next?"
msgstr ""
"Esta descripción general proporciona una visión rápida de principio a fin de Dojo. Sin embargo, ¡El "
"potencial de estos Worlds es enorme! Diseñado para gestionar cientos de Systems y componentes, Dojo está "
"equipado para una creatividad expansiva. Entonces, ¿qué vas a crear a continuación?"

#: src/cairo/entities.md:1
msgid "## Entities"
msgstr "## Entidades"

#: src/cairo/entities.md:3
msgid "> Entities are the primary key value within the world, to which components can be attached."
msgstr ""
"> Las entidades son el valor clave principal dentro del World, al que se pueden adjuntar componentes."

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are treated as a primary key "
"value within the world, to which components can be attached. To illustrate this concept, consider a "
"simple example of a character in a game that has a `Moves` and a `Position` component."
msgstr ""
"Los diferentes Systems ECS manejan entidades de diversas maneras. En Dojo, las entidades se tratan como "
"un valor de clave principal dentro del World, al que se pueden adjuntar componentes. Para ilustrar este "
"concepto, considere un ejemplo simple de un personaje en un juego que tiene un componente `Moves` y "
"`Position`."

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that we do not reference the "
"entity directly. Instead, we simply provide two structs that the entity will contain. "
msgstr ""
"Al definir los componentes de esta entidad, es importante tener en cuenta que no hacemos referencia a la "
"entidad directamente. En lugar de eso, simplemente proporcionamos dos estructuras que contendrá la "
"entidad. "

#: src/cairo/entities.md:9
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Moves {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    remaining: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    player: ContractAddress,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"```"

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that we have not explicitly "
"defined an Entity anywhere. Instead, we use the `ctx.origin` to reference the current entity."
msgstr ""
"Ahora, creemos un `Spawn` para el personaje. Es importante tener en cuenta que no hemos definido "
"explícitamente una Entidad en ninguna parte. En su lugar, usamos `ctx.origin` para hacer referencia a la "
"entidad actual."

#: src/cairo/entities.md:28
msgid "In this example we are using the `ctx.origin` to reference the current entity."
msgstr "En este ejemplo estamos usando `ctx.origin` para hacer referencia a la entidad actual."

#: src/cairo/entities.md:30
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawn {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Moves;\n"
"\n"
"    fn execute(ctx: Context) {\n"
"        let position = get!(ctx.world, ctx.origin, (Position));\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Moves {\n"
"                    player: ctx.origin, remaining: 10\n"
"                    }, Position {\n"
"                    player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"                },\n"
"            )\n"
"        );\n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/entities.md:58
msgid ""
"> ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-FAQ](https://github.com/"
"SanderMertens/ecs-faq)"
msgstr ""
"> Teoría de ECS: Se ha escrito mucho sobre los Systems ECS; para profundizar, lea [ECS-FAQ](https://"
"github.com/SanderMertens/ecs-faq)"

#: src/cairo/testing.md:1
msgid "## Testing"
msgstr "## Testing"

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides a testing framework that "
"allows you to write tests for your smart contracts. Since Dojo uses a custom compiler, you need to use "
"`sozo` to test your contracts."
msgstr ""
"Las pruebas son una parte crucial de cualquier proceso de desarrollo de software. Dojo proporciona un "
"marco de prueba que le permite escribir pruebas para sus smart contract. Dado que Dojo usa un compilador "
"personalizado, necesitas usar `sozo` para probar tus contratos."

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr "Desde el directorio de su proyecto, simplemente:"

#: src/cairo/testing.md:7
msgid ""
"```shell\n"
"sozo test\n"
"```"
msgstr ""
"```shell\n"
"sozo test\n"
"```"

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr "Esto buscará todas las pruebas dentro de su proyecto y las ejecutará."

#: src/cairo/testing.md:14
msgid "### Writing Unit Tests"
msgstr "### Escritura de Tests Unitarios"

#: src/cairo/testing.md:16
msgid "It is best practise to include unit tests in the same file as the model/System you are writing."
msgstr ""
"Se recomienda incluir pruebas unitarias en el mismo archivo que el Model/Sistema que está escribiendo."

#: src/cairo/testing.md:18
msgid ""
"Lets show a `model` test example from the [dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr ""
"Mostremos un ejemplo de test de `model` de [dojo-starter] (https://github.com/dojoengine/dojo-starter):"

#: src/cairo/testing.md:20
msgid "`models.cairo`"
msgstr "`models.cairo`"

#: src/cairo/testing.md:21
msgid ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"...rest of code\n"
"\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use debug::PrintTrait;\n"
"    use super::{Position, PositionTrait};\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_zero() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), 'not zero');\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(100000)]\n"
"    fn test_position_is_equal() {\n"
"        let player = starknet::contract_address_const::<0x0>();\n"
"        let position = Position { player, x: 420, y: 0 };\n"
"        position.print();\n"
"        assert(PositionTrait::is_equal(position, Position { player, x: 420, y: 0 }), 'not equal');\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the `Position` model. It is good "
"practise to test all functions of your models."
msgstr ""
"En esta prueba estamos probando las funciones `is_zero` y `is_equal` del Model `Position`. Es una buena "
"práctica probar todas las funciones de sus Models."

#: src/cairo/testing.md:52
msgid "### Writing Integration Tests"
msgstr "### Redacción de Tests de Integración"

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write integration tests for your "
"world by creating a `tests` directory in your project root. Then create a file for each integration test "
"you want to write."
msgstr ""
"Los tests de integración son tests e2e que prueban todo el sistema. Puede escribir pruebas de "
"integración para su World creando un directorio `tests` en la raíz de su proyecto. Luego cree un archivo "
"para cada prueba de integración que desee escribir."

#: src/cairo/testing.md:56
msgid "This is the example from the [dojo-starter](https://github.com/dojoengine/dojo-starter):"
msgstr "Este es el ejemplo de [dojo-starter](https://github.com/dojoengine/dojo-starter):"

#: src/cairo/testing.md:58
msgid "`move.cairo`"
msgstr "`move.cairo`"

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use dojo::world::{IWorldDispatcherTrait, IWorldDispatcher};\n"
"    use dojo::test_utils::{spawn_test_world, deploy_contract};\n"
"    use dojo_examples::models::{position, moves};\n"
"    use dojo_examples::models::{Position, Moves, Direction};\n"
"    \n"
"    use super::{\n"
"        IPlayerActionsDispatcher, IPlayerActionsDispatcherTrait,\n"
"        player_actions_external as player_actions\n"
"    };\n"
"\n"
"    //OFFSET is defined in constants.cairo\n"
"    use dojo_examples::constants::OFFSET;\n"
"\n"
"    //{Event and Moved are defined in events.cairo}\n"
"    #[event]\n"
"    use dojo_examples::events::{Event, Moved};\n"
"\n"
"    // helper setup function\n"
"    // reusable function for tests\n"
"    fn setup_world() -> IPlayerActionsDispatcher {\n"
"        // components\n"
"        let mut models = array![position::TEST_CLASS_HASH, moves::TEST_CLASS_HASH];\n"
"\n"
"         // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"        \n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', player_actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let player_actions_system = IPlayerActionsDispatcher { contract_address };\n"
"\n"
"        player_actions_system\n"
"    }\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        // caller\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        let player_actions_system = setup_world();\n"
"        \n"
"         // System calls\n"
"        player_actions_system.spawn();\n"
"        player_actions_system.move(Direction::Right(()));\n"
"\n"
"        // check moves\n"
"        let moves = get!(world, caller, (Moves));\n"
"        assert(moves.remaining == 99, 'moves is wrong');\n"
"\n"
"        // check position\n"
"        let new_position = get!(world, caller, (Position));\n"
"        assert(new_position.x == (OFFSET + 1).try_into().unwrap(), 'position x is wrong');\n"
"        assert(new_position.y == OFFSET.try_into().unwrap(), 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use dojo::world::{IWorldDispatcherTrait, IWorldDispatcher};\n"
"    use dojo::test_utils::{spawn_test_world, deploy_contract};\n"
"    use dojo_examples::models::{position, moves};\n"
"    use dojo_examples::models::{Position, Moves, Direction};\n"
"    \n"
"    use super::{\n"
"        IPlayerActionsDispatcher, IPlayerActionsDispatcherTrait,\n"
"        player_actions_external as player_actions\n"
"    };\n"
"\n"
"    //OFFSET is defined in constants.cairo\n"
"    use dojo_examples::constants::OFFSET;\n"
"\n"
"    //{Event and Moved are defined in events.cairo}\n"
"    #[event]\n"
"    use dojo_examples::events::{Event, Moved};\n"
"\n"
"    // helper setup function\n"
"    // reusable function for tests\n"
"    fn setup_world() -> IPlayerActionsDispatcher {\n"
"        // components\n"
"        let mut models = array![position::TEST_CLASS_HASH, moves::TEST_CLASS_HASH];\n"
"\n"
"         // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"        \n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', player_actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let player_actions_system = IPlayerActionsDispatcher { contract_address };\n"
"\n"
"        player_actions_system\n"
"    }\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        // caller\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        let player_actions_system = setup_world();\n"
"        \n"
"         // System calls\n"
"        player_actions_system.spawn();\n"
"        player_actions_system.move(Direction::Right(()));\n"
"\n"
"        // check moves\n"
"        let moves = get!(world, caller, (Moves));\n"
"        assert(moves.remaining == 99, 'moves is wrong');\n"
"\n"
"        // check position\n"
"        let new_position = get!(world, caller, (Position));\n"
"        assert(new_position.x == (OFFSET + 1).try_into().unwrap(), 'position x is wrong');\n"
"        assert(new_position.y == OFFSET.try_into().unwrap(), 'position y is wrong');\n"
"    }\n"
"}\n"
"```"

#: src/cairo/testing.md:121
msgid "#### Useful Dojo Test Functions"
msgstr "#### Funciones útiles de Test de Dojo"

#: src/cairo/testing.md:123
msgid ""
"`spawn_test_world(models, systems)` - This function will create a test world with the models and systems "
"you pass in. It will also deploy the world and register the models and systems."
msgstr ""
"`spawn_test_world(models, systems)`: esta función creará un World de prueba con los Models y Systems que "
"ingrese. También implementará el World y registrará los Models y Systems."

#: src/cairo/modules.md:1
msgid "## Dojo Modules"
msgstr "## Módulos Dojo"

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module architecture for Dojo. This allows "
"us to create reusable modules that can be used in any Dojo world."
msgstr ""
"Con la estandarización de Systems y Componentes podemos crear una arquitectura de módulo para Dojo. Esto "
"nos permite crear módulos reutilizables que se pueden usar en cualquier World Dojo."

#: src/cairo/modules.md:5
msgid "### Module Architecture"
msgstr "### Arquitectura del Módulo"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and share functionality. Modules "
"are a collection of Systems and Components that can be imported into a Dojo world. Dojo is following the "
"ERC patterns and has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""
"Piense en los módulos como ERC para Dojo. Son una forma estándar de crear y compartir funciones. Los "
"módulos son una colección de Systems y componentes que se pueden importar a un World Dojo. Dojo sigue "
"los patrones de ERC y ya tiene módulos definidos para ERC20, ERC721 y ERC1155."

#: src/cairo/modules/erc20.md:1
msgid "## ERC20"
msgstr "## ERC20"

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token standard, but it utilizes Dojo "
"Systems and Components. This allows us to leverage the excellent properties of the ERC20 standard and "
"use it natively within the Dojo environment."
msgstr ""
"El módulo ERC20 de Dojo es una implementación estándar del estándar de token ERC20, pero utiliza Systems "
"y componentes de Dojo. Esto nos permite aprovechar las excelentes propiedades del estándar ERC20 y "
"utilizarlo de forma nativa dentro del entorno Dojo."

#: src/cairo/modules/erc20.md:5
msgid "### Integration into Your World"
msgstr "### Integración en Tu World"

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the ERC20 Dojo contract. "
"Subsequently, install the systems and components into your world."
msgstr ""
"Para integrar el módulo ERC20 en su World, primero debe implementar el contrato ERC20 Dojo. "
"Posteriormente, instale los Systems y componentes en su World."

#: src/client/overview.md:1
msgid "# Overview"
msgstr "# Descripción General"

#: src/client/overview.md:3
msgid "Dojo is BYO client, meaning that you can use any client you want to connect to the Dojo network."
msgstr ""
"Dojo es un cliente BYO, lo que significa que puede utilizar cualquier cliente que desee para conectarse "
"a la red Dojo."

#: src/client/overview.md:5
msgid ""
"- [npm](./npm.md)\n"
"- [torii](torii.md)"
msgstr ""
"- [npm](./npm.md)\n"
"- [torii](torii.md)"

#: src/client/overview.md:8
msgid ""
"> Dojo is always looking to expand these clients, if you would like to contribute reach out into the "
"[Discord](https://discord.gg/KG9w9BmDrV) "
msgstr ""
"> Dojo siempre está buscando expandir estos clientes, si desea contribuir, comuníquese con [Discord]"
"(https://discord.gg/KG9w9BmDrV) "

#: src/client/npm.md:1
msgid "# Javascript Libraries"
msgstr "# Bibliotecas Javascript"

#: src/client/npm.md:3
msgid ""
"> Javascript is a great way to get started with Dojo. It's easy to use, and you can get started in "
"minutes."
msgstr ""
"> Javascript es una excelente manera de comenzar con Dojo. Es fácil de usar y puede comenzar en minutos."

#: src/client/npm.md:5
msgid "### Examples using these:"
msgstr "### Ejemplos que usan estos:"

#: src/client/npm.md:7
msgid ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""
"- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)\n"
"- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#: src/client/npm.md:10
msgid "### @dojoengine/core"
msgstr "### @dojoengine/core"

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream libraries. It contains the core "
"functionality of Dojo and exposes the contract interfaces. Use it if you want to build your own library "
"on top of Dojo."
msgstr ""
"Esta es la biblioteca de nivel más bajo y la utilizan todas las demás bibliotecas posteriores. Contiene "
"la funcionalidad principal de Dojo y expone las interfaces del contrato. Úselo si desea construir su "
"propia biblioteca sobre Dojo."

#: src/client/npm.md:14
msgid "[Repository](https://github.com/dojoengine/packages/tree/main/packages/core)"
msgstr "[Repository](https://github.com/dojoengine/packages/tree/main/packages/core)"

#: src/client/npm.md:16
msgid ""
"```console\n"
"bun add @dojoengine/core\n"
"```"
msgstr ""
"```console\n"
"bun add @dojoengine/core\n"
"```"

#: src/client/npm.md:20
msgid "### @dojoengine/create-burner"
msgstr "### @dojoengine/create-burner"

#: src/client/npm.md:22
msgid "Create burner is a simple way to incorporate burner wallets into your Dojo app."
msgstr "Crear burner es una forma sencilla de incorporar carteras quemadoras en su aplicación Dojo."

#: src/client/npm.md:24
msgid "[Repository](https://github.com/dojoengine/packages/tree/main/packages/create-burner)"
msgstr "[Repository](https://github.com/dojoengine/packages/tree/main/packages/create-burner)"

#: src/client/npm.md:26
msgid ""
"```console\n"
"bun add @dojoengine/create-burner\n"
"```"
msgstr ""
"```console\n"
"bun add @dojoengine/create-burner\n"
"```"

#: src/client/npm.md:30
msgid "### @dojoengine/utils"
msgstr "### @dojoengine/utils"

#: src/client/npm.md:32
msgid "These are utils for helping with interfacing dojo."
msgstr "Estas son utilidades para ayudar con la interfaz de dojo."

#: src/client/npm.md:34
msgid "[Reopsitory](https://github.com/dojoengine/packages/tree/main/packages/utils)"
msgstr "[Repository](https://github.com/dojoengine/packages/tree/main/packages/utils)"

#: src/client/npm.md:36
msgid ""
"```console\n"
"bun add @dojoengine/utils\n"
"```"
msgstr ""
"```console\n"
"bun add @dojoengine/utils\n"
"```"

#: src/client/npm/core.md:1
msgid "# Core"
msgstr "# Core"

#: src/client/torii.md:1
msgid "## Torii Client"
msgstr "## Cliente Torii"

#: src/client/torii.md:3
msgid ""
"Torii client is a rust client for interacting with Dojo worlds. It can be compiled to wasm to be used in "
"JS clients, or can used directly in Rust clients or other lower level languages with bindings."
msgstr ""
"El cliente Torii es un cliente Rust para interactuar con los Worlds Dojo. Se puede compilar en wasm para "
"usarlo en clientes JS, o puede usarse directamente en clientes Rust u otros lenguajes de nivel inferior "
"con enlaces."

#: src/client/torii.md:5
msgid "### Usage in Rust projects"
msgstr "### Uso en proyectos de Rust"

#: src/client/torii.md:7
msgid "__@kairy__"
msgstr "__@kairy__"

#: src/client/torii.md:9
msgid "### Usage in JS Clients"
msgstr "### Usage in JS Clients"

#: src/toolchain/dojoup.md:1
msgid "# `dojoup`"
msgstr "# `dojoup`"

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr "Actualice o vuelva a una rama de Dojo específica con facilidad."

#: src/toolchain/dojoup.md:5
msgid "## Installing"
msgstr "## Instalando"

#: src/toolchain/dojoup.md:11
msgid "## Usage"
msgstr "## Uso"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr "Para instalar la última versión **estable**:"

#: src/toolchain/dojoup.md:18
msgid "> Note: You may have to install `jq` to use `dojoup`. You can do so with the following commands:"
msgstr ""
"> Nota: Es posible que tengas que instalar `jq` para usar `dojoup`. Puedes hacerlo con los siguientes "
"comandos:"

#: src/toolchain/dojoup.md:20
msgid ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"
msgstr ""
"```sh   \n"
"# Debian\n"
"sudo apt-get install jq\n"
"\n"
"# Mac\n"
"brew install jq\n"
"```"

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr "Para instalar una **versión** específica (en este caso, la versión `nightly`):"

#: src/toolchain/dojoup.md:30
msgid ""
"```sh\n"
"dojoup --version nightly\n"
"```"
msgstr ""
"```sh\n"
"dojoup --version nightly\n"
"```"

#: src/toolchain/dojoup.md:34
msgid "To install a specific **branch** (in this case the `release/0.1.0` branch's latest commit):"
msgstr ""
"Para instalar una **rama** específica (en este caso, la última confirmación de la rama `release/0.1.0`):"

#: src/toolchain/dojoup.md:36
msgid ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"
msgstr ""
"```sh\n"
"dojoup --branch release/0.1.0\n"
"```"

#: src/toolchain/dojoup.md:40
msgid "To install a **fork's main branch** (in this case `tarrencev/dojo`'s main branch):"
msgstr ""
"Para instalar una **rama principal de la bifurcación** (en este caso, la rama principal de `tarrencev/"
"dojo`):"

#: src/toolchain/dojoup.md:42
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo\n"
"```"

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` branch's latest commit in "
"`tarrencev/dojo`):"
msgstr ""
"Para instalar una **rama específica en una bifurcación** (en este caso, la última confirmación de la "
"rama `patch-10` en `tarrencev/dojo`):"

#: src/toolchain/dojoup.md:48
msgid ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"
msgstr ""
"```sh\n"
"dojoup --repo tarrencev/dojo --branch patch-10\n"
"```"

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr "Para instalar desde una **Pull Request específica**:"

#: src/toolchain/dojoup.md:54
msgid ""
"```sh\n"
"dojoup --pr 1071\n"
"```"
msgstr ""
"```sh\n"
"dojoup --pr 1071\n"
"```"

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr "Para instalar desde una **commit específico**:"

#: src/toolchain/dojoup.md:60
msgid ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"
msgstr ""
"```sh\n"
"dojoup -C 94bfdb2\n"
"```"

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/dojo`, assuming you're in the "
"home directory)"
msgstr ""
"Para instalar un directorio o repositorio local (por ejemplo, uno ubicado en `~/git/dojo`, suponiendo "
"que esté en el directorio de inicio)"

#: src/toolchain/dojoup.md:66
msgid "##### Note: --branch, --repo, and --version flags are ignored during local installations."
msgstr ""
"##### Nota: Los indicadores --branch, --repo y --version se ignoran durante las instalaciones locales."

#: src/toolchain/dojoup.md:68
msgid ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"
msgstr ""
"```sh\n"
"dojoup --path ./git/dojo\n"
"```"

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use `-v` instead of `--"
"version`, etc."
msgstr ""
"**Consejo**: ¡Todas las banderas tienen un equivalente taquigráfico de un solo carácter! Puede usar `-v` "
"en lugar de `--version`, etc."

#: src/toolchain/dojoup.md:78
msgid "### Precompiled binaries"
msgstr "### Binarios precompilados"

#: src/toolchain/dojoup.md:80
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://github.com/dojoengine/dojo/"
"releases).\n"
"These are better managed by using [Dojoup](#using-dojoup)."
msgstr ""
"Los archivos binarios precompilados están disponibles en la [página de releases de GitHub] (https://"
"github.com/dojoengine/dojo/releases).\n"
"Estos se gestionan mejor utilizando [Dojoup](#using-dojoup)."

#: src/toolchain/dojoup.md:84
msgid ""
"> ℹ️ **Note**\n"
">\n"
"> If you're on Windows, you will need to install and use [Git BASH](https://gitforwindows.org/) or [WSL]"
"(https://learn.microsoft.com/en-us/windows/wsl/install),\n"
"> as your terminal, since Dojoup currently does not support Powershell or Cmd."
msgstr ""
"> ℹ️ **Nota**\n"
">\n"
"> Si estás en Windows, necesitarás instalar y usar [Git BASH](https://gitforwindows.org/) o [WSL]"
"(https://learn.microsoft.com/en-us/windows/ wsl/instalar),\n"
"> como su terminal, ya que Dojoup actualmente no es compatible con Powershell o Cmd."

#: src/toolchain/sozo/overview.md:1
msgid "## Sozo"
msgstr "## Sozo"

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It helps with everything from "
"scaffolding a new project, all the way to deploying and interacting with your Dojo Worlds. It includes a "
"migration planning tool, designed to streamline the updating and deployment of AWs. It provides a robust "
"command-line interface (CLI) that simplifies World management tasks, enabling you to focus on the "
"creative aspects of World-building. In the future, it may include a GUI."
msgstr ""
"`sozo` es una poderosa herramienta todo en uno para gestionar sus proyectos Dojo. Ayuda con todo, desde "
"la preparación de un nuevo proyecto hasta la implementación e interacción con sus Dojo Worlds. Incluye "
"una herramienta de planificación de migración, diseñada para agilizar la actualización y la "
"implementación de AWs. Proporciona una sólida interfaz de línea de comandos (CLI) que simplifica las "
"tareas de gestión de Worlds, permitiéndole centrarse en los aspectos creativos de la construcción de "
"Worlds. En el futuro, puede incluir una GUI."

#: src/toolchain/sozo/overview.md:5
msgid "## Features"
msgstr "## Características"

#: src/toolchain/sozo/overview.md:7
msgid ""
"-   **Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy management of your Worlds, "
"whether you're updating existing ones or deploying new ones."
msgstr ""
"-  **CLI Binaria**: Sozo proporciona una CLI binaria intuitiva, lo que garantiza una fácil "
"administración de tus Worlds, ya sea que estés actualizando los existentes o implementando otros nuevos."

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10 src/toolchain/torii/overview.md:14
msgid "## Installation"
msgstr "## Instalación"

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-start.md), our dedicated "
"installation package manager."
msgstr ""
"El binario `sozo` se puede instalar a través de [`dojoup`](../../getting-started/quick-start.md), "
"nuestro administrador de paquetes de instalación dedicado."

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
msgid "### Installing from Source"
msgstr "### Instalación desde la fuente"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"

#: src/toolchain/sozo/overview.md:21
msgid "This will install Sozo and the required dependencies on your local system."
msgstr "Esto instalará Sozo y las dependencias necesarias en su sistema local."

#: src/toolchain/sozo/overview.md:23
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`sozo` Reference](./reference.md) for a complete overview of all the available subcommands."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`sozo` Reference](./reference.md) para obtener una descripción completa de todos los "
"subcomandos disponibles."

#: src/toolchain/sozo/reference.md:1
msgid "## sozo reference"
msgstr "## Referencia sozo"

#: src/toolchain/sozo/reference.md:3
msgid "### Project Commands"
msgstr "### Comandos del Proyecto"

#: src/toolchain/sozo/reference.md:5
msgid ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"
msgstr ""
"-   [init](./project-commands/init.md)\n"
"-   [build](./project-commands/build.md)\n"
"-   [test](./project-commands/test.md)\n"
"-   [migrate](./project-commands/migrate.md)"

#: src/toolchain/sozo/reference.md:10
msgid "### World Commands"
msgstr "### Comandos de World"

#: src/toolchain/sozo/reference.md:12
msgid ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"
msgstr ""
"-   [execute](./world-commands/execute.md)\n"
"-   [register](./world-commands/register.md)\n"
"-   [system](./world-commands/system.md)\n"
"-   [component](./world-commands/component.md)\n"
"-   [events](./world-commands/events.md)\n"
"-   [auth](./world-commands/auth.md)"

#: src/toolchain/sozo/project-commands/init.md:1
msgid "## sozo init"
msgstr "## sozo init"

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project in the current directory by "
"cloning the [dojo-starter](https://github.com/dojoengine/dojo-starter)."
msgstr ""
"`init` se utiliza para inicializar un nuevo proyecto. Inicializará un nuevo proyecto en el directorio "
"actual clonando [dojo-starter](https://github.com/dojoengine/dojo-starter)."

#: src/toolchain/sozo/project-commands/init.md:5 src/tutorial/onchain-chess/0-setup.md:21
msgid ""
"```sh\n"
"sozo init\n"
"```"
msgstr ""
"```sh\n"
"sozo init\n"
"```"

#: src/toolchain/sozo/project-commands/build.md:1
msgid "## sozo build"
msgstr "## sozo build"

#: src/toolchain/sozo/project-commands/build.md:3
msgid "`build` is used to compile the cairo contracts, generating the necessary artifacts for deployment."
msgstr ""
"`build` se utiliza para compilar los contratos de Cairo, generando los artefactos necesarios para la "
"implementación."

#: src/toolchain/sozo/project-commands/build.md:5 src/tutorial/onchain-chess/0-setup.md:39
msgid ""
"```sh\n"
"sozo build\n"
"```"
msgstr ""
"```sh\n"
"sozo build\n"
"```"

#: src/toolchain/sozo/project-commands/test.md:1
msgid "## sozo test"
msgstr "## sozo test"

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests found within the project."
msgstr ""
"`test` se utiliza para probar los contratos de Cairo del proyecto. Ejecutará todas las pruebas "
"encontradas dentro del proyecto."

#: src/toolchain/sozo/project-commands/test.md:5
msgid ""
"```sh\n"
"sozo test\n"
"```"
msgstr ""
"```sh\n"
"sozo test\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:1
msgid "## sozo migrate"
msgstr "## sozo migrate"

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring and deploying contracts as "
"necessary to deploy or update the World."
msgstr ""
"`migrate` se utiliza para realizar el proceso de migración (implementación), declarando e implementando "
"contratos según sea necesario para implementar o actualizar el World."

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be pushed to the remote "
"counterpart by running `sozo migrate --world <WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of "
"the remote World. In the background, `migrate` will compute the diffs of the local and remote World, "
"then, start constructing a migration strategy to determine, if any, which part of the local World needs "
"to be pushed upstream."
msgstr ""
"Los cambios realizados en el World local después de la implementación inicial se pueden enviar "
"fácilmente a la contraparte remota ejecutando `sozo migrate --world <WORLD_ADDRESS>` siendo "
"`WORLD_ADDRESS` la dirección del World remoto. En segundo plano, `migrate` calculará las diferencias "
"entre el World local y remoto, luego comenzará a construir una estrategia de migración para determinar, "
"si corresponde, qué parte del World local necesita ser impulsada hacia arriba."

#: src/toolchain/sozo/project-commands/migrate.md:7 src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5 src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7 src/toolchain/torii/graphql.md:13
msgid "### USAGE"
msgstr "### USO"

#: src/toolchain/sozo/project-commands/migrate.md:9
msgid ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate [OPTIONS]\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:13 src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43 src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:152 src/toolchain/torii/reference.md:33
msgid "### OPTIONS"
msgstr "### OPCIONES"

#: src/toolchain/sozo/project-commands/migrate.md:15 src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:154 src/toolchain/torii/reference.md:35
msgid "#### General Options"
msgstr "#### Opciones Generales"

#: src/toolchain/sozo/project-commands/migrate.md:17
msgid ""
"`--name` _NAME_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Name of the World. At the moment, the only usage for this option is to be used "
"as a salt when deploying the World contract to avoid address conflicts. This option is **required** when "
"performing the initial migration of the World."
msgstr ""
"`--name` _NAME_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Nombre del World. Por el momento, el único uso de esta opción es como sal al "
"implementar el contrato mundial para evitar conflictos de direcciones. Esta opción es **obligatoria** al "
"realizar la migración inicial del World."

#: src/toolchain/sozo/project-commands/migrate.md:20 src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45 src/toolchain/sozo/world-commands/component.md:63
msgid "#### World Options"
msgstr "#### Opciones de World"

#: src/toolchain/sozo/project-commands/migrate.md:22 src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47 src/toolchain/sozo/world-commands/component.md:65
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The address of the World contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""
"`--world` _WORLD_ADDRESS_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;La dirección del contrato del World.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:26 src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51 src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:198
msgid "#### Starknet Options"
msgstr "#### Opciones de Starknet"

#: src/toolchain/sozo/project-commands/migrate.md:28 src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53 src/toolchain/sozo/world-commands/component.md:71
msgid ""
"`--rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet RPC endpoint. [default: http://localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"
msgstr ""
"`--rpc-url` _URL_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El punto final RPC de Starknet. [predeterminado: http://localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"

#: src/toolchain/sozo/project-commands/migrate.md:32 src/toolchain/sozo/world-commands/execute.md:33
msgid "#### Account Options"
msgstr "#### Opciones de Cuenta"

#: src/toolchain/sozo/project-commands/migrate.md:34 src/toolchain/sozo/world-commands/execute.md:35
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The Starknet account address.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;La dirección de la cuenta de Starknet.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:38 src/toolchain/sozo/world-commands/execute.md:39
msgid "#### Signer Options - Raw"
msgstr "#### Opciones del Signer - Raw"

#: src/toolchain/sozo/project-commands/migrate.md:40 src/toolchain/sozo/world-commands/execute.md:41
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The raw private key associated with the account contract.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"
msgstr ""
"`--private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;La clave privada sin procesar asociada con el contrato de cuenta.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"

#: src/toolchain/sozo/project-commands/migrate.md:44 src/toolchain/sozo/world-commands/execute.md:45
msgid "#### Signer Options - Keystore"
msgstr "#### Opciones del Signer - Keystore"

#: src/toolchain/sozo/project-commands/migrate.md:46 src/toolchain/sozo/world-commands/execute.md:47
msgid ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Use the keystore in the given folder or file."
msgstr ""
"`--keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Utilice el keystore en la carpeta o archivo indicado."

#: src/toolchain/sozo/project-commands/migrate.md:49 src/toolchain/sozo/world-commands/execute.md:50
msgid ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The keystore password. Used with --keystore.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""
"`--password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;La contraseña del keystore. Usado con --keystore.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"

#: src/toolchain/sozo/project-commands/migrate.md:53 src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57 src/toolchain/katana/reference.md:245
msgid "### EXAMPLES"
msgstr "## EJEMPLOS"

#: src/toolchain/sozo/project-commands/migrate.md:55
msgid "1. Deploying your World for the first time to a local Katana node"
msgstr "1. Implementar tu World por primera vez en un nodo Katana local"

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:61
msgid "2. Updating a remote World after making some changes"
msgstr "2. Actualizar un World remoto después de realizar algunos cambios"

#: src/toolchain/sozo/project-commands/migrate.md:63
msgid ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate --world 0x123456\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:1
msgid "## sozo execute"
msgstr "## sozo execute"

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr "`execute` se utiliza para ejecutar el sistema de un World."

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, `execute` expects an account "
"address as well as its respective private key in order to sign the transaction before sending it."
msgstr ""
"Realizar una ejecución del sistema requiere enviar una transacción, por lo tanto, `execute` espera una "
"dirección de cuenta así como su respectiva clave privada para poder firmar la transacción antes de "
"enviarla."

#: src/toolchain/sozo/world-commands/execute.md:9
msgid ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"sozo execute <SYSTEM> [OPTIONS]\n"
"```"

#: src/toolchain/sozo/world-commands/execute.md:17
msgid ""
"`--calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The calldata to be passed to the system that you want to execute.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;Comma separated values e.g., 0x12345,0x69420."
msgstr ""
"`--calldata` _CALLDATA_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Los datos de llamada que se pasarán al sistema que desea ejecutar.\n"
"&nbsp;&nbsp;&nbsp;&nbsp;Valores separados por comas, por ejemplo, 0x12345,0x69420."

#: src/toolchain/sozo/world-commands/execute.md:56
msgid "1. Executing the _position_ system which takes two values (_x_: 0x77 and _y_: 0x44)"
msgstr "1. Ejecutando el sistema _position_ el cual toma dos valores (_x_: 0x77 y _y_: 0x44)"

#: src/toolchain/sozo/world-commands/execute.md:58
msgid ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"
msgstr ""
"```sh\n"
"sozo execute position --calldata 0x77,0x44\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:1
msgid "## sozo register"
msgstr "## sozo register"

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr "`register` se utiliza para registrar nuevos Systems y componentes."

#: src/toolchain/sozo/world-commands/register.md:5
msgid ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo register [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  component  Register a component to a world.\n"
"  system     Register a system to a world.\n"
"  help       Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/register.md:16
msgid ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: component - register a component to a world\n"
"# this will register the Moves component to the world\n"
"sozo register component Moves\n"
"\n"
"# example: system - register a system to a world\n"
"# this will register the spawn system to the world\n"
"sozo register system spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:1
msgid "## sozo system"
msgstr "## sozo system"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for querying about a system's "
"information."
msgstr ""
"`system` se utiliza para interactuar con los Systems de un World. Es útil para consultar información "
"sobre un sistema."

#: src/toolchain/sozo/world-commands/system.md:7
msgid ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"
msgstr ""
"```sh\n"
"sozo system <COMMAND>\n"
"\n"
"Commands:\n"
"  get         Get the class hash of a system.\n"
"  dependency  Retrieve the component dependencies of a system.\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:15 src/toolchain/sozo/world-commands/component.md:16
msgid "### SUBCOMMANDS"
msgstr "### SUBCOMANDOS"

#: src/toolchain/sozo/world-commands/system.md:17 src/toolchain/sozo/world-commands/component.md:18
msgid "#### `get`"
msgstr "#### `get`"

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr "Obtener el class hash de un sistema"

#: src/toolchain/sozo/world-commands/system.md:21
msgid ""
"```sh\n"
"sozo system get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:25 src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26 src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
msgid "##### Arguments"
msgstr "##### Argumentos"

#: src/toolchain/sozo/world-commands/system.md:27 src/toolchain/sozo/world-commands/system.md:40
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the system"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El nombre del sistema"

#: src/toolchain/sozo/world-commands/system.md:30
msgid "#### `dependency`"
msgstr "#### `dependency`"

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr "Recuperar las dependencias de los componentes de un sistema"

#: src/toolchain/sozo/world-commands/system.md:34
msgid ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:59
msgid "1. Get the class hash of the _spawn_ system"
msgstr "1. Obtenga el class hash del sistema _spawn_"

#: src/toolchain/sozo/world-commands/system.md:61
msgid ""
"```sh\n"
"sozo system get spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system get spawn\n"
"```"

#: src/toolchain/sozo/world-commands/system.md:65
msgid "2. Get the component dependencies of the _spawn_ system"
msgstr "2. Obtenga las dependencias de los componentes del sistema _spawn_"

#: src/toolchain/sozo/world-commands/system.md:67
msgid ""
"```sh\n"
"sozo system dependency spawn\n"
"```"
msgstr ""
"```sh\n"
"sozo system dependency spawn\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:1
msgid "## sozo component"
msgstr "## sozo component"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for querying about a component's "
"information, or a component value of an entity."
msgstr ""
"`component` se utiliza para interactuar con los componentes de un World. Es útil para consultar sobre la "
"información de un componente o el valor de un componente de una entidad."

#: src/toolchain/sozo/world-commands/component.md:7
msgid ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"
msgstr ""
"```sh\n"
"sozo component <COMMAND>\n"
"\n"
"Commands:\n"
"  get     Get the class hash of a component\n"
"  schema  Retrieve the schema for a component\n"
"  entity  Get the component value for an entity\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr "Obtener el class hash de un componente"

#: src/toolchain/sozo/world-commands/component.md:22
msgid ""
"```sh\n"
"sozo component get <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component get <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:28 src/toolchain/sozo/world-commands/component.md:41
msgid ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El nombre del componente"

#: src/toolchain/sozo/world-commands/component.md:31
msgid "#### `schema`"
msgstr "#### `schema`"

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr "Retrieve the schema for a component"

#: src/toolchain/sozo/world-commands/component.md:35
msgid ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"
msgstr ""
"```sh\n"
"sozo component schema <NAME>\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:44
msgid "#### `entity`"
msgstr "#### `entity`"

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr "Obtener el valor del componente para una entidad"

#: src/toolchain/sozo/world-commands/component.md:48
msgid ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"
msgstr ""
"```sh\n"
"sozo component entity <NAME> [KEYS]...\n"
"```"

#: src/toolchain/sozo/world-commands/component.md:54
msgid ""
"_`NAME`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;El nombre del componente"

#: src/toolchain/sozo/world-commands/component.md:57
msgid ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;The keys of the entity that you want to query.  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;Comma separated values e.g., 0x12345,0x69420,..."
msgstr ""
"_`KEYS`_  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;Las claves de la entidad que desea consultar.\n"
" &nbsp;&nbsp;&nbsp;&nbsp;Valores separados por comas, por ejemplo, 0x12345,0x69420,..."

#: src/toolchain/sozo/world-commands/events.md:1
msgid "## sozo events"
msgstr "## sozo events"

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr "`eventos` se utiliza para consultar eventos de World."

#: src/toolchain/sozo/world-commands/events.md:5
msgid ""
"```sh\n"
"sozo events\n"
"```"
msgstr ""
"```sh\n"
"sozo events\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:1
msgid "## sozo auth"
msgstr "## sozo auth"

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr "`auth` se utiliza para gestionar la autorización del World."

#: src/toolchain/sozo/world-commands/auth.md:5
msgid ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"
msgstr ""
"```sh\n"
"sozo auth [OPTIONS] <COMMAND>\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:9
msgid ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"
msgstr ""
"```sh\n"
"Commands:\n"
"  writer  Auth a system with the given calldata.\n"
"  help    Print this message or the help of the given subcommand(s)\n"
"```"

#: src/toolchain/sozo/world-commands/auth.md:15
msgid ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position component\n"
"sozo auth writer Position spawn\n"
"```"
msgstr ""
"```sh\n"
"# example: writer - auth a system with the given calldata\n"
"# This will auth the spawn system with the writer role for Position component\n"
"sozo auth writer Position spawn\n"
"```"

#: src/toolchain/katana/overview.md:1
msgid "## Katana"
msgstr "## Katana"

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support local development with Dojo."
msgstr ""
"`katana` es un nodo local de Starknet _increíblemente rápido_, diseñado para respaldar el desarrollo "
"local con Dojo."

#: src/toolchain/katana/overview.md:5
msgid "### Features"
msgstr "### Características"

#: src/toolchain/katana/overview.md:7
msgid ""
"-   [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) support\n"
"-   Custom methods for manipulating the blockchain states"
msgstr ""
"-  Soporte [Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0)\n"
"-  Métodos personalizados para manipular los estados de blockchain"

#: src/toolchain/katana/overview.md:12
msgid "`katana` binary is available via [`dojoup`](../../getting-started/quick-start.md)."
msgstr "El binario `katana` está disponible a través de [`dojoup`](../../getting-started/quick-start.md)."

#: src/toolchain/katana/overview.md:14
msgid "### Installing from source"
msgstr "### Instalando desde la fuente"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"

#: src/toolchain/katana/overview.md:22
msgid "### Usage"
msgstr "### Uso"

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"

#: src/toolchain/katana/overview.md:60
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`katana` Reference](./reference.md) for an in depth reference and documentation on Katana."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`referencia de katana`](./reference.md) para obtener una referencia detallada y "
"documentación sobre Katana."

#: src/toolchain/katana/reference.md:1
msgid "## katana reference"
msgstr "## Referencia de katana"

#: src/toolchain/katana/reference.md:3
msgid "### NAME"
msgstr "### NAME"

#: src/toolchain/katana/reference.md:5
msgid "katana - Create a local testnet node for deploying and testing Starknet smart contracts."
msgstr ""
"katana - Cree un nodo de prueba local para implementar y probar smart contracs de Starknet."

#: src/toolchain/katana/reference.md:9
msgid ""
"```sh\n"
"katana [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"katana [OPTIONS]\n"
"```"

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
msgid "### DESCRIPTION"
msgstr "### DESCRIPCIÓN"

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart contracts. Katana supports "
"deployment and execution of the **new** as well as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"Cree un nodo de testnet local para implementar y probar smart contracs de Starknet. Katana apoya "
"el despliegue y ejecución de los contratos **nuevos** y **heredados** (Cairo 0) de Cairo."

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, Supported RPC Methods, Katana "
"flags and their usages. You can run multiple flags at the same time."
msgstr ""
"Esta sección cubre una lista extensa de información sobre modos de minería, métodos RPC admitidos, "
"indicadores de Katana y sus usos. Puede ejecutar varias banderas al mismo tiempo."

#: src/toolchain/katana/reference.md:19
msgid "#### Mining Modes"
msgstr "#### Modos de Minería"

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, a new block is "
"automatically mined as soon as a transaction is submitted."
msgstr ""
"En Katana, los modos de minería determinan la frecuencia con la que se extraen los bloques. De forma "
"predeterminada, se extrae automáticamente un nuevo bloque tan pronto como se envía una transacción."

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a new block is created at a "
"fixed time interval selected by the user. To enable this mode of mining, use the `--block-time "
"<MILLISECONDS>` flag, as demonstrated in the following example."
msgstr ""
"Puede cambiar del comportamiento de minería predeterminado a la minería a intervalos, donde se crea un "
"nuevo bloque en un intervalo de tiempo fijo seleccionado por el usuario. Para habilitar este modo de "
"minería, use el indicador `--block-time <MILLISECONDS>`, como se demuestra en el siguiente ejemplo."

#: src/toolchain/katana/reference.md:25
msgid ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10000\n"
"```"
msgstr ""
"```sh\n"
"# Produces a new block every 10 seconds\n"
"katana --block-time 10000\n"
"```"

#: src/toolchain/katana/reference.md:30
msgid "#### Forking"
msgstr "#### Bifurcación"

#: src/toolchain/katana/reference.md:32
msgid ""
"Katana supports forking from a Starknet RPC provider. You can configure your node to enable the forking "
"feature by providing a valid RPC provider using the `--rpc-url <URL>` flag., which would initiate Katana "
"to fork the latest block of the provided network. If you would like to fork from a specific block, you "
"can do so using `--fork-block-number <BLOCK_NUMBER>`."
msgstr ""
"Katana admite la bifurcación de un proveedor de RPC de Starknet. Puede configurar su nodo para habilitar "
"la función de bifurcación proporcionando un proveedor RPC válido usando el indicador `--rpc-url <URL>`, "
"lo que iniciaría a Katana a bifurcar el último bloque de la red proporcionada. Si desea bifurcar desde "
"un bloque específico, puede hacerlo usando `--fork-block-number <BLOCK_NUMBER>`."

#: src/toolchain/katana/reference.md:34
msgid ""
"NOTE: This does not allow fetching of historical blocks but only blocks that are mined by Katana. "
"However, support for fetching historical blocks will be added in the future."
msgstr ""
"NOTA: Esto no permite recuperar bloques históricos, sino solo bloques extraídos por Katana. Sin embargo, "
"en el futuro se agregará soporte para recuperar bloques históricos."

#: src/toolchain/katana/reference.md:36
msgid ""
"```sh\n"
"# Forks the network at block 1200\n"
"katana --rpc-url http://your-rpc-provider.com --fork-block-number 1200\n"
"```"
msgstr ""
"```sh\n"
"# Forks the network at block 1200\n"
"katana --rpc-url http://your-rpc-provider.com --fork-block-number 1200\n"
"```"

#: src/toolchain/katana/reference.md:41
msgid "#### Messaging"
msgstr "#### Mensajería"

#: src/toolchain/katana/reference.md:43
msgid ""
"Katana also allows users to perform L1 <-> L2 integration using the messaging feature. There are two "
"types of messaging service supported by Katana:"
msgstr ""
"Katana también permite a los usuarios realizar la integración L1 <-> L2 utilizando la función de "
"mensajería. Hay dos tipos de servicios de mensajería compatibles con Katana:"

#: src/toolchain/katana/reference.md:45
msgid ""
"1. _Ethereum_\n"
"2. _Starknet_ (**experimental**)"
msgstr ""
"1. _Ethereum_\n"
"2. _Starknet_ (**experimental**)"

#: src/toolchain/katana/reference.md:48
msgid ""
"If configured to _Ethereum_ messaging, Katana will listen/send messages on an Ethereum chain. This type "
"of messaging behaves similar to the canonical Starknet sequencer with the exception that messages from "
"L2 -> L1 will be sent directly to the settlement chain for consumption, instead of having to wait for "
"the corresponding blocks of the messages to be proven on the settlement chain (which in reality would be "
"a very time consuming process)."
msgstr ""
"Si está configurado para mensajería _Ethereum_, Katana escuchará/enviará mensajes en una cadena de "
"Ethereum. Este tipo de mensajería se comporta de manera similar al secuenciador canónico de Starknet con "
"la excepción de que los mensajes de L2 -> L1 se enviarán directamente a la cadena de liquidación para su "
"consumo, en lugar de tener que esperar a que los bloques correspondientes de mensajes se prueben en la "
"liquidación. cadena (que en realidad sería un proceso que llevaría mucho tiempo)."

#: src/toolchain/katana/reference.md:50
msgid ""
"The _Starknet_ messaging, however, is an experimental feature that allows Katana to listen/send messages "
"on a Starknet chain. It attempts to replicate the behaviour of Ethereum messaging but with a Starknet "
"chain as the settlement layer. This is achieved by having Katana listen to the Starknet chain for new "
"blocks and then sending the messages to the settlement chain for consumption. This is an experimental "
"and opinionated feature, and is not recommended for production use."
msgstr ""
"La mensajería _Starknet_, sin embargo, es una característica experimental que permite a Katana listen/"
"enviar mensajes en una cadena Starknet. Intenta replicar el comportamiento de la mensajería de Ethereum "
"pero con una cadena Starknet como capa de liquidación. Esto se logra haciendo que Katana escuche la "
"cadena Starknet en busca de nuevos bloques y luego envíe los mensajes a la cadena de liquidación para su "
"consumo. Esta es una característica experimental y obstinada, y no se recomienda para uso en producción."

#: src/toolchain/katana/reference.md:52
msgid ""
"```sh\n"
"katana --messaging path/to/messaging/config.json\n"
"```"
msgstr ""
"```sh\n"
"katana --messaging path/to/messaging/config.json\n"
"```"

#: src/toolchain/katana/reference.md:56
msgid "The messaging config file is a JSON file that contains the following fields:"
msgstr "El archivo de configuración de mensajería es un archivo JSON que contiene los siguientes campos:"

#: src/toolchain/katana/reference.md:58
msgid ""
"```json\n"
"{\n"
"\t/// The type of messaging service to use. Can be either \"ethereum\" or \"starknet\".\n"
"\t\"chain\": \"ethereum\",\n"
"\t/// The RPC-URL of the settlement chain.\n"
"\t\"rpc_url\": \"http://127.0.0.1:8545\",\n"
"\t/// The messaging-contract address on the settlement chain.\n"
"\t\"contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n"
"\t/// The address to use for settling messages. It should be a valid address that\n"
"\t/// can be used to send a transaction on the settlement chain.\n"
"\t\"sender_address\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n"
"\t/// The private key associated to `sender_address`.\n"
"\t\"private_key\": \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\",\n"
"\t/// The interval, in seconds, at which the messaging service will fetch and settle messages\n"
"\t/// from/to the settlement chain.\n"
"\t\"interval\": 2,\n"
"\t/// The block on settlement chain from where Katana will start fetching messages.\n"
"\t\"from_block\": 0\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"\t/// The type of messaging service to use. Can be either \"ethereum\" or \"starknet\".\n"
"\t\"chain\": \"ethereum\",\n"
"\t/// The RPC-URL of the settlement chain.\n"
"\t\"rpc_url\": \"http://127.0.0.1:8545\",\n"
"\t/// The messaging-contract address on the settlement chain.\n"
"\t\"contract_address\": \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n"
"\t/// The address to use for settling messages. It should be a valid address that\n"
"\t/// can be used to send a transaction on the settlement chain.\n"
"\t\"sender_address\": \"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\",\n"
"\t/// The private key associated to `sender_address`.\n"
"\t\"private_key\": \"0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\",\n"
"\t/// The interval, in seconds, at which the messaging service will fetch and settle messages\n"
"\t/// from/to the settlement chain.\n"
"\t\"interval\": 2,\n"
"\t/// The block on settlement chain from where Katana will start fetching messages.\n"
"\t\"from_block\": 0\n"
"}\n"
"```"

#: src/toolchain/katana/reference.md:79
msgid "#### Supported Transport Layers"
msgstr "#### Capas de Transporte Admitidas"

#: src/toolchain/katana/reference.md:81
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port 5050 by default, but it can "
"be changed by running the following command:"
msgstr ""
"Por el momento, solo se admite la conexión HTTP. El servidor escucha en el puerto 5050 de forma "
"predeterminada, pero se puede cambiar ejecutando el siguiente comando:"

#: src/toolchain/katana/reference.md:83
msgid ""
"```sh\n"
"katana --port <PORT>\n"
"```"
msgstr ""
"```sh\n"
"katana --port <PORT>\n"
"```"

#: src/toolchain/katana/reference.md:87
msgid "#### Starknet Feature Compatibility"
msgstr "#### Compatibilidad de Características de Starknet"

#: src/toolchain/katana/reference.md:89
msgid "##### Supported Transaction Type"
msgstr "##### Tipo de Transacción Soportada"

#: src/toolchain/katana/reference.md:91
msgid ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"
msgstr ""
"| Type           | Version |\n"
"| -------------- | ------- |\n"
"| INVOKE         | 1       |\n"
"| DECLARE        | 1, 2    |\n"
"| DEPLOY_ACCOUNT |         |"

#: src/toolchain/katana/reference.md:97
msgid "#### Supported RPC Methods"
msgstr "#### Métodos RPC Soportados"

#: src/toolchain/katana/reference.md:99
msgid "##### Starknet Methods"
msgstr "##### Métodos Starknet"

#: src/toolchain/katana/reference.md:101
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. The standard methods are "
"based on [this](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katana admite la versión **v0.3.0** de las especificaciones Starknet JSON-RPC. Los métodos estándar se "
"basan en [esta](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0) referencia."

#: src/toolchain/katana/reference.md:103
msgid ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   **`starknet_getClassAt`**\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"
msgstr ""
"-   `starknet_blockNumber`\n"
"-   `starknet_blockHashAndNumber`\n"
"-   `starknet_getBlockWithTxs`\n"
"-   `starknet_getBlockWithTxHashes`\n"
"-   `starknet_getBlockTransactionCount`\n"
"-   `starknet_getTransactionByHash`\n"
"-   `starknet_getTransactionByBlockIdAndIndex`\n"
"-   `starknet_getTransactionReceipt`\n"
"-   `starknet_pendingTransactions`\n"
"-   `starknet_getStateUpdate`\n"
"\n"
"-   `starknet_call`\n"
"-   `starknet_estimateFee`\n"
"\n"
"-   `starknet_chainId`\n"
"\n"
"-   `starknet_getNonce`\n"
"-   `starknet_getEvents`\n"
"-   `starknet_getStorageAt`\n"
"-   `starknet_getClassHashAt`\n"
"-   `starknet_getClass`\n"
"-   **`starknet_getClassAt`**\n"
"\n"
"-   `starknet_addInvokeTransaction`\n"
"-   `starknet_addDeclareTransaction`\n"
"-   `starknet_addDeployAccountTransaction`"

#: src/toolchain/katana/reference.md:130
msgid "##### Custom Methods"
msgstr "##### Métodos Personalizados"

#: src/toolchain/katana/reference.md:132
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily configure the node to suit "
"your testing environment."
msgstr ""
"Katana proporciona un conjunto conveniente de métodos RPC personalizados para configurar rápida y "
"fácilmente el nodo para adaptarlo a su entorno de prueba."

#: src/toolchain/katana/reference.md:134
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock`\n"
"Extraiga un nuevo bloque que incluya todas las transacciones actualmente pendientes."

#: src/toolchain/katana/reference.md:137
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`\n"
"Obtenga la hora para el siguiente bloque."

#: src/toolchain/katana/reference.md:140
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`\n"
"Aumenta el tiempo del bloque en una cantidad determinada de tiempo, en segundos."

#: src/toolchain/katana/reference.md:143
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp that you want in the next "
"block."
msgstr ""
"`katana_setNextBlockTimestamp`\n"
"Similar a `katana_increaseNextBlockTimestamp` pero toma la marca de tiempo exacta que deseas en el "
"siguiente bloque."

#: src/toolchain/katana/reference.md:146
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"`katana_predeployedAccounts`\n"
"Obtenga la información de todas las cuentas previamente implementadas."

#: src/toolchain/katana/reference.md:149
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""
"`katana_setStorageAt`\n"
"Establezca un valor exacto del espacio de almacenamiento de un contrato."

#: src/toolchain/katana/reference.md:156
msgid ""
"`--silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Don't print anything on startup."
msgstr ""
"`--silent`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; No imprime nada al inicio."

#: src/toolchain/katana/reference.md:159
msgid ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable auto and interval mining, and mine on demand instead."
msgstr ""
"`--no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Desactive la minería automática y de intervalos y, en su lugar, extraiga según "
"demanda."

#: src/toolchain/katana/reference.md:162
msgid ""
"`-b, --block-time <MILLISECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Block time in milliseconds for interval mining."
msgstr ""
"`-b, --block-time <MILLISECONDS>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Tiempo de bloque en milisegundos para minería de intervalos."

#: src/toolchain/katana/reference.md:165
msgid ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dump the state of chain on exit to the given file.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; If the value is a directory, the state will be written to `<PATH>/state.bin`."
msgstr ""
"`--dump-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Vuelque el estado de la cadena al salir del archivo dado.\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Si el valor es un directorio, el estado se escribirá en `<PATH>/state.bin`."

#: src/toolchain/katana/reference.md:169
msgid ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Initialize the chain from a previously saved state snapshot."
msgstr ""
"`--load-state <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Inicialice la cadena a partir de una instantánea de estado previamente guardada."

#: src/toolchain/katana/reference.md:172
msgid ""
"`--rpc-url <URL>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The Starknet RPC provider to fork the network from."
msgstr ""
"`--rpc-url <URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; El proveedor de Starknet RPC desde el cual bifurcar la red."

#: src/toolchain/katana/reference.md:175
msgid ""
"`--json-log`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Output logs in JSON format."
msgstr ""
"`--json-log`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Registros de salida en formato JSON."

#: src/toolchain/katana/reference.md:178
msgid ""
"`--fork-block-number <BLOCK_NUMBER>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Fork the network at a specific block."
msgstr ""
"`--fork-block-number <BLOCK_NUMBER>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Bifurca la red en un bloque específico."

#: src/toolchain/katana/reference.md:181
msgid ""
"`--messaging <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Configure the messaging service to allow Katana to listen/send messages on a "
"settlement chain that can be either Ethereum or another Starknet sequencer (experimental)."
msgstr ""
"`--messaging <PATH>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Configure el servicio de mensajería para permitir que Katana escuche/envíe "
"mensajes en una cadena de liquidación que puede ser Ethereum u otro secuenciador Starknet (experimental)."

#: src/toolchain/katana/reference.md:184
msgid ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help (see a summary with '-h')."
msgstr ""
"`-h, --help`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir ayuda (ver un resumen con '-h')."

#: src/toolchain/katana/reference.md:187
msgid ""
"`-V, --version`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version information."
msgstr ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir información de la versión."

#: src/toolchain/katana/reference.md:190
msgid "#### Server Options"
msgstr "#### Opciones del Servidor"

#: src/toolchain/katana/reference.md:192
msgid ""
"`-p, --port <PORT>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Port number to listen on. [default: 5050]"
msgstr ""
"`-p, --port <PORT>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de puerto para escuchar. [predeterminado: 5050]"

#: src/toolchain/katana/reference.md:195
msgid ""
"`--host <HOST>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The IP address the server will listen on."
msgstr ""
"`--host <HOST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; La dirección IP en la que escuchará el servidor."

#: src/toolchain/katana/reference.md:200
msgid ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify the seed for randomness of accounts to be predeployed."
msgstr ""
"`--seed <SEED>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especifique la semilla para la aleatoriedad de las cuentas que se implementarán "
"previamente."

#: src/toolchain/katana/reference.md:203
msgid ""
"`--accounts <NUM>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Number of pre-funded accounts to generate. [default: 10]"
msgstr ""
"`--accounts <NUM>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Número de cuentas prefinanciadas a generar. [predeterminado: 10]"

#: src/toolchain/katana/reference.md:206
msgid ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Disable charging fee for transactions."
msgstr ""
"`--disable-fee`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; Deshabilite el cobro de tarifas por transacciones."

#: src/toolchain/katana/reference.md:209
msgid "#### Environment Options"
msgstr "#### Opciones de Entorno"

#: src/toolchain/katana/reference.md:211
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The chain ID. [default: KATANA]"
msgstr ""
"`--chain-id <CHAIN_ID>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; La identificación de la cadena. [predeterminado: KATANA]"

#: src/toolchain/katana/reference.md:214
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The gas price."
msgstr ""
"`--gas-price <GAS_PRICE>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El precio del gas."

#: src/toolchain/katana/reference.md:217
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the account validation logic."
msgstr ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El número máximo de pasos disponibles para la lógica de validación de la cuenta."

#: src/toolchain/katana/reference.md:220
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; The maximum number of steps available for the account execution logic."
msgstr ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; El número máximo de pasos disponibles para la lógica de ejecución de la cuenta."

#: src/toolchain/katana/reference.md:223
msgid "### Shell Completions"
msgstr "### Finalizaciones de Shell"

#: src/toolchain/katana/reference.md:225
msgid "`katana` completions shell"
msgstr "shell de terminaciones `katana`"

#: src/toolchain/katana/reference.md:227
msgid "Generates a shell completions script for the given shell."
msgstr "Genera un script de finalización de shell para el shell determinado."

#: src/toolchain/katana/reference.md:229
msgid "Supported shells are:"
msgstr "Los shells soportados son:"

#: src/toolchain/katana/reference.md:231
msgid ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"
msgstr ""
"-   bash\n"
"-   elvish\n"
"-   fish\n"
"-   powershell\n"
"-   zsh"

#: src/toolchain/katana/reference.md:237
msgid "#### EXAMPLES"
msgstr "#### EJEMPLOS"

#: src/toolchain/katana/reference.md:239
msgid "Generate shell completions script for `bash` and appends it to a `.bashrc` file:"
msgstr "Genere un script de finalización de shell para `bash` y agréguelo a un archivo `.bashrc`:"

#: src/toolchain/katana/reference.md:241
msgid ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"
msgstr ""
"```bash\n"
"katana completions bash >> ~/.bashrc\n"
"```"

#: src/toolchain/katana/reference.md:247
msgid "1. Create 15 dev accounts and disable transaction fee mechanism"
msgstr "1. Cree 15 cuentas de desarrollo y desactive el mecanismo de tarifas de transacción"

#: src/toolchain/katana/reference.md:249
msgid ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"
msgstr ""
"```sh\n"
"katana --accounts 15 --disable-fee\n"
"```"

#: src/toolchain/katana/reference.md:253
msgid "2. Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""
"2. Establezca la identificación de la cadena en `SN_GOERLI` y ejecute el servidor en el puerto 8545"

#: src/toolchain/katana/reference.md:255
msgid ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"
msgstr ""
"```sh\n"
"katana --chain-id SN_GOERLI --port 8545\n"
"```"

#: src/toolchain/katana/reference.md:259
msgid "3. Load previously stored state and dump the state of this session to a file on shutdown"
msgstr ""
"3. Cargue el estado previamente almacenado y vuelque el estado de esta sesión en un archivo al cerrar"

#: src/toolchain/katana/reference.md:261
msgid ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"
msgstr ""
"```sh\n"
"katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
"```"

#: src/toolchain/torii/overview.md:1
msgid "## Torii - Networking & Indexing"
msgstr "## Torii - Redes e Indexación"

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly fast and exceptionally "
"scalable."
msgstr ""
"Torii es un indexador automático para Worlds dojo. Construido en rust para ser increíblemente rápido y "
"excepcionalmente escalable."

#: src/toolchain/torii/overview.md:5
msgid "### Dojo indexer"
msgstr "### Indexador de Dojo"

#: src/toolchain/torii/overview.md:7
msgid "Torii indexes your dojo worlds and exposes a GraphQL API to query them. Simply run:"
msgstr ""
"Torii indexa los Worlds de tu dojo y expone una API GraphQL para consultarlos. Simplemente ejecuta:"

#: src/toolchain/torii/overview.md:9
msgid ""
"```sh\n"
"torii\n"
"```"
msgstr ""
"```sh\n"
"torii\n"
"```"

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr "¡Y tendrás una API GraphQL ejecutándose en `http://localhost:8080`!"

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/quick-start.md), our dedicated "
"installation package manager."
msgstr ""
"El binario `torii` se puede instalar a través de [`dojoup`](../../getting-started/quick-start.md), "
"nuestro administrador de paquetes de instalación dedicado."

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "If you prefer to install from the source code:"

#: src/toolchain/torii/overview.md:22
msgid ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"
msgstr ""
"```sh\n"
"cargo install --path ./crates/torii --profile local --force\n"
"```"

#: src/toolchain/torii/overview.md:26
msgid "This will install Torii and the required dependencies on your local system."
msgstr "Esto instalará Torii y las dependencias requeridas en su sistema local."

#: src/toolchain/torii/overview.md:28
msgid ""
"> 📚 **Reference**\n"
">\n"
"> See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""
"> 📚 **Referencia**\n"
">\n"
"> Consulte la [`torii` Reference](./reference.md) para obtener una referencia completa."

#: src/toolchain/torii/reference.md:1
msgid "## torii reference"
msgstr "## Referencia torii"

#: src/toolchain/torii/reference.md:3 src/toolchain/torii/graphql.md:3
msgid "### Name"
msgstr "### Name"

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr "torii: - Un indexador automático y una capa de red para un contrato de World."

#: src/toolchain/torii/reference.md:9
msgid ""
"```sh\n"
"torii [OPTIONS]\n"
"```"
msgstr ""
"```sh\n"
"torii [OPTIONS]\n"
"```"

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The indexer queries the specified "
"Starknet RPC endpoint for transaction blocks and listens for transactions related to the world contract. "
"These transactions can include component/system registrations, entity state updates, system calls, and "
"events. The parsed data is then stored in a local SQLite database."
msgstr ""
"`torii` inicia el indexador y expone los puntos finales de la API GraphQL/gRPC. El indexador consulta el "
"punto final Starknet RPC especificado en busca de bloques de transacciones y escucha las transacciones "
"relacionadas con el contrato de World. Estas transacciones pueden incluir registros de componentes/"
"Systems, actualizaciones del estado de la entidad, llamadas al sistema y eventos. Luego, los datos "
"analizados se almacenan en una base de datos SQLite local."

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing custom queries specific to "
"the world contract for client applications."
msgstr ""
"Los puntos finales de las API GraphQL y gRPC se ejecutan en conjunto con el indexador, proporcionando "
"consultas personalizadas específicas del contrato mundial para aplicaciones cliente."

#: src/toolchain/torii/reference.md:19
msgid "#### Database URL"
msgstr "#### Database URL"

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be stored either in-memory or "
"persistently on the filesystem."
msgstr ""
"`torii` usa una base de datos sqlite para almacenar datos indexados. La base de datos se puede almacenar "
"en memoria o de forma persistente en el sistema de archivos."

#: src/toolchain/torii/reference.md:23
msgid ""
"- The in-memory database is ephemeral and only lasts as long as the indexer is running. This is a fast "
"and simple option to start the indexer for development/testing.\n"
"- Persistent storage should be used in production. It relies on the local filesystem for storage."
msgstr ""
"- La base de datos en memoria es efímera y solo dura mientras se ejecuta el indexador. Esta es una "
"opción rápida y sencilla para iniciar el indexador para desarrollo/prueba.\n"
"- En producción se debe utilizar almacenamiento persistente. Depende del sistema de archivos local para "
"el almacenamiento."

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a period of inactivity, causing "
"queries to result in errors. A workaround is to start `katana` with the `--block-time` option or use a "
"persistent database."
msgstr ""
"Nota: Si utiliza una db en memoria, la memoria se recolectará como basura después de un período de "
"inactividad, lo que provocará que las consultas generen errores. Una solución alternativa es iniciar "
"`katana` con la opción `--block-time` o usar una base de datos persistente."

#: src/toolchain/torii/reference.md:28
msgid ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"
msgstr ""
"```sh\n"
"# Persistent database storage using file indexer.db\n"
"torii --database-url sqlite:indexer.db\n"
"```"

#: src/toolchain/torii/reference.md:37
msgid ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Address of the world contract to index"
msgstr ""
"`-w, --world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Dirección del contrato world a indexar"

#: src/toolchain/torii/reference.md:40
msgid ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Starknet RPC endpoint to use [default: http//localhost:5050]"
msgstr ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Punto final Starknet RPC a utilizar [predeterminado: http//localhost:5050]"

#: src/toolchain/torii/reference.md:43
msgid ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a local manifest to initialize from"
msgstr ""
"`-m, --manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especifique un manifiesto local desde el que inicializar"

#: src/toolchain/torii/reference.md:46
msgid ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Database URL (read more above) [default: sqlite::memory:]"
msgstr ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; URL de la base de datos (leer más arriba)[predeterminado: sqlite::memory:]"

#: src/toolchain/torii/reference.md:49
msgid ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Specify a block to start indexing from, ignored if stored head exists [default: "
"0]"
msgstr ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Especifique un bloque desde el que comenzar a indexar, ignorado si existe un "
"encabezado almacenado [predeterminado: 0]"

#: src/toolchain/torii/reference.md:52
msgid ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print help"
msgstr ""
"`-h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Imprimir ayuda"

#: src/toolchain/torii/reference.md:55
msgid ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Print version"
msgstr ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; Versión impresa"

#: src/toolchain/torii/graphql.md:1
msgid "## Torii - GraphQL"
msgstr "## Torii - GraphQL"

#: src/toolchain/torii/graphql.md:5
msgid ""
"In Dojo, you have access to custom queries and subscriptions that are specifically designed to work with "
"the `caller` for client applications. GraphQL is the technology that makes this possible."
msgstr ""
"En Dojo, tiene acceso a consultas y suscripciones personalizadas diseñadas específicamente para "
"funcionar con el `caller` para aplicaciones cliente. GraphQL es la tecnología que hace esto posible."

#: src/toolchain/torii/graphql.md:7
msgid ""
"GraphQL is the rising star of backend technologies. It replaces REST as an API design paradigm and is "
"becoming the new standard for exposing the data and functionality of a web server. It allows you to "
"specify exactly what data you want to retrieve, and it delivers that data in a structured JSON format. "
"This flexibility in data retrieval ensures that you get the information you need efficiently and in a "
"format that's easy to work with."
msgstr ""
"GraphQL es la estrella en ascenso de las tecnologías backend. Reemplaza a REST como paradigma de diseño "
"de API y se está convirtiendo en el nuevo estándar para exponer los datos y la funcionalidad de un "
"servidor web. Le permite especificar exactamente qué datos desea recuperar y los entrega en un formato "
"JSON estructurado. Esta flexibilidad en la recuperación de datos garantiza que obtenga la información "
"que necesita de manera eficiente y en un formato con el que sea fácil trabajar."

#: src/toolchain/torii/graphql.md:9
msgid "#### GraphQL Playground"
msgstr "#### GraphQL Playground"

#: src/toolchain/torii/graphql.md:11
msgid ""
"GraphQL Playground is a `GraphQL IDE`` that allows you to interactively explore the functionality of a "
"GraphQL API by sending queries and mutations to it. It’s somewhat similar to Postman which offers "
"comparable functionality for REST APIs."
msgstr ""
"GraphQL Playground es un `GraphQL IDE` que le permite explorar interactivamente la funcionalidad de una "
"API GraphQL enviándole consultas y mutaciones. Es algo similar a Postman, que ofrece una funcionalidad "
"comparable para las API REST."

#: src/toolchain/torii/graphql.md:15
msgid "#### Pre-requisites"
msgstr "#### Requisitos previos"

#: src/toolchain/torii/graphql.md:17
msgid "Make sure torii is running in your local terminal."
msgstr "Asegúrese de que torii se esté ejecutando en su terminal local."

#: src/toolchain/torii/graphql.md:19
msgid ""
"```sh\n"
"torii --world <WORLD_ADDRESS>\n"
"```"
msgstr ""
"```sh\n"
"torii --world <WORLD_ADDRESS>\n"
"```"

#: src/toolchain/torii/graphql.md:23
msgid "It starts GraphQL server at `http://0.0.0.0:8080/graphql`"
msgstr "Inicia el servidor GraphQL en `http://0.0.0.0:8080/graphql`"

#: src/toolchain/torii/graphql.md:25
msgid ""
"After the torii server starts on your local machine, you're ready to make query and subscription "
"operations."
msgstr ""
"Una vez que el servidor torii se inicie en su máquina local, estará listo para realizar operaciones de "
"consulta y suscripción."

#: src/toolchain/torii/graphql.md:27
msgid "### Query operation"
msgstr "### Operación de consulta"

#: src/toolchain/torii/graphql.md:29
msgid ""
"In [`hello-dojo`](../../cairo/hello-dojo.md#next-steps) we fetched some data from the `Moves` model. "
"This time let's fetch only `id`, `name`, `class_hash` fields from `Position` model ."
msgstr ""
"En [`hello-dojo`](../../cairo/hello-dojo.md#next-steps) obtuvimos algunos datos del Model `Moves`. Esta "
"vez recuperaremos solo los campos `id`, `name`, `class_hash` del Model `Position`."

#: src/toolchain/torii/graphql.md:31
msgid ""
"```graphql\n"
"query {\n"
"  model(id: \"Position\") {\n"
"    id\n"
"    name\n"
"    class_hash\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"query {\n"
"  model(id: \"Position\") {\n"
"    id\n"
"    name\n"
"    class_hash\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:43
msgid ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"model\": {\n"
"      \"id\": \"Position\",\n"
"      \"name\": \"Position\",\n"
"      \"class_hash\": \"0x6ffc643cbc4b2fb9c424242b18175a5e142269b45f4463d1cd4dddb7a2e5095\"\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"model\": {\n"
"      \"id\": \"Position\",\n"
"      \"name\": \"Position\",\n"
"      \"class_hash\": \"0x6ffc643cbc4b2fb9c424242b18175a5e142269b45f4463d1cd4dddb7a2e5095\"\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:55
msgid ""
"Great! If you're wondering about the number of fields a `Model` has or the details of a `Entities`, you "
"can find all the information about the schema definition in the `Documentation Explorer` section of the "
"GraphQL IDE. It's your go-to place for exploring the rest of the documentation."
msgstr ""
"¡Excelente! Si se pregunta sobre la cantidad de campos que tiene un `Model` o los detalles de una "
"`Entities`, puede encontrar toda la información sobre la definición del esquema en la sección "
"`Documentation Explorer` del IDE GraphQL. Es su lugar de referencia para explorar el resto de la "
"documentación."

#: src/toolchain/torii/graphql.md:57
msgid "Now lets retrieve more data from `Moves` model."
msgstr "Ahora recuperemos más datos del Model `Moves`."

#: src/toolchain/torii/graphql.md:59
msgid ""
"```graphql\n"
"query {\n"
"  movesModels {\n"
"    edges {\n"
"      node {\n"
"        player\n"
"        remaining\n"
"        last_direction\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"query {\n"
"  movesModels {\n"
"    edges {\n"
"      node {\n"
"        player\n"
"        remaining\n"
"        last_direction\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:75
msgid ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"movesModels\": {\n"
"      \"edges\": [\n"
"        {\n"
"          \"node\": {\n"
"            \"player\": \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\",\n"
"            \"remaining\": 10,\n"
"            \"last_direction\": \"None\"\n"
"          }\n"
"        }\n"
"      ]\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"movesModels\": {\n"
"      \"edges\": [\n"
"        {\n"
"          \"node\": {\n"
"            \"player\": \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\",\n"
"            \"remaining\": 10,\n"
"            \"last_direction\": \"None\"\n"
"          }\n"
"        }\n"
"      ]\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:93
msgid ""
"Feel free to play around with the query by removing any fields from the selection set and observe the "
"responses sent by the server. It is your turn to create any kind of query for entities and models!"
msgstr ""
"Siéntase libre de jugar con la consulta eliminando cualquier campo del conjunto de selección y observe "
"las respuestas enviadas por el servidor. ¡Es tu turno de crear cualquier tipo de consulta para entidades "
"y Models!"

#: src/toolchain/torii/graphql.md:95
msgid "### Subscription operations"
msgstr "### Subscription operations"

#: src/toolchain/torii/graphql.md:97
msgid ""
"Subscriptions are a GraphQL feature that allows a server to send data to its clients when a specific "
"event happens. Subscriptions are usually implemented with WebSockets. In that setup, the server "
"maintains a steady connection to its subscribed client. This also breaks the “Request-Response-Cycle” "
"that is used for with REST APIs."
msgstr ""
"Las suscripciones son una característica de GraphQL que permite a un servidor enviar datos a sus "
"clientes cuando ocurre un evento específico. Las suscripciones suelen implementarse con WebSockets. En "
"esa configuración, el servidor mantiene una conexión estable con su cliente suscrito. Esto también rompe "
"el \"Request-Response-Cycle” que se utiliza con las API REST."

#: src/toolchain/torii/graphql.md:99
msgid ""
"Instead, the client initially opens up a long-lived connection to the server by sending a subscription "
"query that specifies which event it is interested in. Every time this particular event happens, the "
"server uses the connection to push the event data to the subscribed client(s)."
msgstr ""
"En cambio, el cliente inicialmente abre una conexión de larga duración con el servidor enviando una "
"consulta de suscripción que especifica qué evento le interesa. Cada vez que ocurre este evento en "
"particular, el servidor usa la conexión para enviar los datos del evento al cliente/s suscrito."

#: src/toolchain/torii/graphql.md:101
msgid "In this example, you can listen when an `Model` is registered by executing this subscription"
msgstr "En este ejemplo, puede escuchar cuando se registra un `Model` ejecutando esta suscripción"

#: src/toolchain/torii/graphql.md:103
msgid ""
"```graphql\n"
"subscription modelRegistered {\n"
"  modelRegistered {\n"
"    id\n"
"    name\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"subscription modelRegistered {\n"
"  modelRegistered {\n"
"    id\n"
"    name\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:112
msgid ""
"Graphql also supports subscription to a targeted entity or model, for this we have to pass its id as an "
"argument"
msgstr ""
"Graphql también admite la suscripción a una entidad o Model de destino, para ello tenemos que pasar su "
"identificación como argumento"

#: src/toolchain/torii/graphql.md:114
msgid ""
"In this example, our server provides a `entityUpdated` subscription, which should notify clients "
"whenever an entity with id `0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20` is "
"updated. On the same subscription we can get the model(components) values of the updated entity . A "
"client can execute a subscription that looks like this:"
msgstr ""
"En este ejemplo, nuestro servidor proporciona una suscripción `entityUpdated`, que debe notificar a los "
"clientes cada vez que se actualiza una entidad con ID "
"`0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20`. En la misma suscripción podemos "
"obtener los valores del Model (componentes) de la entidad actualizada. Un cliente puede ejecutar una "
"suscripción similar a esta:"

#: src/toolchain/torii/graphql.md:116
msgid ""
"```graphql\n"
"subscription {\n"
"  entityUpdated(\n"
"    id: \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\"\n"
"  ) {\n"
"    id\n"
"    keys\n"
"    model_names\n"
"    event_id\n"
"    created_at\n"
"    updated_at\n"
"    models {\n"
"      __typename\n"
"      ... on Moves {\n"
"        remaining\n"
"        player\n"
"      }\n"
"      ... on Position {\n"
"        vec {\n"
"          x\n"
"          y\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```graphql\n"
"subscription {\n"
"  entityUpdated(\n"
"    id: \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\"\n"
"  ) {\n"
"    id\n"
"    keys\n"
"    model_names\n"
"    event_id\n"
"    created_at\n"
"    updated_at\n"
"    models {\n"
"      __typename\n"
"      ... on Moves {\n"
"        remaining\n"
"        player\n"
"      }\n"
"      ... on Position {\n"
"        vec {\n"
"          x\n"
"          y\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/toolchain/torii/graphql.md:144
msgid "According to your input, you will receive an output like this:"
msgstr "Según su entrada, recibirá un resultado como este:"

#: src/toolchain/torii/graphql.md:146
msgid ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves,Position\",\n"
"      \"event_id\": "
"\"0x0000000000000000000000000000000000000000000000000000000000000013:0x0000:0x0000\",\n"
"      \"created_at\": \"2023-10-17 11:39:42\",\n"
"      \"updated_at\": \"2023-10-17 11:52:48\",\n"
"      \"models\": [\n"
"        {\n"
"          \"__typename\": \"Moves\",\n"
"          \"remaining\": 10,\n"
"          \"player\": \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"        },\n"
"        {\n"
"          \"__typename\": \"Position\",\n"
"          \"vec\": {\n"
"            \"x\": 10,\n"
"            \"y\": 10\n"
"          }\n"
"        }\n"
"      ]\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"data\": {\n"
"    \"entityUpdated\": {\n"
"      \"id\": \"0x28cd7ee02d7f6ec9810e75b930e8e607793b302445abbdee0ac88143f18da20\",\n"
"      \"keys\": [\n"
"        \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"      ],\n"
"      \"model_names\": \"Moves,Position\",\n"
"      \"event_id\": "
"\"0x0000000000000000000000000000000000000000000000000000000000000013:0x0000:0x0000\",\n"
"      \"created_at\": \"2023-10-17 11:39:42\",\n"
"      \"updated_at\": \"2023-10-17 11:52:48\",\n"
"      \"models\": [\n"
"        {\n"
"          \"__typename\": \"Moves\",\n"
"          \"remaining\": 10,\n"
"          \"player\": \"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\"\n"
"        },\n"
"        {\n"
"          \"__typename\": \"Position\",\n"
"          \"vec\": {\n"
"            \"x\": 10,\n"
"            \"y\": 10\n"
"          }\n"
"        }\n"
"      ]\n"
"    }\n"
"  }\n"
"}\n"
"```"

#: src/deployment/locally.md:1
msgid "## Deploying Locally"
msgstr "## Implementación Local"

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local development environment named "
"[Katana](./toolchain/katana/overview.md). Katana serves as an on-device Starknet blockchain, allowing "
"you to rigorously test your smart contracts before transitioning them to the remote testnet."
msgstr ""
"Dojo está diseñado para un desarrollo rápido y cuenta con un entorno de desarrollo local ultrarrápido "
"llamado [Katana](./toolchain/katana/overview.md). Katana sirve como una cadena de bloques Starknet en el "
"dispositivo, lo que le permite probar rigurosamente sus smart contract antes de realizar la transición a "
"la red de prueba remota."

#: src/deployment/locally.md:5
msgid "### Katana Deployments"
msgstr "### Implementaciones de Katana"

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr "La implementación en Katana no podría ser más sencilla."

#: src/deployment/locally.md:9
msgid ""
"> This assumes you have followed the [Quick Start](./getting-started/quick-start.md) guide and have a "
"project initialized."
msgstr ""
"> Esto supone que ha seguido la guía [Inicio rápido](./getting-started/quick-start.md) y tiene un "
"proyecto inicializado."

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr "Desde el directorio de su proyecto, ejecute:"

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr "¡Esto ha iniciado una Katana local en la que ahora puedes implementar!"

#: src/deployment/locally.md:19
msgid "### Deploying to Katana"
msgstr "### Implementación en Katana"

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr "Para implementar su proyecto en Katana, ejecute:"

#: src/deployment/locally.md:27
msgid "Note - this will only work if you have compiled your contracts. If you have not, run:"
msgstr "Nota: esto sólo funcionará si ha compilado sus contratos. Si no lo has hecho, ejecuta:"

#: src/deployment/remote.md:1
msgid "## Deployment to Remote Network"
msgstr "## Implementación en Red Remota"

#: src/deployment/remote.md:3
msgid "> *IMPORTANT: Dojo is unaudited. Use at your own risk.*"
msgstr "> *IMPORTANTE: Dojo no está auditado. Úselo bajo su propio riesgo.*"

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a valid account and network "
"endpoint."
msgstr ""
"Dojo facilita la implementación en redes remotas; solo necesita tener una cuenta válida y un punto final "
"de red."

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr "Scarb.toml"

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = \"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = \"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = \"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = \"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = \"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = \"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = \"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = \"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"

#: src/deployment/remote.md:33
msgid "### Remote Katana"
msgstr "### Katana Remota"

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is not recommended for production "
"use."
msgstr ""
"Las Katanas se pueden alojar y ejecutar como redes de prueba remotas; sin embargo, esto no se recomienda "
"para uso en producción."

#: src/deployment/remote.md:37
msgid "__todo__: add instructions for deploying to remote katana"
msgstr "__todo__: agregue instrucciones para implementar en katana remota"

#: src/deployment/remote.md:40
msgid "### Madara "
msgstr "### Madara "

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazingly fast Starknet sequencer. Built "
"on the robust Substrate framework and fast, thanks to Rust 🦀, Madara delivers unmatched performance and "
"scalability to power your Starknet-based Validity Rollup chain."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara) es un secuenciador Starknet increíblemente "
"rápido. Construido sobre el robusto framework de Substrate y rápido, gracias a Rust 🦀, Madara ofrece un "
"rendimiento y una escalabilidad inigualables para impulsar su cadena Validity Rollup basada en Starknet."

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr "Hay una red de prueba pública de Madara disponible para su implementación:"

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr "Puede usar la siguiente cuenta para realizar la implementación:"

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = \"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = \"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"

#: src/deployment/remote.md:59
msgid "### Starknet "
msgstr "### Starknet "

#: src/deployment/remote.md:61
msgid "__todo__: add instructions for deploying to remote Starknet"
msgstr "__todo__: agregue instrucciones para implementar en Starknet remoto"

#: src/tutorial/onchain-chess/index.md:1
msgid "# Building a Chess Game"
msgstr "# Construyendo un Juego de Ajedrez"

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr "_\"Acabo de terminar de leer El Libro del Dojo. ¿Qué debo hacer a continuación?\"_"

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes followed by a list of cool "
"projects. This is a great answer for some people, but others might be looking for a little more "
"direction."
msgstr ""
"Las respuestas a esta pregunta son siempre \"¡Haz algo!\", a veces seguidas de una lista de proyectos "
"interesantes. Esta es una gran respuesta para algunas personas, pero otras podrían estar buscando un "
"poco más de dirección."

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner tutorials and working on your "
"projects. The primary goal here is to get you to write code. The secondary goal is to get you reading "
"documentation."
msgstr ""
"Esta guía está destinada a llenar el vacío entre los tutoriales para principiantes muy dirigidos y el "
"trabajo en sus proyectos. El objetivo principal aquí es conseguir que escribas código. El objetivo "
"secundario es que leas la documentación."

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do so before starting this "
"project."
msgstr ""
"Si aún no ha leído el Libro Dojo, le recomendamos encarecidamente que lo haga antes de comenzar este "
"proyecto."

#: src/tutorial/onchain-chess/index.md:11
msgid "## What are we building?"
msgstr "## ¿Qué estamos construyendo?"

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new game and play chess. This guide "
"does not cover every rules of the chess game. You will build step by step as follows:"
msgstr ""
"Estamos creando un contrato de juego de ajedrez on-chain que le permite comenzar un nuevo juego y jugar "
"ajedrez. Esta guía no cubre todas las reglas del juego de ajedrez. Construirás paso a paso de la "
"siguiente manera:"

#: src/tutorial/onchain-chess/index.md:15
msgid ""
"1. A system contract to spawn all the chess pieces\n"
"2. A system contract to make pieces move\n"
"3. Add some functions to check a legal move\n"
"4. Play chess ♟♙ - integration test!"
msgstr ""
"1. Un contrato de sistema para generar todas las piezas de ajedrez.\n"
"2. Un contrato sistema para hacer que las piezas se muevan\n"
"3. Agregue algunas funciones para verificar un movimiento legal.\n"
"4. Juega al ajedrez ♟♙ - ¡prueba de integración!"

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/rkdud007/chess-dojo/tree/"
"tutorialv3)."
msgstr ""
"El código completo del tutorial se basa en [este repositorio](https://github.com/rkdud007/chess-dojo/"
"tree/tutorialv3)."

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you know some basics about Cairo "
"and Dojo, you're good. We won't make a full chess game with all the rules. We're keeping it simple."
msgstr ""
"Si esto parece demasiado difícil, ¡no te preocupes! Esta guía es para principiantes. Si conoces algunos "
"conceptos básicos sobre Cairo y Dojo, estás bien. No haremos una partida de ajedrez completa con todas "
"las reglas. Lo mantendremos simple."

#: src/tutorial/onchain-chess/index.md:24
msgid "## What after this guide?"
msgstr "## ¿Qué pasa después de esta guía?"

#: src/tutorial/onchain-chess/index.md:26
msgid "We're making another guide to help design the frontend. This will make our chess game complete."
msgstr ""
"Estamos creando otra guía para ayudar a diseñar la interfaz. Esto completará nuestro juego de ajedrez."

#: src/tutorial/onchain-chess/index.md:28
msgid "After you finish all the four chapters, we can move on to the frontend guide."
msgstr "Una vez que haya terminado los cuatro capítulos, podemos pasar a la guía de interfaz."

#: src/tutorial/onchain-chess/0-setup.md:1
msgid "# 0. Setup"
msgstr "# 0. Configuración"

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-dojo.md) chapter to gain a "
"basic understanding of the Dojo game._"
msgstr ""
"_Antes de comenzar, recomendamos seguir el capítulo [`hello-dojo`](../../cairo/hello-dojo.md) para "
"obtener una comprensión básica del juego Dojo._"

#: src/tutorial/onchain-chess/0-setup.md:5
msgid "## Initializing the Project"
msgstr "## Inicializando el Proyecto"

#: src/tutorial/onchain-chess/0-setup.md:7
msgid "Create a new Dojo project folder. You can name your project what you want."
msgstr "Cree una nueva carpeta de proyecto Dojo. Puedes nombrar tu proyecto como quieras."

#: src/tutorial/onchain-chess/0-setup.md:9
msgid ""
"```sh\n"
"mkdir dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"mkdir dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr "Abra la carpeta del proyecto."

#: src/tutorial/onchain-chess/0-setup.md:15
msgid ""
"```sh\n"
"cd dojo-chess\n"
"```"
msgstr ""
"```sh\n"
"cd dojo-chess\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr "E inicialice el proyecto usando sozo init."

#: src/tutorial/onchain-chess/0-setup.md:25
msgid "## Cleaning Up the Boilerplate"
msgstr "## Limpiando lo Repetitivo"

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure both `models.cairo` and "
"`systems.cairo` files are empty. In this tutorial, we won't be creating a `systems.cairo` nor the `src/"
"systems` folder, you can delete both (highly optional, folder structure is entirely up to you). instead, "
"we'll be creating a file named `actions_contract.cairo`, this is where our game logic/contract will "
"reside. "
msgstr ""
"El proyecto viene con muchos códigos repetitivos. Límpielo todo. Asegúrese de que los archivos `models."
"cairo` y `systems.cairo` estén vacíos. En este tutorial, no crearemos una carpeta `systems.cairo` ni la "
"carpeta `src/systems`, puedes eliminar ambas (muy opcional, la estructura de la carpeta depende "
"completamente de ti). en su lugar, crearemos un archivo llamado `actions_contract.cairo`, aquí es donde "
"residirá nuestra lógica/contrato de juego. "

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "Remodel your`lib.cairo`, to look like this :"
msgstr "Remodela tu `lib.cairo`, para que luzca así:"

#: src/tutorial/onchain-chess/0-setup.md:31
msgid ""
"```rust,ignore\n"
"mod models;\n"
"mod actions_contract;\n"
"mod tests;\n"
"```"
msgstr ""
"```rust,ignore\n"
"mod models;\n"
"mod actions_contract;\n"
"mod tests;\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:37
msgid "Compile your project with:"
msgstr "Compila tu proyecto con:"

#: src/tutorial/onchain-chess/0-setup.md:43
msgid "## Basic components"
msgstr "## Componentes básicos"

#: src/tutorial/onchain-chess/0-setup.md:45
msgid "While there are many ways to design a chess game using the ECS model, we'll follow this approach:"
msgstr ""
"Si bien hay muchas formas de diseñar un juego de ajedrez utilizando el Model ECS, seguiremos este "
"enfoque:"

#: src/tutorial/onchain-chess/0-setup.md:47
msgid ""
"> Every square of the chess board (e.g., A1) will be treated as an entity. If a piece exists on a "
"square, the square entity will hold that piece."
msgstr ""
"> Cada casilla del tablero de ajedrez (por ejemplo, A1) será tratada como una entidad. Si existe una "
"pieza en un cuadrado, la entidad cuadrada contendrá esa pieza."

#: src/tutorial/onchain-chess/0-setup.md:49
msgid ""
"First, add this basic model to `models.cairo` file. If you are not familar with model syntax in Dojo "
"engine, go back to this [chapter](../../cairo/models.md)."
msgstr ""
"Primero, agregue este Model básico al archivo `models.cairo`. Si no está familiarizado con la sintaxis "
"del Model en el Dojo engine, vuelva a este [capítulo](../../cairo/models.md)."

#: src/tutorial/onchain-chess/0-setup.md:51
msgid ""
"```rust,ignore\n"
"#[derive(Model)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn : (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: ()\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Model)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"enum PieceType {\n"
"    WhitePawn : (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: ()\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid "## Basic systems"
msgstr "## Systems básicos"

#: src/tutorial/onchain-chess/0-setup.md:82
msgid "Starting from the next chapter, you will implement the `actions_contract.cairo` logic."
msgstr "A partir del próximo capítulo, implementará la lógica `actions_contract.cairo`."

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "Create `actions_contract.cairo` inside the src folder. the file should contain a basic contract."
msgstr ""
"Cree `actions_contract.cairo` dentro de la carpeta src. el archivo debe contener un contrato básico."

#: src/tutorial/onchain-chess/0-setup.md:86
msgid "For example, `actions_contract.cairo` should look like this:"
msgstr "Por ejemplo, `actions_contract.cairo` debería verse así:"

#: src/tutorial/onchain-chess/0-setup.md:88
msgid ""
"```rust,ignore\n"
"#[starknet::contract]\n"
"mod actions {\n"
"    \n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[starknet::contract]\n"
"mod actions {\n"
"    \n"
"    #[storage]\n"
"    struct Storage {}\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:96
msgid ""
"It should be noted that systems are cairo contracts, by implication, rather than implementing the game "
"logic in systems, we are implementing it in a contract."
msgstr ""
"Cabe señalar que los Systems son contratos de Cairo, por implicación, en lugar de implementar la lógica "
"del juego en los Systems, la estamos implementando en un contrato."

#: src/tutorial/onchain-chess/0-setup.md:98
msgid "## Compile your project"
msgstr "## Compila tu proyecto"

#: src/tutorial/onchain-chess/0-setup.md:100
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr "Ahora prueba con `sozo build` para compilar. ¿Enfrentó algunos errores?"

#: src/tutorial/onchain-chess/0-setup.md:102 src/tutorial/onchain-chess/0-setup.md:147
msgid ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:106
msgid ""
"You would probably faced some trait implementation errors, which you can implement as a derive like:"
msgstr ""
"Probablemente haya enfrentado algunos errores de implementación de trait, que puede implementar como una "
"derivación como:"

#: src/tutorial/onchain-chess/0-setup.md:108
msgid ""
"```rust,ignore\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum PieceType {\n"
"    WhitePawn: (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: (),\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum PieceType {\n"
"    WhitePawn: (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: (),\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:139
msgid ""
"Complied? Great! then let's move on. If not fix other issues as above, so that you can run the `sozo "
"build` command successfully."
msgstr ""
"¿Cumplido? ¡Excelente! entonces sigamos adelante. De lo contrario, solucione otros problemas como se "
"indicó anteriormente, para que pueda ejecutar el comando `sozo build` con éxito."

#: src/tutorial/onchain-chess/0-setup.md:141
msgid "## Run test"
msgstr "## Run test"

#: src/tutorial/onchain-chess/0-setup.md:143
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo test` are important steps to "
"ensure your code is correct."
msgstr ""
"Antes de continuar con el siguiente capítulo, recuerde que `sozo build` y `sozo test` son pasos "
"importantes para garantizar que su código sea correcto."

#: src/tutorial/onchain-chess/0-setup.md:145
msgid "Run sozo test. Did you face any errors?"
msgstr "Ejecute la prueba de sozo. ¿Enfrentó algún error?"

#: src/tutorial/onchain-chess/0-setup.md:151
msgid ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"
msgstr ""
"```sh\n"
"error: Variable not dropped. Trait has no implementation in context:\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:155
msgid ""
"For the no implementation error, implement the PrintTrait to run `sozo test` successfully. For the not "
"dropped error, add the Drop trait. Address other errors by adding derives or implementing them on a case-"
"by-case basis."
msgstr ""
"Para el error de no implementación, implemente PrintTrait para ejecutar la `sozo test`con éxito. Para el "
"error no eliminado, agregue el Drop trait. Solucione otros errores agregando derivaciones o "
"implementándolas caso por caso."

#: src/tutorial/onchain-chess/0-setup.md:157
msgid "## Add more models"
msgstr "## Agregar más Models"

#: src/tutorial/onchain-chess/0-setup.md:159
msgid ""
"Before you move on, add more models so we can use them in the next chapter when creating the action "
"contract."
msgstr ""
"Antes de continuar, agregue más Models para que podamos usarlos en el próximo capítulo al crear el "
"contrato de acción."

#: src/tutorial/onchain-chess/0-setup.md:161
msgid "### Requirements"
msgstr "### Requisitos"

#: src/tutorial/onchain-chess/0-setup.md:163
msgid "- `Color` enum with values White,Black & None"
msgstr "- Enumeración `Color` con valores Blanco, Negro y Ninguno"

#: src/tutorial/onchain-chess/0-setup.md:164
msgid ""
"```rust,ignore\n"
"    White: (),\n"
"    Black: (),\n"
"    None: (),\n"
"```"
msgstr ""
"```rust,ignore\n"
"    White: (),\n"
"    Black: (),\n"
"    None: (),\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:170
msgid "- `Game` model:"
msgstr "- Model `Game`:"

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Color,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    winner: Color,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:178
msgid "- `GameTurn` model:"
msgstr "- Model `GameTurn`:"

#: src/tutorial/onchain-chess/0-setup.md:179
msgid ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"
msgstr ""
"```rust,ignore\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:184
msgid ""
"- Run `sozo build` to see if your code compiles, we'll handle `test` implementiation in the subsequent "
"chapters."
msgstr ""
"- Ejecute `sozo build` para ver si su código se compila; nos encargaremos de la implementación de `test` "
"en los capítulos siguientes."

#: src/tutorial/onchain-chess/0-setup.md:186
msgid "This tutorial is extracted from [here](https://github.com/Akinbola247/chess-dojo/tree/tutorialv3)"
msgstr "Este tutorial está extraído de [aquí](https://github.com/Akinbola247/chess-dojo/tree/tutorialv3)"

#: src/tutorial/onchain-chess/0-setup.md:188
msgid ""
"<details>\n"
"<summary>Click to see full `models.cairo` code</summary>"
msgstr ""
"<detalles>\n"
"<summary>Haga clic para ver el código `models.cairo` completo</summary>"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"```rust,ignore\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"use dojo::database::schema::{SchemaIntrospection, Ty, Enum, serialize_member_type};\n"
"\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum PieceType {\n"
"    WhitePawn: (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: (),\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum Color {\n"
"    White: (),\n"
"    Black: (),\n"
"    None: (),\n"
"}\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Color,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"}\n"
"\n"
"\n"
"//printing trait for debug\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"            Color::None(_) => {\n"
"                'None'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"            'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"            PieceType::None(_) => {\n"
"                'None'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"use array::ArrayTrait;\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"use dojo::database::schema::{SchemaIntrospection, Ty, Enum, serialize_member_type};\n"
"\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: PieceType,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum PieceType {\n"
"    WhitePawn: (),\n"
"    WhiteKnight: (),\n"
"    WhiteBishop: (),\n"
"    WhiteRook: (),\n"
"    WhiteQueen: (),\n"
"    WhiteKing: (),\n"
"    BlackPawn: (),\n"
"    BlackKnight: (),\n"
"    BlackBishop: (),\n"
"    BlackRook: (),\n"
"    BlackQueen: (),\n"
"    BlackKing: (),\n"
"    None: (),\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq, Introspect)]\n"
"enum Color {\n"
"    White: (),\n"
"    Black: (),\n"
"    None: (),\n"
"}\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Color,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"#[derive(Model, Drop, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color\n"
"}\n"
"\n"
"\n"
"//printing trait for debug\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"            Color::None(_) => {\n"
"                'None'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"            'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"            PieceType::None(_) => {\n"
"                'None'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:329
msgid "</details>"
msgstr "</details>"

#: src/tutorial/onchain-chess/0-setup.md:331
msgid "Congratulations! You've completed the basic setup for building an on-chain chess game 🎉"
msgstr "¡Felicidades! Has completado la configuración básica para crear un juego de ajedrez on-chain 🎉"

#: src/tutorial/onchain-chess/1-action.md:1
msgid "# 1. Action_Contract"
msgstr "# 1. Action_Contract"

#: src/tutorial/onchain-chess/1-action.md:3
msgid ""
"This chapter will address implementing `action_contract.cairo`, which spawns the game & squares "
"containing pieces and also allow players to move pieces."
msgstr ""
"Este capítulo abordará la implementación de `action_contract.cairo`, que genera el juego y los cuadrados "
"que contienen piezas y también permite a los jugadores mover piezas."

#: src/tutorial/onchain-chess/1-action.md:5
msgid "## What is `action_contract`?"
msgstr "## ¿Qué es `action_contract`?"

#: src/tutorial/onchain-chess/1-action.md:7
msgid ""
"To play chess, you need, to start game, spawn the pieces, and move around the board. the "
"`action_contract` has two dominant functions `spawn_game` function which spawns the game entity and "
"places each \n"
"piece in its proper position on the board and the `move` funtion which allows pieces to be moved around "
"the board."
msgstr ""
"Para jugar al ajedrez, necesitas comenzar el juego, generar las piezas y moverte por el tablero. El "
"`action_contract` tiene dos funciones dominantes: la función `spawn_game` que genera la entidad del "
"juego y coloca cada pieza en su posición adecuada en el tablero y la función `move` que permite mover "
"las piezas por el tablero."

#: src/tutorial/onchain-chess/1-action.md:10
msgid ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" height=\"auto\">"
msgstr ""
"<p align=\"center\">\n"
"<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" height=\"auto\">"

#: src/tutorial/onchain-chess/1-action.md:13
msgid "## Requirements"
msgstr "## Requisitos"

#: src/tutorial/onchain-chess/1-action.md:15
msgid "_Copy the unit tests below and paste them at the bottom of your `action_contract.cairo` file._"
msgstr ""
"_Copie las pruebas unitarias a continuación y péguelas en la parte inferior de su archivo "
"`action_contract.cairo`._"

#: src/tutorial/onchain-chess/1-action.md:17
msgid ""
"1. Write an interface for the `initiate_system` contract and define your functions. In this case, `move` "
"and `spawn_game` "
msgstr ""
"1. Escriba una interfaz para el contrato `initiate_system` y defina sus funciones. En este caso, `move` "
"y `spawn_game` "

#: src/tutorial/onchain-chess/1-action.md:18
msgid ""
"```shell\n"
"    #[starknet::interface]\n"
"    trait IActions<ContractState> {\n"
"        fn move(\n"
"            self: @ContractState,\n"
"            curr_position: (u32, u32),\n"
"            next_position: (u32, u32),\n"
"            caller: ContractAddress, //player\n"
"            game_id: felt252\n"
"        );\n"
"        fn spawn_game(\n"
"            self: @ContractState, white_address: ContractAddress, black_address: ContractAddress, \n"
"        );\n"
"    }\n"
"```"
msgstr ""
"```shell\n"
"    #[starknet::interface]\n"
"    trait IActions<ContractState> {\n"
"        fn move(\n"
"            self: @ContractState,\n"
"            curr_position: (u32, u32),\n"
"            next_position: (u32, u32),\n"
"            caller: ContractAddress, //player\n"
"            game_id: felt252\n"
"        );\n"
"        fn spawn_game(\n"
"            self: @ContractState, white_address: ContractAddress, black_address: ContractAddress, \n"
"        );\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/1-action.md:33
msgid ""
"2. Bring in required imports into the contract and initialize storage with the `world_dispatcher` in it "
"like this :"
msgstr ""
"2. Incorpore las importaciones requeridas al contrato e inicialice el almacenamiento con "
"`world_dispatcher` de esta manera:"

#: src/tutorial/onchain-chess/1-action.md:34
msgid ""
"```shell\n"
"    #[starknet::contract]\n"
"        mod actions {\n"
"        use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"        use debug::PrintTrait;\n"
"        use starknet::ContractAddress;\n"
"        use dojo_chess::models::{Color, Square, PieceType, Game, GameTurn};\n"
"        use super::IActions;\n"
"\n"
"        #[storage]\n"
"        struct Storage {\n"
"            world_dispatcher: IWorldDispatcher, \n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```shell\n"
"    #[starknet::contract]\n"
"        mod actions {\n"
"        use dojo::world::{IWorldDispatcher, IWorldDispatcherTrait};\n"
"        use debug::PrintTrait;\n"
"        use starknet::ContractAddress;\n"
"        use dojo_chess::models::{Color, Square, PieceType, Game, GameTurn};\n"
"        use super::IActions;\n"
"\n"
"        #[storage]\n"
"        struct Storage {\n"
"            world_dispatcher: IWorldDispatcher, \n"
"        }\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/1-action.md:49
msgid "should be noted that `actions` is the contract name."
msgstr "Cabe señalar que `actions` es el nombre del contrato."

#: src/tutorial/onchain-chess/1-action.md:51
msgid ""
"3. Write a `spawn_game` function that accepts the `white address`, and `black address` as input and set "
"necessary states using `set!(...)`.Implement the game entity, comprised of the `Game` model and "
"`GameTurn` model we created in the `models.cairo` and Implement the square entities from a1 to h8 "
"containing the correct `PieceType` in the `spawn_game` fn."
msgstr ""
"3. Escriba una función `spawn_game` que acepte la `white address` y `black address` como entrada y "
"establezca los estados necesarios usando `set!(...)`. Implemente la entity del juego, compuesta por el "
"model `Game` y el model `GameTurn` que creamos en `models.cairo` e implementamos las entities cuadradas "
"de a1 a h8 que contienen el `PiezaType` correcto en `spawn_game` fn."

#: src/tutorial/onchain-chess/1-action.md:52
msgid ""
"```shell\n"
"        #[external(v0)]\n"
"    impl PlayerActionsImpl of IActions<ContractState> {\n"
"        fn spawn_game(\n"
"            self: @ContractState, white_address: ContractAddress, black_address: ContractAddress\n"
"        ) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let game_id = pedersen::pedersen(white_address.into(), black_address.into());\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Game {\n"
"                        game_id: game_id,\n"
"                        winner: Color::None(()),\n"
"                        white: white_address,\n"
"                        black: black_address,\n"
"                        }, GameTurn {\n"
"                        game_id: game_id, turn: Color::White(()), \n"
"                    },\n"
"                )\n"
"            );\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 0, y: 0, piece: PieceType::WhiteRook }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 0, y: 1, piece: PieceType::WhitePawn }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 1, y: 6, piece: PieceType::BlackPawn }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 1, y: 0, piece: PieceType::WhiteKnight }));\n"
"            \n"
"            //the rest of the positions on the board goes here.... \n"
"        }\n"
"```"
msgstr ""
"```shell\n"
"        #[external(v0)]\n"
"    impl PlayerActionsImpl of IActions<ContractState> {\n"
"        fn spawn_game(\n"
"            self: @ContractState, white_address: ContractAddress, black_address: ContractAddress\n"
"        ) {\n"
"            let world = self.world_dispatcher.read();\n"
"            let game_id = pedersen::pedersen(white_address.into(), black_address.into());\n"
"            set!(\n"
"                world,\n"
"                (\n"
"                    Game {\n"
"                        game_id: game_id,\n"
"                        winner: Color::None(()),\n"
"                        white: white_address,\n"
"                        black: black_address,\n"
"                        }, GameTurn {\n"
"                        game_id: game_id, turn: Color::White(()), \n"
"                    },\n"
"                )\n"
"            );\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 0, y: 0, piece: PieceType::WhiteRook }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 0, y: 1, piece: PieceType::WhitePawn }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 1, y: 6, piece: PieceType::BlackPawn }));\n"
"\n"
"            set!(world, (Square { game_id: game_id, x: 1, y: 0, piece: PieceType::WhiteKnight }));\n"
"            \n"
"            //the rest of the positions on the board goes here.... \n"
"        }\n"
"```"

#: src/tutorial/onchain-chess/1-action.md:85
msgid ""
"4. Write a `move` function that accepts the `current position`, `next position`, `caller address`, and "
"`game id`. The `move` function should look like this:"
msgstr ""
"4. Escriba una función`move` que acepte la `current position`, `next position`, `caller address`, y "
"`game id`. La función `move` debería verse así:"

#: src/tutorial/onchain-chess/1-action.md:86
msgid ""
"```shell \n"
"    fn move(\n"
"            self: @ContractState,\n"
"            curr_position: (u32, u32),\n"
"            next_position: (u32, u32),\n"
"            caller: ContractAddress, //player\n"
"            game_id: felt252\n"
"        ) {\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            let (current_x, current_y) = curr_position;\n"
"            let (next_x, next_y) = next_position;\n"
"            current_x.print();\n"
"            current_y.print();\n"
"\n"
"            next_x.print();\n"
"            next_y.print();\n"
"\n"
"            let mut current_square = get!(world, (game_id, current_x, current_y), (Square));\n"
"\n"
"            // check if next_position is out of board or not\n"
"            assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"            // check if this is the right piece type move\n"
"            assert(\n"
"                is_right_piece_move(current_square.piece, curr_position, next_position),\n"
"                'Should be right piece move'\n"
"            );\n"
"            let target_piece = current_square.piece;\n"
"            // make current_square piece none and move piece to next_square \n"
"            current_square.piece = PieceType::None(());\n"
"            let mut next_square = get!(world, (game_id, next_x, next_y), (Square));\n"
"\n"
"            // check the piece already in next_suqare\n"
"            let maybe_next_square_piece = next_square.piece;\n"
"\n"
"            if maybe_next_square_piece == PieceType::None(()) {\n"
"                next_square.piece = target_piece;\n"
"            } else {\n"
"                if is_piece_is_mine(maybe_next_square_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            }\n"
"\n"
"            set!(world, (next_square));\n"
"            set!(world, (current_square));\n"
"        }\n"
"        //helper functions within the fn move. don't worry, we'll address logic content in the next "
"chapter \n"
"        fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_right_piece_move(maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, "
"u32)) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"    }\n"
"``` "
msgstr ""
"```shell \n"
"    fn move(\n"
"            self: @ContractState,\n"
"            curr_position: (u32, u32),\n"
"            next_position: (u32, u32),\n"
"            caller: ContractAddress, //player\n"
"            game_id: felt252\n"
"        ) {\n"
"            let world = self.world_dispatcher.read();\n"
"\n"
"            let (current_x, current_y) = curr_position;\n"
"            let (next_x, next_y) = next_position;\n"
"            current_x.print();\n"
"            current_y.print();\n"
"\n"
"            next_x.print();\n"
"            next_y.print();\n"
"\n"
"            let mut current_square = get!(world, (game_id, current_x, current_y), (Square));\n"
"\n"
"            // check if next_position is out of board or not\n"
"            assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"            // check if this is the right piece type move\n"
"            assert(\n"
"                is_right_piece_move(current_square.piece, curr_position, next_position),\n"
"                'Should be right piece move'\n"
"            );\n"
"            let target_piece = current_square.piece;\n"
"            // make current_square piece none and move piece to next_square \n"
"            current_square.piece = PieceType::None(());\n"
"            let mut next_square = get!(world, (game_id, next_x, next_y), (Square));\n"
"\n"
"            // check the piece already in next_suqare\n"
"            let maybe_next_square_piece = next_square.piece;\n"
"\n"
"            if maybe_next_square_piece == PieceType::None(()) {\n"
"                next_square.piece = target_piece;\n"
"            } else {\n"
"                if is_piece_is_mine(maybe_next_square_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            }\n"
"\n"
"            set!(world, (next_square));\n"
"            set!(world, (current_square));\n"
"        }\n"
"        //helper functions within the fn move. don't worry, we'll address logic content in the next "
"chapter \n"
"        fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"        fn is_right_piece_move(maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, "
"u32)) -> bool {\n"
"            //the rest of the code ....\n"
"        }\n"
"    }\n"
"``` "

#: src/tutorial/onchain-chess/1-action.md:150
msgid "7. Run `sozo test` and pass all the tests."
msgstr "7. Ejecute `sozo test` y pase todas las pruebas."

#: src/tutorial/onchain-chess/1-action.md:152
msgid "## Test Flow"
msgstr "## Test Flow"

#: src/tutorial/onchain-chess/1-action.md:154
msgid ""
"- Spawn the test world (`spawn_test_world`) that imports the models in testing.\n"
"- deploy actions contract\n"
"- interact with `spawn_game` function in the `actions` contract by providing white and black player's "
"wallet addresses as inputs.\n"
"- Retrieve the game entity and piece entity created in `actions` contract.\n"
"- Ensure the game has been correctly created.\n"
"- Verify that each `Piece` is located in the correct `Square`."
msgstr ""
"- Generar el mundo de prueba (`spawn_test_world`) que importa los model en prueba.\n"
"- Implementar contrato de acciones\n"
"- Interactuar con la función `spawn_game` en el contrato de `actions` proporcionando las direcciones de "
"billetera de los jugadores blancos y negros como entradas.\n"
"- Recuperar la entidad de juego y la entidad de pieza creadas en el contrato de `actions`.\n"
"- Asegúrate de que el juego se haya creado correctamente.\n"
"- Verificar que cada `Piece` esté ubicada en el `Square` correcto."

#: src/tutorial/onchain-chess/1-action.md:161
msgid "## Unit Tests"
msgstr "## Tests unitarios"

#: src/tutorial/onchain-chess/1-action.md:163
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::{spawn_test_world, deploy_contract};\n"
"    use dojo_chess::models::{Game, game, GameTurn, game_turn, Square, square, PieceType};\n"
"\n"
"    use dojo_chess::actions_contract::actions;\n"
"    use starknet::class_hash::Felt252TryIntoClassHash;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use dojo::world::IWorldDispatcher;\n"
"    use core::array::SpanTrait;\n"
"    use super::{IActionsDispatcher, IActionsDispatcherTrait};\n"
"\n"
"    // helper setup function\n"
"    // reusable function for tests\n"
"    fn setup_world() -> (IWorldDispatcher, IActionsDispatcher) {\n"
"        // models\n"
"        let mut models = array![\n"
"            game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH\n"
"        ];\n"
"        // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"\n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"\n"
"        (world, actions_system)\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"\n"
"        //system calls\n"
"        actions_system.spawn_game(white, black);\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, game_id, (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        assert(a1.piece == PieceType::WhiteRook, 'should be White Rook');\n"
"        assert(a1.piece != PieceType::None, 'should have piece');\n"
"    }\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"        actions_system.spawn_game(white, black);\n"
"\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn');\n"
"        assert(a2.piece != PieceType::None, 'should have piece');\n"
"\n"
"        actions_system.move((0, 1), (0, 2), white.into(), game_id);\n"
"\n"
"        let c3 = get!(world, (game_id, 0, 2), (Square));\n"
"        assert(c3.piece == PieceType::WhitePawn, 'should be White Pawn');\n"
"        assert(c3.piece != PieceType::None, 'should have piece');\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::{spawn_test_world, deploy_contract};\n"
"    use dojo_chess::models::{Game, game, GameTurn, game_turn, Square, square, PieceType};\n"
"\n"
"    use dojo_chess::actions_contract::actions;\n"
"    use starknet::class_hash::Felt252TryIntoClassHash;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use dojo::world::IWorldDispatcher;\n"
"    use core::array::SpanTrait;\n"
"    use super::{IActionsDispatcher, IActionsDispatcherTrait};\n"
"\n"
"    // helper setup function\n"
"    // reusable function for tests\n"
"    fn setup_world() -> (IWorldDispatcher, IActionsDispatcher) {\n"
"        // models\n"
"        let mut models = array![\n"
"            game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH\n"
"        ];\n"
"        // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"\n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"\n"
"        (world, actions_system)\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"\n"
"        //system calls\n"
"        actions_system.spawn_game(white, black);\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, game_id, (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        assert(a1.piece == PieceType::WhiteRook, 'should be White Rook');\n"
"        assert(a1.piece != PieceType::None, 'should have piece');\n"
"    }\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"        actions_system.spawn_game(white, black);\n"
"\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn');\n"
"        assert(a2.piece != PieceType::None, 'should have piece');\n"
"\n"
"        actions_system.move((0, 1), (0, 2), white.into(), game_id);\n"
"\n"
"        let c3 = get!(world, (game_id, 0, 2), (Square));\n"
"        assert(c3.piece == PieceType::WhitePawn, 'should be White Pawn');\n"
"        assert(c3.piece != PieceType::None, 'should have piece');\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/1-action.md:242 src/tutorial/onchain-chess/2-legal.md:163
msgid "## Need help?"
msgstr "## ¿Necesitas ayuda?"

#: src/tutorial/onchain-chess/1-action.md:244 src/tutorial/onchain-chess/2-legal.md:165
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community](https://discord.gg/akd2yfuRS3)!"
msgstr ""
"Si estás atascado, ¡no dudes en hacer preguntas en la [comunidad Dojo](https://discord.gg/akd2yfuRS3)!"

#: src/tutorial/onchain-chess/1-action.md:246
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/tutorialv3/src/actions_contract."
"cairo) for chapter 1 here."
msgstr ""
"Puede encontrar la [respuesta](https://github.com/rkdud007/chess-dojo/blob/tutorialv3/src/"
"actions_contract.cairo) para el capítulo 1 aquí."

#: src/tutorial/onchain-chess/2-legal.md:1
msgid "# 2. Check Legal Move"
msgstr "# 2. Verificar Movimiento Legal"

#: src/tutorial/onchain-chess/2-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr "En este capítulo, crearemos funciones para verificar:"

#: src/tutorial/onchain-chess/2-legal.md:5
msgid ""
"- If the next move goes outside the board.\n"
"- If there's a piece that can be captured.\n"
"- If the next move is allowed for the type of piece.\n"
"- If the user can allow to make a action (based on the piece's color).\n"
"- ... You can also add other custom check functions."
msgstr ""
"- Si el siguiente movimiento sale fuera del tablero.\n"
"- Si hay alguna pieza que se pueda capturar.\n"
"- Si el siguiente movimiento está permitido por el tipo de pieza.\n"
"- Si el usuario puede permitir realizar una acción (según el color de la pieza).\n"
"-... También puede agregar otras funciones de verificación personalizadas."

#: src/tutorial/onchain-chess/2-legal.md:11
msgid "## Make Check Functions"
msgstr "## Realizar Funciones de Verificación"

#: src/tutorial/onchain-chess/2-legal.md:13
msgid ""
"We need to add some check functions in `actions` contract. These will help make sure the next move is "
"allowed."
msgstr ""
"Necesitamos agregar algunas funciones de verificación en el contrato de `actions`. Esto ayudará a "
"garantizar que se permita el siguiente movimiento."

#: src/tutorial/onchain-chess/2-legal.md:15
msgid "1. See if player is moving the right piece"
msgstr "1. Ver si el jugador está moviendo la pieza correcta"

#: src/tutorial/onchain-chess/2-legal.md:17
msgid ""
"```rust,ignore\n"
"   fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"        false\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"   fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"        false\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:23
msgid "2. See if the next spot is still on the board."
msgstr "2. Vea si el siguiente lugar todavía está en el tablero."

#: src/tutorial/onchain-chess/2-legal.md:25
msgid ""
"```rust,ignore\n"
"      fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"        let (n_x, n_y) = next_position;\n"
"        if n_x > 7 || n_x < 0 {\n"
"            return false;\n"
"        }\n"
"        if n_y > 7 || n_y < 0 {\n"
"            return false;\n"
"        }\n"
"        true\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"      fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"        let (n_x, n_y) = next_position;\n"
"        if n_x > 7 || n_x < 0 {\n"
"            return false;\n"
"        }\n"
"        if n_y > 7 || n_y < 0 {\n"
"            return false;\n"
"        }\n"
"        true\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:38
msgid "3. See if the person trying the move is doing it at the right time and with their piece color."
msgstr ""
"3. Observa si la persona que intenta el movimiento lo hace en el momento adecuado y con el color de su "
"pieza."

#: src/tutorial/onchain-chess/2-legal.md:40
msgid ""
"```rust,ignore\n"
"    fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"        true\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"        true\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:46
msgid "4. see if it's the right move"
msgstr "4. Ver si es el movimiento correcto"

#: src/tutorial/onchain-chess/2-legal.md:47
msgid ""
"```rust,ignore\n"
"    fn is_right_piece_move(\n"
"        maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, u32)\n"
"    ) -> bool {\n"
"        let (c_x, c_y) = curr_position;\n"
"        let (n_x, n_y) = next_position;\n"
"        match maybe_piece {\n"
"            PieceType::WhitePawn => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteKnight => {\n"
"                if n_x == c_x + 2 && n_y == c_x + 1 {\n"
"                    return true;\n"
"                }\n"
"\n"
"                panic(array!['Knight illegal move'])\n"
"            },\n"
"            PieceType::WhiteBishop => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteRook => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteQueen => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteKing => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackPawn => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackKnight => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackBishop => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackRook => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackQueen => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackKing => {\n"
"                true\n"
"            },\n"
"            PieceType::None(_) => panic(array!['Should not move empty square']),\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    fn is_right_piece_move(\n"
"        maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, u32)\n"
"    ) -> bool {\n"
"        let (c_x, c_y) = curr_position;\n"
"        let (n_x, n_y) = next_position;\n"
"        match maybe_piece {\n"
"            PieceType::WhitePawn => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteKnight => {\n"
"                if n_x == c_x + 2 && n_y == c_x + 1 {\n"
"                    return true;\n"
"                }\n"
"\n"
"                panic(array!['Knight illegal move'])\n"
"            },\n"
"            PieceType::WhiteBishop => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteRook => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteQueen => {\n"
"                true\n"
"            },\n"
"            PieceType::WhiteKing => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackPawn => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackKnight => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackBishop => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackRook => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackQueen => {\n"
"                true\n"
"            },\n"
"            PieceType::BlackKing => {\n"
"                true\n"
"            },\n"
"            PieceType::None(_) => panic(array!['Should not move empty square']),\n"
"        }\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:98
msgid "5. You can also add other check functions to be extra sure the move is allowed."
msgstr ""
"5. También puede agregar otras funciones de verificación para asegurarse de que el movimiento esté "
"permitido."

#: src/tutorial/onchain-chess/2-legal.md:100
msgid ""
"Once you've made these check functions, you can use them in the `move` function in the contract as "
"illustrated in the previous chapter [here](1-action.md). You can decide how to set them up and which "
"ones to use. We'll give an example to help:"
msgstr ""
"Una vez que haya realizado estas funciones de verificación, puede usarlas en la función `move` del "
"contrato como se ilustra en el capítulo anterior [aquí](1-action.md). Puedes decidir cómo configurarlos "
"y cuáles usar. Daremos un ejemplo para ayudar:"

#: src/tutorial/onchain-chess/2-legal.md:102
msgid "## Testing Each Function"
msgstr "## Testing de Cada Función"

#: src/tutorial/onchain-chess/2-legal.md:104
msgid ""
"Since we have different check functions, we need to test each one. To make this easier, let's use parts "
"that are the same for many tests."
msgstr ""
"Como tenemos diferentes funciones de verificación, debemos probar cada una. Para hacerlo más fácil, "
"usemos piezas que sean iguales para muchas pruebas."

#: src/tutorial/onchain-chess/2-legal.md:106
msgid ""
"First, make a helper function called `setup_world`. This will give back an `IWorldDispatcher` and "
"`IActionsDispatcher` that we can use many times in the tests."
msgstr ""
"Primero, cree una función auxiliar llamada `setup_world`. Esto nos devolverá un `IWorldDispatcher` y un "
"`IActionsDispatcher` que podremos usar muchas veces en las pruebas."

#: src/tutorial/onchain-chess/2-legal.md:108
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"      fn setup_world() -> (IWorldDispatcher, IActionsDispatcher) {\n"
"        // models\n"
"        let mut models = array![\n"
"            game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH\n"
"        ];\n"
"        // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"\n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"\n"
"        (world, actions_system)\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"      fn setup_world() -> (IWorldDispatcher, IActionsDispatcher) {\n"
"        // models\n"
"        let mut models = array![\n"
"            game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH\n"
"        ];\n"
"        // deploy world with models\n"
"        let world = spawn_test_world(models);\n"
"\n"
"        // deploy systems contract\n"
"        let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"\n"
"        (world, actions_system)\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:128
msgid "Then, our main `test_move` function will be simpler."
msgstr "Entonces, nuestra función principal `test_move` será más simple."

#: src/tutorial/onchain-chess/2-legal.md:130
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let (move_system, initate_system) = setup_world();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let (move_system, initate_system) = setup_world();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:142
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. Let's make a "
"`test_piecetype_illegal` function. This will check if the `is_right_piece_move` function, that you "
"implemented in the move system, works right."
msgstr ""
"Ahora podemos hacer pruebas que muestren errores si intentamos movimientos que no están permitidos. "
"Hagamos una función `test_piecetype_illegal`. Esto verificará si la función `is_right_piece_move`, que "
"implementó en el sistema de movimiento, funciona correctamente."

#: src/tutorial/onchain-chess/2-legal.md:144
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {    \n"
"    let white = starknet::contract_address_const::<0x01>();\n"
"    let black = starknet::contract_address_const::<0x02>();\n"
"    let (world, actions_system) = setup_world();\n"
"    let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"    let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"    assert(b1.piece == PieceType::WhiteKnight, 'should be White Knight');\n"
"\n"
"    // Knight cannot move to that square\n"
"    actions_system.move((1,0),(2,3),white.into(), game_id);\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {    \n"
"    let white = starknet::contract_address_const::<0x01>();\n"
"    let black = starknet::contract_address_const::<0x02>();\n"
"    let (world, actions_system) = setup_world();\n"
"    let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"    let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"    assert(b1.piece == PieceType::WhiteKnight, 'should be White Knight');\n"
"\n"
"    // Knight cannot move to that square\n"
"    actions_system.move((1,0),(2,3),white.into(), game_id);\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/2-legal.md:161
msgid "Finish by making your tests. These should find wrong moves and give back errors."
msgstr "Termina haciendo tus tests. Estos deberían encontrar movimientos incorrectos y devolver errores."

#: src/tutorial/onchain-chess/3-test.md:1
msgid "# 3 Test Contract"
msgstr "# 3 Contrato de Test"

#: src/tutorial/onchain-chess/3-test.md:3
msgid "In this chapter, we'll use everything we've learned to run a full chess game scenario."
msgstr ""
"En este capítulo, usaremos todo lo que hemos aprendido para ejecutar un escenario de juego de ajedrez "
"completo."

#: src/tutorial/onchain-chess/3-test.md:5
msgid "Here's what we'll do in our test:"
msgstr "Esto es lo que haremos en nuestro test:"

#: src/tutorial/onchain-chess/3-test.md:7
msgid ""
"1. Spawn `white_pawn_1` to (0,1)\n"
"2. Move `white_pawn_1` to (0,3)\n"
"3. Move `black_pawn_2` to (1,6)\n"
"4. Move `white_pawn_1` to (0,4)\n"
"5. Move `black_pawn_2` to (1,4)\n"
"6. Move `white_pawn_1` to (1,4)\n"
"7. Capture `black_pawn_2`"
msgstr ""
"1. Spawn `white_pawn_1` en (0,1)\n"
"2. Move `white_pawn_1` a (0,3)\n"
"3. Move `black_pawn_2` a (1,6)\n"
"4. Move `white_pawn_1` a (0,4)\n"
"5. Move `black_pawn_2` a (1,4)\n"
"6. Move `white_pawn_1` a (1,4)\n"
"7. Capture `black_pawn_2`"

#: src/tutorial/onchain-chess/3-test.md:15
msgid ""
"To place the pieces, use our `spawn_game` function in our `actions` contract. For moving them, use the "
"`move_system` contract. Remember to check if a piece can be captured when using `move_system`."
msgstr ""
"Para colocar las piezas, use nuestra función `spawn_game` en nuestro contrato de `actions`. Para "
"moverlos, utilice el contrato `move_system`. Recuerde verificar si se puede capturar una pieza al usar "
"`move_system`."

#: src/tutorial/onchain-chess/3-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr "Antes de llegar al código, configure su test de integración de esta manera:"

#: src/tutorial/onchain-chess/3-test.md:19
msgid ""
"- Copy the test below and add it to your `src/tests.cairo` file.\n"
"- Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod tests;` line."
msgstr ""
"- Copie la prueba a continuación y agréguela a su archivo `src/tests.cairo`.\n"
"- Crea un `test.cairo` en tu src y actualiza `lib.cairo` agregando la línea `mod tests;`."

#: src/tutorial/onchain-chess/3-test.md:22
msgid "## Full Code"
msgstr "## Full Code"

#: src/tutorial/onchain-chess/3-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::models::{Game, game, GameTurn, game_turn, Square, square, PieceType};\n"
"\n"
"    use dojo_chess::actions_contract::actions;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"    use dojo_chess::actions_contract::tests::setup_world;\n"
"    use dojo_chess::actions_contract::{IActionsDispatcher, IActionsDispatcherTrait};\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"\n"
"        //system calls\n"
"        actions_system.spawn_game(white, black);\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn in (0,1)');\n"
"        assert(a2.piece != PieceType::None, 'should have piece in (0,1)');\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        assert(b7.piece == PieceType::BlackPawn, 'should be Black Pawn in (1,6)');\n"
"        assert(b7.piece != PieceType::None, 'should have piece in (1,6)');\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        actions_system.move((0, 1), (0, 3), white.into(), game_id);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        assert(a4.piece == PieceType::WhitePawn, 'should be White Pawn in (0,3)');\n"
"        assert(a4.piece != PieceType::None, 'should have piece in (0,3)');\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        actions_system.move((1, 6), (1, 4), white.into(), game_id);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        assert(b5.piece == PieceType::BlackPawn, 'should be Black Pawn in (1,4)');\n"
"        assert(b5.piece != PieceType::None, 'should have piece in (1,4)');\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        actions_system.move((0, 3), (1, 4), white.into(), game_id);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        assert(b5.piece == PieceType::WhitePawn, 'should be White Pawn in (1,4)');\n"
"        assert(b5.piece != PieceType::None, 'should have piece in (1,4)');\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::models::{Game, game, GameTurn, game_turn, Square, square, PieceType};\n"
"\n"
"    use dojo_chess::actions_contract::actions;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"    use dojo_chess::actions_contract::tests::setup_world;\n"
"    use dojo_chess::actions_contract::{IActionsDispatcher, IActionsDispatcherTrait};\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        let (world, actions_system) = setup_world();\n"
"\n"
"        //system calls\n"
"        actions_system.spawn_game(white, black);\n"
"        let game_id = pedersen::pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn in (0,1)');\n"
"        assert(a2.piece != PieceType::None, 'should have piece in (0,1)');\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        assert(b7.piece == PieceType::BlackPawn, 'should be Black Pawn in (1,6)');\n"
"        assert(b7.piece != PieceType::None, 'should have piece in (1,6)');\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        actions_system.move((0, 1), (0, 3), white.into(), game_id);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        assert(a4.piece == PieceType::WhitePawn, 'should be White Pawn in (0,3)');\n"
"        assert(a4.piece != PieceType::None, 'should have piece in (0,3)');\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        actions_system.move((1, 6), (1, 4), white.into(), game_id);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        assert(b5.piece == PieceType::BlackPawn, 'should be Black Pawn in (1,4)');\n"
"        assert(b5.piece != PieceType::None, 'should have piece in (1,4)');\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        actions_system.move((0, 3), (1, 4), white.into(), game_id);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        assert(b5.piece == PieceType::WhitePawn, 'should be White Pawn in (1,4)');\n"
"        assert(b5.piece != PieceType::None, 'should have piece in (1,4)');\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:90
msgid "## Diving into the Code"
msgstr "## Profundizando en el Código"

#: src/tutorial/onchain-chess/3-test.md:91
msgid "First, we'll set up the players and their colors."
msgstr "Primero, configuraremos los jugadores y sus colores."

#: src/tutorial/onchain-chess/3-test.md:93
msgid ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"
msgstr ""
"```rust,ignore\n"
"   let white = starknet::contract_address_const::<0x01>();\n"
"   let black = starknet::contract_address_const::<0x02>();\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:98
msgid ""
"We should list both models with each having CLASS_HASH as elements and then we deploy world to models "
"with `spawn_test_world`"
msgstr ""
"Deberíamos enumerar ambos models, cada uno con CLASS_HASH como elementos y luego implementar el mundo en "
"los modelos con `spawn_test_world`."

#: src/tutorial/onchain-chess/3-test.md:100
msgid ""
"```rust,ignore\n"
"//models\n"
" let mut models = array![game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH];\n"
" let world = spawn_test_world(models);\n"
"```"
msgstr ""
"```rust,ignore\n"
"//models\n"
" let mut models = array![game::TEST_CLASS_HASH, game_turn::TEST_CLASS_HASH, square::TEST_CLASS_HASH];\n"
" let world = spawn_test_world(models);\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:105
msgid ""
"We then deploy our system contracts in our helper function in `action_contract` file. we only imported "
"it in our test file."
msgstr ""
"Luego implementamos nuestros contratos del sistema en nuestra función auxiliar en el archivo "
"`action_contract`. solo lo importamos en nuestro archivo de test."

#: src/tutorial/onchain-chess/3-test.md:106
msgid ""
"```rust,ignore\n"
"    let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"```"
msgstr ""
"```rust,ignore\n"
"    let contract_address = world\n"
"            .deploy_contract('salt', actions::TEST_CLASS_HASH.try_into().unwrap());\n"
"        let actions_system = IActionsDispatcher { contract_address };\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:112
msgid ""
"We use `spawn_game` function in `actions_contract.cairo` to put our Square pieces on the board. Each "
"Square holds a piece. The system's `spawn_game` function needs some input i.e the addresses of the "
"players."
msgstr ""
"Usamos la función `spawn_game` en `actions_contract.cairo` para colocar nuestras piezas cuadradas en el "
"tablero. Cada cuadrado contiene una pieza. La función `spawn_game` del sistema necesita alguna entrada, "
"es decir, las direcciones de los jugadores."

#: src/tutorial/onchain-chess/3-test.md:114
msgid ""
"```rust,ignore\n"
"        // spawn\n"
"         actions_system.spawn_game(white, black);\n"
"```"
msgstr ""
"```rust,ignore\n"
"        // spawn\n"
"         actions_system.spawn_game(white, black);\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:119
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that exists on the square, you need to "
"use the keys of the `Square` model, which are `game_id`, `x`, and `y`. Do the same check for the Black "
"Pawn."
msgstr ""
"Comprobemos si hay un peón blanco en (0,1). Recuerde, para obtener una pieza que existe en el cuadrado, "
"debe usar las claves del model `Square`, que son `game_id`,`x`, e `y`. Haz la misma prueba con el peón "
"negro."

#: src/tutorial/onchain-chess/3-test.md:121
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn in (0,1)');\n"
"        assert(a2.piece != PieceType::None, 'should have piece in (0,1)');\n"
"```"
msgstr ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        assert(a2.piece == PieceType::WhitePawn, 'should be White Pawn in (0,1)');\n"
"        assert(a2.piece != PieceType::None, 'should have piece in (0,1)');\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:128
msgid ""
"After setting up the board, use `move` function in the contract to make moves. Provide the current "
"position, the next position, the player's address, and the game id."
msgstr ""
"Después de configurar el tablero, use la función `move` en el contrato para realizar movimientos. "
"Proporcione la posición actual, la siguiente posición, la dirección del jugador y la identificación del "
"juego."

#: src/tutorial/onchain-chess/3-test.md:130
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        actions_system.move((0, 1), (0, 3), white.into(), game_id);\n"
"```"
msgstr ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        actions_system.move((0, 1), (0, 3), white.into(), game_id);\n"
"```"

#: src/tutorial/onchain-chess/3-test.md:135
msgid "Keep moving pieces and checking if they're in the right places."
msgstr "Sigue moviendo piezas y comprobando si están en los lugares correctos."

#: src/tutorial/onchain-chess/3-test.md:137
msgid "## Congratulations!"
msgstr "## ¡Felicidades!"

#: src/tutorial/onchain-chess/3-test.md:139
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This tutorial was just the "
"beginning. There are many ways to make the game better, like optimizing parts, adding checks, or "
"considering special cases. If you want to do more with this chess game, try these challenges:"
msgstr ""
"¡Has creado los contratos básicos para un juego de ajedrez usando el Dojo engine! Este tutorial fue solo "
"el comienzo. Hay muchas formas de mejorar el juego, como optimizar piezas, agregar controles o "
"considerar casos especiales. Si quieres hacer más con este juego de ajedrez, prueba estos desafíos:"

#: src/tutorial/onchain-chess/3-test.md:141
msgid ""
"- Add a checkmate feature. Our game doesn't end now, so decide when it should!\n"
"- Include special moves like castling, En Passant Capture, or Pawn Promotion.\n"
"- Make your own chess rules! You could even create your own version of the [immortal game](https://"
"immortal.game/)"
msgstr ""
"- Agregar una función de jaque mate. Nuestro juego no termina ahora, ¡así que decide cuándo debería "
"terminar!\n"
"- Incluye movimientos especiales como enroque, captura al paso o promoción de peones.\n"
"- ¡Haz tus propias reglas de ajedrez! Incluso podrías crear tu propia versión del [juego inmortal]"
"(https://immortal.game/)"

#: src/tutorial/onchain-chess/3-test.md:145
msgid "Lastly, share your project with others in the [Dojo community](https://discord.gg/akd2yfuRS3)!"
msgstr "¡Por último, comparte tu proyecto con otros en la [comunidad Dojo](https://discord.gg/akd2yfuRS3)!"

#: src/tutorial/onchain-chess/4-utils.md:1
msgid "# 4. Modularize functions"
msgstr "# 4. Modularizar funciones"

#: src/tutorial/onchain-chess/4-utils.md:2
msgid ""
"In order to keep our code has dry as possible, you can modularize your functions. To do this, we'll "
"create an `utils.cairo` file and add the below:"
msgstr ""
"Para mantener nuestro código lo más seco posible, puede modularizar sus funciones. Para hacer esto, "
"crearemos un archivo `utils.cairo` y agregaremos lo siguiente:"

#: src/tutorial/onchain-chess/4-utils.md:3
msgid ""
"```rust,ignore\n"
"use dojo_chess::models::PieceType;\n"
"use starknet::ContractAddress;\n"
"\n"
"fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"     //rest of the code here\n"
"}\n"
"\n"
"fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"    //rest of the code here\n"
"}\n"
"\n"
"fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"    //rest of the code here\n"
"}\n"
"\n"
"fn is_right_piece_move(\n"
"    maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, u32)\n"
") -> bool {\n"
"    //rest of the code here\n"
"    \n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"use dojo_chess::models::PieceType;\n"
"use starknet::ContractAddress;\n"
"\n"
"fn is_piece_is_mine(maybe_piece: PieceType) -> bool {\n"
"     //rest of the code here\n"
"}\n"
"\n"
"fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, game_id: felt252) -> bool {\n"
"    //rest of the code here\n"
"}\n"
"\n"
"fn is_out_of_board(next_position: (u32, u32)) -> bool {\n"
"    //rest of the code here\n"
"}\n"
"\n"
"fn is_right_piece_move(\n"
"    maybe_piece: PieceType, curr_position: (u32, u32), next_position: (u32, u32)\n"
") -> bool {\n"
"    //rest of the code here\n"
"    \n"
"}\n"
"```"

#: src/tutorial/onchain-chess/4-utils.md:26
msgid "In your, `action_contracts`, these functions can be imported for use as follows "
msgstr "En su `action_contracts`, estas funciones se pueden importar para usarlas de la siguiente manera"

#: src/tutorial/onchain-chess/4-utils.md:27
msgid ""
"```rust,ignore\n"
"    use dojo_chess::utils::{is_out_of_board, is_right_piece_move, is_piece_is_mine};\n"
"```"
msgstr ""
"```rust,ignore\n"
"    use dojo_chess::utils::{is_out_of_board, is_right_piece_move, is_piece_is_mine};\n"
"```"

#: src/tutorial/onchain-chess/4-utils.md:30
msgid "That's right! you have successfully modularized your functions."
msgstr "¡Así es! Ha modularizado con éxito sus funciones."

#: src/misc/contributors.md:1
msgid "## Contributing to Dojo Book"
msgstr "## Contribuyendo al libro de Dojo"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo book to keep pace with these "
"advancements. Updating and refining the book ensures that it remains a relevant and valuable resource "
"for those interested in understanding and utilizing the latest Dojo engine features and capabilities. "
"All help is welcome!"
msgstr ""
"A medida que el Dojo engine progresa y se desarrolla, es esencial que el libro de Dojo siga el ritmo de "
"estos avances. Actualizar y perfeccionar el libro garantiza que siga siendo un recurso relevante y "
"valioso para aquellos interesados en comprender y utilizar las funciones y capacidades más recientes del "
"Dojo engine. ¡Toda ayuda es bienvenida!"

#: src/misc/contributors.md:5
msgid "### The purpose of the book"
msgstr "### El propósito del libro."

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to users at various levels of "
"experience. It aims to serve as both an introductory guide for those new to Dojo and its ancillary "
"packages, as well as a reference for more experienced users seeking to deepen their understanding of the "
"engine's features and capabilities."
msgstr ""
"El libro Dojo está diseñado para ser un recurso integral dirigido a usuarios de distintos niveles de "
"experiencia. Su objetivo es servir como guía introductoria para quienes son nuevos en Dojo y sus "
"paquetes auxiliares, así como también como referencia para usuarios más experimentados que buscan "
"profundizar su comprensión de las características y capacidades del motor."

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "El libro está dividido en algunos capítulos principales:"

#: src/misc/contributors.md:11
msgid ""
"- Framework Theory\n"
"- Getting Started\n"
"- Building a World"
msgstr ""
"- Teoría del Framework\n"
"- Primeros Pasos\n"
"- Construyedo un World"

#: src/misc/contributors.md:15
msgid "### Code of Conduct"
msgstr "### Código de Conducta"

#: src/misc/contributors.md:17
msgid "The book follows the [Rust Code of Conduct](https://www.rust-lang.org/policies/code-of-conduct)."
msgstr ""
"El libro sigue el [Código de conducta de Rust](https://www.rust-lang.org/policies/code-of-conduct)."

#: src/misc/contributors.md:19
msgid "### Ways to contribute"
msgstr "### Formas de contribuir"

#: src/misc/contributors.md:21
msgid "#### Issues"
msgstr "#### Issues"

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open an issue. If you find "
"multiple pieces of content lacking, please open up a separate issue for each."
msgstr ""
"Si cree que falta algún contenido o que está desactualizado, no dude en abrir un problema. Si encuentra "
"que faltan varios contenidos, abra un issue separado para cada uno."

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of work they are interested in "
"more easily."
msgstr ""
"Luego, los issues se etiquetarán para que otros contribuyentes puedan encontrar fragmentos de trabajo "
"que les interesen más fácilmente."

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as much detail as you deem "
"necessary."
msgstr ""
"El issue debe contener lo que falta o lo que podría mejorarse, con el mayor detalle que considere "
"necesario."

#: src/misc/contributors.md:29
msgid "#### Pull requests"
msgstr "#### Pull requests"

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - anything is welcome, from "
"reformulating a sentence, fixing a typo, to adding new sections or chapters."
msgstr ""
"Siéntase libre de contribuir con cambios al libro abriendo una pull request; cualquier cosa es "
"bienvenida, desde reformular una oración, corregir un error tipográfico hasta agregar nuevas secciones o "
"capítulos."

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may request changes. Do not be "
"discouraged!"
msgstr ""
"Cuando su pull request esté abierta, otros contribuyentes la echarán un vistazo y podrán solicitar "
"cambios. ¡No se desanime!"

#: src/misc/contributors.md:35
msgid "### Writing style"
msgstr "### Estilo de escritura"

#: src/misc/contributors.md:37
msgid "This section documents a few standards for writing used throughout the book."
msgstr "Esta sección documenta algunos estándares de escritura utilizados a lo largo del libro."

#: src/misc/contributors.md:39
msgid "#### Chapters start with a second level heading"
msgstr "#### Los capítulos comienzan con un título de segundo nivel."

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "Nosotros usamos:"

#: src/misc/contributors.md:43
msgid ""
"```md\n"
"## Some Page\n"
"```"
msgstr ""
"```md\n"
"## Some Page\n"
"```"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr "Nosotros no usamos:"

#: src/misc/contributors.md:49
msgid ""
"```md\n"
"# Some Page\n"
"```"
msgstr ""
"```md\n"
"# Some Page\n"
"```"
