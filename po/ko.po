msgid ""
msgstr ""
"Project-Id-Version: Dojo: The Provable Game Engine\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2023-09-21 02:15+0900\n"
"Last-Translator: Gayeong(Pia) Park <gayeongparkk@gmail.com>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.3.2\n"

#: src/SUMMARY.md:3
msgid "Foreword"
msgstr "서문"

#: src/SUMMARY.md:4 src/theory/what-is-dojo.md:1
msgid "What is Dojo?"
msgstr "Dojo란 무엇인가요?"

#: src/SUMMARY.md:5
msgid "AW Theory"
msgstr "AW 이론"

#: src/SUMMARY.md:6
msgid "Cairo Ecosystem"
msgstr "카이로(Cairo) 생태계"

#: src/SUMMARY.md:7 src/theory/faqs.md:1
msgid "FAQs"
msgstr "FAQs"

#: src/SUMMARY.md:9 src/client/npm/core.md:10 src/misc/contributors.md:12
msgid "Getting Started"
msgstr "시작하기"

#: src/SUMMARY.md:11 src/getting-started/quick-start.md:1
msgid "Quick Start"
msgstr "빠른 시작"

#: src/SUMMARY.md:12
msgid "Manual Install"
msgstr "수동 설치"

#: src/SUMMARY.md:13 src/getting-started/setup.md:1
msgid "Development Setup"
msgstr "개발환경 설정"

#: src/SUMMARY.md:14
msgid "Contributing"
msgstr "기여하기"

#: src/SUMMARY.md:16
msgid "Community"
msgstr "커뮤니티"

#: src/SUMMARY.md:18 src/community/get-started.md:1
msgid "Get Started"
msgstr "시작하기"

#: src/SUMMARY.md:20
msgid "Architecture"
msgstr "아키텍처"

#: src/SUMMARY.md:22 src/cairo/hello-dojo.md:1
msgid "Hello Dojo"
msgstr "헬로 Dojo"

#: src/SUMMARY.md:23 src/cairo/config.md:1
msgid "Config"
msgstr "기본 설정"

#: src/SUMMARY.md:24
msgid "World"
msgstr "월드(World)"

#: src/SUMMARY.md:25 src/cairo/components.md:1
msgid "Components"
msgstr "컴포넌트(Components)"

#: src/SUMMARY.md:26 src/cairo/systems.md:1
msgid "Systems"
msgstr "시스템(Systems)"

#: src/SUMMARY.md:27 src/cairo/entities.md:1
msgid "Entities"
msgstr "엔티티(Entities)"

#: src/SUMMARY.md:28 src/cairo/authorization.md:1
msgid "Authorization"
msgstr "권한"

#: src/SUMMARY.md:29 src/cairo/commands.md:1
msgid "Commands"
msgstr "명령어"

#: src/SUMMARY.md:30 src/cairo/events.md:1
msgid "Events"
msgstr "이벤트(Events)"

#: src/SUMMARY.md:31 src/cairo/testing.md:1
msgid "Testing"
msgstr "테스트"

#: src/SUMMARY.md:32 src/cairo/modules.md:1
msgid "Dojo Modules"
msgstr "Dojo 모듈"

#: src/SUMMARY.md:33 src/cairo/modules/erc20.md:1
msgid "ERC20"
msgstr "ERC20"

#: src/SUMMARY.md:34
msgid "ERC721"
msgstr "ERC721"

#: src/SUMMARY.md:35
msgid "ERC1155"
msgstr "ERC1155"

#: src/SUMMARY.md:36
msgid "DeFi"
msgstr "DeFi"

#: src/SUMMARY.md:38
msgid "Client SDKs"
msgstr "클라이언트 SDK"

#: src/SUMMARY.md:40 src/client/overview.md:1
msgid "Overview"
msgstr "개요"

#: src/SUMMARY.md:41
msgid "JS"
msgstr "JS"

#: src/SUMMARY.md:42
msgid "Core"
msgstr "코어"

#: src/SUMMARY.md:44
msgid "Toolchain"
msgstr "툴체인"

#: src/SUMMARY.md:46
msgid "Dojoup"
msgstr "Dojoup"

#: src/SUMMARY.md:47 src/toolchain/sozo/overview.md:1
msgid "Sozo"
msgstr "Sozo"

#: src/SUMMARY.md:48 src/SUMMARY.md:60 src/SUMMARY.md:62
msgid "Reference"
msgstr "참고"

#: src/SUMMARY.md:49
msgid "init"
msgstr "init"

#: src/SUMMARY.md:50
msgid "build"
msgstr "빌드"

#: src/SUMMARY.md:51
msgid "test"
msgstr "테스트"

#: src/SUMMARY.md:52
msgid "migrate"
msgstr "마이그레이션"

#: src/SUMMARY.md:53
msgid "execute"
msgstr "실행"

#: src/SUMMARY.md:54
msgid "register"
msgstr "등록"

#: src/SUMMARY.md:55
msgid "system"
msgstr "시스템"

#: src/SUMMARY.md:56
msgid "component"
msgstr "컴포넌트"

#: src/SUMMARY.md:57
msgid "events"
msgstr "이벤트"

#: src/SUMMARY.md:58
msgid "auth"
msgstr "auth"

#: src/SUMMARY.md:59 src/toolchain/katana/overview.md:1
msgid "Katana"
msgstr "Katana"

#: src/SUMMARY.md:61
msgid "Torii"
msgstr "Torii"

#: src/SUMMARY.md:64
msgid "Deploying"
msgstr "배포"

#: src/SUMMARY.md:66
msgid "Locally"
msgstr "로컬 환경"

#: src/SUMMARY.md:67
msgid "Remote"
msgstr "원격 환경"

#: src/SUMMARY.md:69
msgid "Tutorial"
msgstr "튜토리얼"

#: src/SUMMARY.md:71
msgid "Onchain Chess"
msgstr "온체인 체스"

#: src/SUMMARY.md:72 src/tutorial/onchain-chess/0-setup.md:1
msgid "0. Setup"
msgstr "0. 설정"

#: src/SUMMARY.md:73
msgid "1. Initiate"
msgstr "1. 시작"

#: src/SUMMARY.md:74
msgid "2. Move"
msgstr "2. 이동"

#: src/SUMMARY.md:75 src/tutorial/onchain-chess/3-legal.md:1
msgid "3. Check Legal Move"
msgstr "3. 가능 여부 확인"

#: src/SUMMARY.md:76
msgid "4. Test Chess"
msgstr "4. 체스 테스트"

#: src/SUMMARY.md:79
msgid "Contributors"
msgstr "기여자(Contributors)"

#: src/index.md:1
msgid "![Dojo](images/dojo-mark-full-dark.svg)"
msgstr ""

#: src/index.md:3
#, fuzzy
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors. For additional resources, join the "
"community on [Discord](https://discord.gg/vUN4Xq9Qv6) and check out the "
"[contribution guide](./misc/contributors.md)."
msgstr ""
"> Dojo는 현재 초기 개발 단계에 있는 오픈소스 프로젝트로, 기여를 적극 환영합니"
"다. 추가 자료가 필요하면 [Discord](https://discord.gg/vUN4Xq9Qv6)의 커뮤니티"
"에 가입하고 [컨트리뷰션 가이드](./misc/contributors.md)를 참조하세요."

#: src/index.md:7
#, fuzzy
msgid "Dojo: The Provable Game Engine"
msgstr "## Dojo: 증명 가능한 게임 엔진"

#: src/index.md:9
msgid ""
"Dojo employs [Cairo](https://github.com/starkware-libs/cairo) to deliver a "
"robust architecture and toolset for designing autonomous worlds and onchain "
"games. It features an integrated entity component system (ECS) and includes "
"a native indexer, RPC testnet, and a comprehensive CLI management toolkit."
msgstr ""
"Dojo는 [Cairo](https://github.com/starkware-libs/cairo)를 사용하여 자율 세계"
"와 온체인 게임 설계를 위한 강력한 아키텍처와 툴셋을 제공합니다. 카이로는 통"
"합 엔티티 컴포넌트 시스템(ECS)을 갖추고 있으며 네이티브 인덱서, RPC 테스트"
"넷, 포괄적인 CLI 관리 툴킷을 포함하고 있습니다."

#: src/index.md:11
msgid ""
"This book is dedicated to familiarizing you with the Dojo engine and the "
"potential of Provable games. A special section on the [Theory](./theory/"
"autonomous-worlds.md) elucidates this emergent concept of autonomous worlds "
"and Provable games."
msgstr ""
"이 책은 Dojo 엔진과 증명가능한 게임의 잠재력에 익숙해지는 데 중점을 두고 있습"
"니다. [이론](./theory/autonomous-worlds.md)의 특별 섹션에서는 자율 세계와 증"
"명 가능한 게임에 대한 새로운 개념을 설명합니다."

#: src/index.md:13
#, fuzzy
msgid "[Quickstart](./getting-started/quick-start.md)"
msgstr ""
"`katana` 바이너리는 [`dojoup`](../../getting-started/quick-start.md)를 통해 "
"사용할 수 있습니다."

#: src/index.md:14
msgid "[What is Dojo? ](./theory/what-is-dojo.md)"
msgstr ""

#: src/index.md:15
msgid "[Explore the Architecture](./cairo/hello-dojo.md)"
msgstr ""

#: src/index.md:18
#, fuzzy
msgid "Explainer"
msgstr "### 설명"

#: src/index.md:20
msgid ""
"Here's a video of [Cartridge](https://cartridge.gg/)'s [Tarrence](https://"
"twitter.com/tarrenceva) explaining how Dojo works at the 2023 [Autonomous "
"Anonymous Summit](https://twitter.com/pet3rpan_/status/1666764726427353091):"
msgstr ""
"다음은 [Cartridge](https://cartridge.gg/)의 [Tarrence](https://twitter.com/"
"tarrenceva)가 2023년 [자율 익명 서밋](https://twitter.com/pet3rpan_/"
"status/1666764726427353091)에서 Dojo가 어떻게 작동하는지 설명하는 영상입니다:"

#: src/index.md:30
#, fuzzy
msgid "Organizational Structure"
msgstr "### 조직 구조"

#: src/index.md:31
msgid ""
"Dojo is an open-source initiative, licensed under MIT, dedicated to "
"promoting and advancing the concept of Autonomous Worlds (AWs). It is "
"spearheaded by [Cartridge](https://cartridge.gg/), [Realms & BibliothecaDAO]"
"(https://bibliothecadao.xyz/), [briq](https://briq.construction/) and many "
"more [contributors](https://github.com/orgs/dojoengine/people)."
msgstr ""
"Dojo는 MIT 라이선스를 받은 오픈소스 이니셔티브로, 자율 세계(Autonomous "
"Worlds)의 개념을 홍보하고 발전시키는 데 전념하고 있습니다. [Cartridge]"
"(https://cartridge.gg/), [Realms & BibliothecaDAO](https://bibliothecadao."
"xyz/), [briq](https://briq.construction/) 및 기타 여러 [컨트리뷰터](https://"
"github.com/orgs/dojoengine/people)가 주도하고 있습니다."

#: src/index.md:33
#, fuzzy
msgid "How do I get involved?"
msgstr "### 참여하려면 어떻게 해야 하나요?"

#: src/index.md:35
msgid ""
"Check out our [Github](https://github.com/dojoengine), our [Twitter](https://"
"twitter.com/dojostarknet), [Discord](https://discord.gg/vUN4Xq9Qv6) and "
"[contribution guide](https://book.dojoengine.org/misc/contributors.html)"
msgstr ""
"[깃허브](https://github.com/dojoengine), [트위터](https://twitter.com/"
"dojostarknet), [디스코드](https://discord.gg/vUN4Xq9Qv6), [기여 가이드]"
"(https://book.dojoengine.org/misc/contributors.html)를 확인하세요"

#: src/theory/what-is-dojo.md:3
msgid ""
"Dojo is the culmination of lessons learned from attempts at building [on-"
"chain games](https://naavik.co/digest/primer-fully-on-chain-gaming), an "
"emerging sector in the gaming industry. Any developer who has endeavored to "
"build an on-chain game recognizes the inherent engineering hurdles - a "
"realization that drove us to create Dojo. Just as you wouldn't recreate "
"Unity every time you develop a new game, the same principle applies here. "
"Dojo is designed to handle the complex infrastructure, allowing developers "
"to focus on the unique aspects of their games."
msgstr ""
"Dojo는 게임 업계에서 떠오르는 분야인 [온체인 게임](https://naavik.co/digest/"
"primer-fully-on-chain-gaming)을 구축하기 위한 다양한 시도와 교훈을 종합한 결"
"과물입니다. 온체인 게임 개발에 경험이 있는 개발자라면 이 분야의 내재된 엔지니"
"어링 문제점을 잘 알고 있을 것입니다. 이러한 깨달음을 바탕으로 Dojo가 탄생했습"
"니다. 새로운 게임을 개발할 때마다 Unity를 처음부터 만들 필요가 없는 것처럼, "
"Dojo는 복잡한 게임 인프라 처리를 대신해줍니다, 이를 통해 개발자는 게임의 특징"
"에만 집중할 수 있습니다."

#: src/theory/what-is-dojo.md:5
msgid ""
"Dojo aspires to be the go-to tool for building provable games. It is "
"radically open-source, and all contributions are welcome."
msgstr ""
"Dojo의 목표는 증명 가능한 게임 제작 도구가 되는 것입니다. 기본적으로 모두 오"
"픈 소스로 제공되며, 모든 기여자를 환영합니다."

#: src/theory/what-is-dojo.md:9
#, fuzzy
msgid "Stop building infrastructure; start building games"
msgstr "## 인프라 그만 만들고, 게임 만들기 시작하세요"

#: src/theory/what-is-dojo.md:11
msgid ""
"Dojo's suite of tools takes the infrastructure complexity out of building on-"
"chain games. It includes:"
msgstr ""
"Dojo는 온체인 게임 개발에 필요한 복잡한 인프라 문제를 해결하기 위해 아래의 도"
"구들을 제공합니다:"

#: src/theory/what-is-dojo.md:13
#, fuzzy
msgid "Entity Component System (ECS)"
msgstr "### 엔티티 컴포넌트 시스템(ECS)"

#: src/theory/what-is-dojo.md:15
msgid ""
"Dojo offers a standardized approach to building games on smart contracts. "
"Recognizing the intricacies of game design, Dojo simplifies the development "
"process, allowing creators to focus on gameplay logic. This standardization "
"paves the way for an interconnected network of worlds, streamlining "
"developer expertise and promoting game integration."
msgstr ""
"Dojo는 스마트 컨트랙트 기반의 표준화된 게임 제작 접근법을 제공합니다. 게임 디"
"자인 자체는 복잡한데, Dojo의 표준화된 접근법은 개발 프로세스를 단순화하여 게"
"임플레이 로직에만 집중할 수 있게 합니다. 이로써 서로 연결된 게임 네트워크의 "
"기반을 마련하고, 게임플레이의 통합을 쉽게 해줍니다."

#: src/theory/what-is-dojo.md:17
msgid ""
"Utilizing the ECS (Entity Component System) as its core architecture, Dojo "
"effectively manages the state and behavior of Autonomous Worlds (AWs). This "
"model revolves around systems acting on entities, which are collections of "
"pure data components. Systems efficiently determine which entities to "
"process based on persistent queries over these components."
msgstr ""
"Dojo는 ECS(엔티티 컴포넌트 시스템)를 핵심 아키텍처로 활용하여 자율 세계(AW)"
"의 상태와 동작을 효과적으로 관리합니다. 이 모델은 순수한 데이터 컴포넌트의 집"
"합인 엔티티에 따라 작동하는 시스템을 중심으로 작동합니다. 시스템은 이러한 컴"
"포넌에 대한 지속적인 쿼리를 기반으로 처리할 엔티티를 효율적으로 결정합니다."

#: src/theory/what-is-dojo.md:19
msgid "Read detailed information about the [Dojo ECS](../cairo/overview.md)."
msgstr "[Dojo ECS](../cairo/overview.md)에 대한 자세한 정보를 읽어보세요."

#: src/theory/what-is-dojo.md:21
#, fuzzy
msgid "[Torii](/crates/torii/README.md) - Starknet Indexer"
msgstr "### [Torii](/crates/torii/README.md) - 스타크넷 인덱서"

#: src/theory/what-is-dojo.md:23
msgid ""
"Building on-chain games often involves grappling with the challenge of "
"indexing on-chain state. However, Dojo standardizes contract states to "
"mirror traditional relational databases. This setup enables the [Torii "
"Indexer](../toolchain/torii/overview.md) to auto-index all contract states, "
"ensuring efficient and streamlined queries. Torii then exposes these states "
"via a GraphQL API or gRPC (coming soon), allowing developers to easily query "
"and retrieve data."
msgstr ""
"온체인 게임을 개발하면서 온체인 상태 인덱싱 문제를 해결해야 할 때가 있습니"
"다. Dojo는 기존 관계형 데이터베이스를 반영하여 컨트랙트 상태를 표준화합니다. "
"[Torii 인덱서](../toolchain/torii/overview.md)를 통해 모든 컨트랙트 상태가 자"
"동으로 인덱싱되어, 효율적이며 간소화된 쿼리가 가능합니다. 그런 다음 Torii는 "
"이러한 상태를 GraphQL API 또는 gRPC(곧 출시 예정)를 통해 노출하여 개발자가 데"
"이터를 쉽게 쿼리하고 검색할 수 있도록 합니다."

#: src/theory/what-is-dojo.md:25
msgid ""
"Using Torii drastically reduces the time and effort required to build on-"
"chain games. It also eliminates the need to manually create indexers, which "
"can be a tedious and error-prone process."
msgstr ""
"Torii를 사용하면 온체인 게임을 개발하는데에 필요한 시간과 노력을 크게 줄일 "
"수 있습니다. 또한 오류가 발생하기 쉬운 인덱서를 수동으로 생성할 필요가 없습니"
"다."

#: src/theory/what-is-dojo.md:27
#, fuzzy
msgid "[Katana](/crates/katana/README.md) - Blazingly fast development network"
msgstr "### [Katana](/crates/katana/README.md) - 빠른 개발용 네트워크"

#: src/theory/what-is-dojo.md:29
msgid ""
"Katana is a customizable StarkNet development network. It is blazingly fast "
"and allows you to iterate on your game logic swiftly."
msgstr ""
"Katana는 커스터마이징 가능한 스타크넷 개발용 네트워크로, 빠른 반복 개발이 가"
"능합니다."

#: src/theory/what-is-dojo.md:31
#, fuzzy
msgid "[Sozo CLI](/crates/sozo/README.md) - CLI Management Tool"
msgstr "### [Sozo CLI](/crates/sozo/README.md) - CLI 관리 도구"

#: src/theory/what-is-dojo.md:33
msgid ""
"Dojo worlds are poised to become some of the largest contracts. Sozo is a "
"CLI tool that assists you in managing your worlds. It enables you to create, "
"build, test, and deploy your worlds. Additionally, you can craft new "
"components and systems and register them with your world."
msgstr ""
"Dojo 월드는 크게 확장된 컨트랙트입니다. Sozo는 월드를 관리하기 위한 CLI 도구"
"로, 이를 통해 월드의 생성, 빌드, 테스트, 배포가 가능합니다. 또한 새로운 컴포"
"넌트와 시스템을 제작하여 월드에 등록할 수도 있습니다."

#: src/theory/what-is-dojo.md:35
#, fuzzy
msgid "What Dojo doesn't give you"
msgstr "### Dojo가 제공하지 않는 것"

#: src/theory/what-is-dojo.md:37
#, fuzzy
msgid ""
"Visual graphics - While Dojo provides networking and contracts, it doesn't "
"offer graphical engines. You can bring your graphics of choice! Integrate "
"your Dojo world with Unreal, Godot, or Unity."
msgstr ""
"1. 시각적 그래픽 - Dojo는 네트워킹과 컨트랙트는 제공하지만 그래픽 엔진은 제공"
"하지 않습니다. 하지만 원하는 그래픽 엔진(예: 언리얼, 고도, 유니티)을 가져와 "
"Dojo 월드와 통합이 가능합니다."

#: src/theory/what-is-dojo.md:39
#, fuzzy
msgid "Understanding the Dojo Workflow: A Visual Guide"
msgstr "## Dojo 워크플로 이해하기: 비주얼 가이드"

#: src/theory/what-is-dojo.md:41
msgid ""
"To help you understand how `Sozo` works, we've created a visual guide that "
"outlines the flow of execution using the powerful sozo tool and the katana "
"development network."
msgstr ""
"'Sozo'의 작동 방식을 이해하는 데 도움을 주기 위해 강력한 sozo 도구와 katana "
"개발 네트워크를 사용하여 흐름을 간략하게 설명하는 비쥬얼 가이드를 만들었습니"
"다."

#: src/theory/what-is-dojo.md:43
msgid ""
"This visual representation will help you grasp the fundamental steps of "
"working with Dojo, guiding you through the process of creating and managing "
"your on-chain games."
msgstr ""
"이 가이드는 Sozo 도구와 Katana 개발 네트워크를 활용하여 Dojo의 기본 단계와 온"
"체인 게임 제작 및 관리 과정을 설명합니다."

#: src/theory/what-is-dojo.md:45
msgid "![Dojo Sozo Workflow](../images/dojo-sozo-workflow.jpg)"
msgstr ""

#: src/theory/autonomous-worlds.md:1
#, fuzzy
msgid "Autonomous Worlds"
msgstr "## 자율 세계(Autonomous Worlds)"

#: src/theory/autonomous-worlds.md:3
#, fuzzy
msgid ""
"\"Autonomous worlds represent persistent, permissionless, and decentralized "
"open environments that users can freely interact with and contribute to.\""
msgstr ""
"> \"자율 세계는 사용자가 자유롭게 상호 작용하고 기여할 수 있는 지속 가능하며 "
"중앙 권한이 없는 분산된 개방된 환경을 말합니다.”"

#: src/theory/autonomous-worlds.md:5
msgid ""
"The precise definition of Autonomous Worlds (AWs) remains somewhat elusive, "
"as it is more of an abstract concept that has yet to be fully crystallized. "
"Lattice first [introduced](https://0xparc.org/blog/autonomous-worlds) the "
"terminology in 2022, but the notion of open worlds operating on the "
"blockchain has been around for a while. The abstraction introduced by MUD "
"served as a catalyst for the market to recognize the potential of these "
"worlds."
msgstr ""
"자율 세계(AW)의 개념은 아직 완전히 구체화되지 않아 추상적인 면이 있습니다. "
"Lattice가 2022년에 이 [용어](https://0xparc.org/blog/autonomous-worlds)를 처"
"음 도입했으나, 블록체인에서 운용되는 오픈 월드라는 아이디어는 이미 오래 전부"
"터 있었습니다. MUD가 추상적 개념으로 제시됨으로써, 시장은 이러한 월드의 잠재"
"력을 더욱 인식하게 되었습니다."

#: src/theory/autonomous-worlds.md:7
msgid ""
"Autonomous Worlds share notable similarities with blockchains in their "
"fundamental nature. Once established, they persist, maintaining their state "
"throughout the lifespan of the chain. Players can join or leave, and "
"developers can expand these worlds by deploying features in a permissionless "
"manner, much like how contracts are added to a chain. While there is no "
"universally accepted definition for an Autonomous World, we believe that a "
"game must possess at least the following two essential features to be "
"considered as such:"
msgstr ""
"자율 세계는 근본적으로 블록체인과 여러 중요한 특징을 공유합니다. 한 번 만들어"
"진 자율 세계는 체인의 수명 동안 지속되며, 플레이어들은 자유롭게 참여하거나 나"
"갈 수 있습니다. 개발자들도 체인에 컨트랙트를 추가함으로써 자율 세계를 확장할 "
"수 있습니다. 자율 세계의 정의는 명확하지 않지만, 유니티는 게임이 자율 세계로 "
"간주되기 위해서는 적어도 다음 두 가지 요소가 필요하다고 강조합니다:"

#: src/theory/autonomous-worlds.md:9
#, fuzzy
msgid ""
"Decentralized data availability layer: While the state execution may reside "
"on a centralized layer, it is crucial that the state can be reconstructed if "
"the execution layer ceases to exist. Rollups offer a solution, providing "
"increased capacity execution layers while ensuring data is permanently "
"settled on Ethereum. This guarantees the world's perpetual persistence."
msgstr ""
"1. 분산형 데이터 가용성 계층: 상태는 중앙화된 레이어에서 실행될 수 있으나, 해"
"당 레이어가 사라져도 상태를 복구할 수 있어야 합니다. 롤업은 데이터를 이더리움"
"에 안정적으로 저장하며 실행 레이어의 용량을 확장하는 솔루션을 제공합니다. 이"
"것은 월드의 지속성을 보장합니다.\n"
"\n"
"2. 월드 확장을 위한 무허가 진입점: 월드 컨트랙트는 허가 없이 새로운 시스템과 "
"구성 요소를 수용할 수 있어야 합니다. 모든 구성 요소와 시스템이 반드시 사용되"
"는 것은 아니지만, 이 원칙을 따라서 열린 액세스와 잠재적인 개선을 보장해야 합"
"니다."

#: src/theory/autonomous-worlds.md:11
#, fuzzy
msgid ""
"Permissionless entry point for expanding the world: The World contract must "
"be capable of accepting new systems and components without requiring "
"permission. While this doesn't imply that every component and system will be "
"utilized, they must adhere to this pattern, ensuring open and unrestricted "
"access for potential enhancements."
msgstr ""
"1. 분산형 데이터 가용성 계층: 상태는 중앙화된 레이어에서 실행될 수 있으나, 해"
"당 레이어가 사라져도 상태를 복구할 수 있어야 합니다. 롤업은 데이터를 이더리움"
"에 안정적으로 저장하며 실행 레이어의 용량을 확장하는 솔루션을 제공합니다. 이"
"것은 월드의 지속성을 보장합니다.\n"
"\n"
"2. 월드 확장을 위한 무허가 진입점: 월드 컨트랙트는 허가 없이 새로운 시스템과 "
"구성 요소를 수용할 수 있어야 합니다. 모든 구성 요소와 시스템이 반드시 사용되"
"는 것은 아니지만, 이 원칙을 따라서 열린 액세스와 잠재적인 개선을 보장해야 합"
"니다."

#: src/theory/autonomous-worlds.md:13
msgid ""
"We're firm believers in the potential for Autonomous Worlds to catalize the "
"exploration of novel forms in the medium provided by zk proofs and "
"blockchain technology. This is not only about games, but also about new "
"forms of artwork, coordination, fun, emerging from tinkering and radical "
"innovation, eventually questioning the very notion of \"play\" in this brave "
"new decentralized and trustless world."
msgstr ""
"우리는 자율 세계가 영지식 증명과 블록체인 기술을 통한 새로운 탐험의 잠재력을 "
"지니고 있다고 생각합니다. 이것은 단순히 게임을 넘어서, 새로운 예술 작품, 협"
"력, 창의성, 그리고 이 혁신적인 탈중앙화 세계에서 ‘놀이’라는 개념 자체를 재평"
"가하는 방식에 관한 것입니다."

#: src/theory/autonomous-worlds.md:15
#, fuzzy
msgid "Homework"
msgstr "### 읽어보기"

#: src/theory/autonomous-worlds.md:16
msgid ""
"[Wired - Autonomous Worlds Primer](https://www.wired.com/story/autonomous-"
"worlds-aim-to-free-online-games-from-corporate-control/)"
msgstr ""

#: src/theory/autonomous-worlds.md:17
msgid ""
"[0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/autonomous-"
"worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:18
msgid ""
"[Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep.substack."
"com/p/the-strongest-crypto-gaming-thesis)"
msgstr ""

#: src/theory/autonomous-worlds.md:19
msgid ""
"[Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/blog/"
"mud-an-engine-for-autonomous-worlds)"
msgstr ""

#: src/theory/autonomous-worlds.md:20
msgid "[Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)"
msgstr ""

#: src/theory/autonomous-worlds.md:21
msgid ""
"[Guiltygyoza - Composable Engineering](https://www.guiltygyoza.xyz/2023/05/"
"composable-engineering)"
msgstr ""

#: src/theory/autonomous-worlds.md:22
msgid ""
"[Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/wind-up-"
"worlds/)"
msgstr ""

#: src/theory/autonomous-worlds.md:23
msgid ""
"[Are.na collection on Autonomous Worlds](https://www.are.na/sylve-chevet/on-"
"chain-realities-and-autonomous-worlds)"
msgstr ""

#: src/theory/cairo.md:1
#, fuzzy
msgid "Provable games"
msgstr "# 증명 가능한 게임"

#: src/theory/cairo.md:3
msgid ""
"Provable games demand [zero-knowledge](https://ethereum.org/en/zero-"
"knowledge-proofs/) properties for efficient scaling and verification of "
"computations. [Cairo](https://book.starknet.io/chapter_1/what_is_cairo.html) "
"addresses this need by providing a generalized language, eliminating the "
"complexity of creating circuits to incorporate [SNARKs](https://consensys."
"net/blog/developers/introduction-to-zk-snarks/). "
msgstr ""
"증명 가능한 게임은 계산의 효율적인 확장 및 검증을 위해 [영지식 증명](https://"
"ethereum.org/en/zero-knowledge-proofs/) 특성을 필요로 합니다. [Cairo]"
"(https://book.starknet.io/chapter_1/what_is_cairo.html)는 이를 위한 일반화된 "
"언어를 제공하며, [SNARK](https://consensys.net/blog/developers/introduction-"
"to-zk-snarks/)를 통합하기 위한 회로(circuits)의 복잡성을 해소합니다. "

#: src/theory/cairo.md:5
msgid ""
"**You can simply program in Cairo and your applications become automatically "
"provable**. "
msgstr "**Cairo를 활용하면 자동으로 애플리케이션을 증명할 수 있습니다.**. "

#: src/theory/cairo.md:7
msgid ""
"Moreover, you can deploy your programs on the [Cairo Virtual Machine]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f) (CVM), "
"which is compatible with Starknet's Layer 2, Starknet appchains, and even in-"
"browser through WebAssembly (WASM)! Dojo aims to supply straightforward ZK "
"primitives to fuel your game development."
msgstr ""
"또한, 스타크넷의 레이어 2와 스타크넷 앱체인에 호환되는 [Cairo 가상 머신]"
"(https://medium.com/starkware/cairo-welcome-on-board-1cf3487554f)(CVM)에서 프"
"로그램 배포가 가능하며, 웹어셈블리(WASM)를 통해서도 브라우저 내에서 배포가 가"
"능합니다. Dojo는 게임 개발을 지원하기 위해 직관적인 ZK 도구를 제공하는 것을 "
"목표로 합니다."

#: src/theory/cairo.md:9
msgid ""
"For more information about Starknet, Cairo and its tech stack, check out the "
"[Starknet & Cairo book](https://book.starknet.io/)."
msgstr ""
"스타크넷, 카이로 및 기술 스택에 대한 자세한 내용은 [Starknet & Cairo book]"
"(https://book.starknet.io/)에서 확인하실 수 있습니다."

#: src/theory/cairo.md:11 src/getting-started/setup.md:8
#, fuzzy
msgid "Cairo"
msgstr "## Cairo"

#: src/theory/cairo.md:13
msgid ""
"Cairo is an open-source, Turing-complete smart contract language developed "
"by Starkware, designed to power the Validity Rollup Starknet. The language "
"enables highly expressive and verifiable computation, making it well-suited "
"for building scalable and secure applications, including decentralized "
"finance (DeFi) projects."
msgstr ""
"Cairo는 Starkware에서 개발한 튜링 완전(turing-complete)한 오픈소스 스마트 컨"
"트랙트 언어로서, 밸리디티 롤업 Starknet의 구동을 위해 설계되었습니다. 이 언어"
"는 높은 표현력과 검증 가능한 계산 능력으로 탈중앙 금융(DeFi) 프로젝트를 비롯"
"하여 확장 가능하며 안전한 애플리케이션 개발에 적합합니다."

#: src/theory/cairo.md:15
msgid ""
"Dojo builds on Cairo to create a robust framework for developing Autonomous "
"Worlds (AWs). By leveraging the capabilities of Cairo, Dojo aims to "
"streamline the development process, improve maintainability, and enhance the "
"performance of AWs."
msgstr ""
"Dojo는 Cairo를 토대로 자율 월드(AW) 개발을 위한 강력한 프레임워크를 제공합니"
"다. Cairo의 기능을 최대화하여 개발 과정을 단순화하고, 유지보수성 및 AW의 성"
"능 향상을 추구합니다."

#: src/theory/cairo.md:17
msgid ""
"A key feature of the Dojo framework is its use of [commands](../cairo/"
"commands.md). Commands are a design pattern that helps to reduce boilerplate "
"code, resulting in cleaner and more maintainable applications. They achieve "
"this by encapsulating specific actions or operations within self-contained, "
"reusable units."
msgstr ""
"Dojo 프레임워크의 주요 특징은 [명령어](../cairo/commands.md)를 활용한다는 것"
"입니다. 이 명령어(Command) 디자인 패턴은 불필요한 코드를 줄이고 보다 깔끔하"
"며 유지 관리하기 쉬운 애플리케이션 개발을 도와줍니다."

#: src/theory/cairo.md:19
msgid ""
"Developers can write commands freely within Systems, and the Cairo compiler "
"takes care of inlining the appropriate functions. "
msgstr ""
"개발자는 시스템 내에서 명령어를 자유롭게 작성할 수 있고, Cairo 컴파일러는 이"
"를 적절하게 인라인 처리합니다. "

#: src/theory/cairo.md:21
#, fuzzy
msgid "Essential Reading"
msgstr "#### 읽어보기"

#: src/theory/cairo.md:22
msgid "[Cairo book](https://cairo-book.github.io/)"
msgstr ""

#: src/theory/cairo.md:23
#, fuzzy
msgid "[Awesome Cairo](https://github.com/auditless/awesome-cairo)"
msgstr "[Repository](https://github.com/dojoengine/create-burner)"

#: src/theory/cairo.md:24
msgid "[Starknet Book](https://book.starknet.io/)"
msgstr ""

#: src/theory/cairo.md:26
#, fuzzy
msgid "Starknet as an L2"
msgstr "### L2 스타크넷"

#: src/theory/cairo.md:28
msgid ""
"Starknet is a Validity Rollup Layer 2 (L2) solution designed to scale "
"Ethereum. It operates by offering high transaction throughput and low gas "
"costs while maintaining the same level of security as Ethereum Layer 1 (L1). "
"The strategy it uses is akin to solving a sudoku puzzle: verifying a "
"solution is easier than finding the solution from scratch. Similarly, "
"Starknet replaces heavy and costly L1 computation with cheaper L1 "
"verification through the use of STARK proofs computed off-chain."
msgstr ""
"Starknet은 이더리움의 확장을 위한 유효성 롤업(Validity Rollup) L2 솔루션으로 "
"설계되었습니다. 이더리움 L1의 보안 수준을 유지하며 높은 트랜잭션 처리 능력과 "
"저렴한 가스 비용을 제공합니다. 스타크넷은 오프체인에서의 STARK 증명을 활용하"
"여 L1의 비용이 많이 드는 계산을 저렴한 L1 검증으로 대체합니다."

#: src/theory/cairo.md:30
msgid ""
"In more technical terms, Starknet is a permissionless Validity-Rollup (also "
"known as a \"ZK-Rollup\") that supports general computation and currently "
"runs as an L2 network over Ethereum. The network's L1 security is guaranteed "
"by its utilization of the STARK cryptographic proof system, which is "
"considered one of the safest and most scalable."
msgstr ""
"기술적으로 보면, 스타크넷은 일반 연산을 지원하는 비허가형 유효성 롤업(ZK 롤"
"업)으로서, 현재 이더리움 상의 L2 네트워크로 운영되고 있습니다. 이 네트워크의 "
"L1 보안은 STARK 암호화 증명 시스템을 통해 확보됩니다."

#: src/theory/cairo.md:32
#, fuzzy
msgid "Starknet as an Appchain"
msgstr "### 앱체인 스타크넷"

#: src/theory/cairo.md:34
msgid ""
"Cairo is an isomorphic, general-purpose language, optimized for Zero-"
"Knowledge (ZK) proofs. It's the driving force behind Starknet, Starkex, and "
"appchains. Remarkably, you can also run it in WebAssembly (WASM) to generate "
"proofs on the client-side! The Dojo team is working closely with the [Madara]"
"(https://github.com/keep-starknet-strange/madara) team to enable Starknet "
"appchains to seamlessly run Dojo worlds."
msgstr ""
"Cairo는 스타크넷, 스타크엑스, 앱체인의 기반이 되는 범용 언어로서 영지식(ZK) "
"증명에 최적화되어 있습니다. 놀랍게도 웹어셈블리(WASM)에서도 실행이 가능하여, "
"클라이언트 측에서 증명을 생성할 수 있습니다. Dojo 팀은 [Madara](https://"
"github.com/keep-starknet-strange/madara)팀과 협력하여 스타크넷 앱체인이 Dojo "
"월드에서 원활하게 동작하도록 지원하고 있습니다."

#: src/theory/faqs.md:3
#, fuzzy
msgid "Who owns Dojo?"
msgstr "#### Dojo의 소유자는 누구인가요?"

#: src/theory/faqs.md:5
msgid ""
"Dojo is strictly open-source and uses the Apache 2.0 license. Anyone can use "
"Dojo for free, and anyone can contribute to the project."
msgstr ""
"Dojo는 엄격한 오픈소스 정책을 따르며 Apache 2.0 라이선스로 제공됩니다. 따라"
"서 누구나 Dojo를 비용 없이 사용하거나 프로젝트에 기여할 수 있습니다."

#: src/theory/faqs.md:7
#, fuzzy
msgid "Why Dojo?"
msgstr "#### 왜 Dojo를 선택해야 하나요?"

#: src/theory/faqs.md:9
msgid ""
"Dojo was created to solve problems the founders faced when building onchain "
"games. It standardizes the process of building such games and provides a "
"suite of tools to make it easier."
msgstr ""
"Dojo는 창업자들이 온체인 게임 개발에 직면하는 문제점을 해결하기 위해 설계되었"
"습니다. 이를 위해 게임 제작 과정을 표준화하는 동시에 이 과정을 간소화하는 도"
"구를 제공합니다."

#: src/theory/faqs.md:11
#, fuzzy
msgid "What is the Dojo roadmap?"
msgstr "#### Dojo의 로드맵은 어떻게 되나요?"

#: src/theory/faqs.md:13
msgid ""
"Dojo is rapidly evolving. You can find open issues on the [Dojo Github]"
"(https://github.com/dojoengine/dojo/issues) and join the [Discord](https://"
"discord.gg/vUN4Xq9Qv6) to get involved. If you have ideas for the project, "
"please open an issue."
msgstr ""
"Dojo는 지속적으로 발전하고 있습니다.[Dojo 깃허브](https://github.com/"
"dojoengine/dojo/issues)에서 현재 진행 중인 이슈를 확인하고 [디스코드]"
"(https://discord.gg/vUN4Xq9Qv6)를 통해 커뮤니티에 참여할 수 있습니다. 만약 프"
"로젝트에 대한 새로운 아이디어가 있다면 이슈를 제출해 주십시오."

#: src/theory/faqs.md:15
#, fuzzy
msgid "What is an onchain game?"
msgstr "#### 온체인 게임이란 무엇인가요?"

#: src/theory/faqs.md:17
msgid ""
"Onchain games are games that exist entirely on a public blockchain network; "
"all states and logic are onchain. Clients (like web browsers) do not exist "
"on the chain but exist purely to interact with and interpret the onchain "
"state."
msgstr ""
"온체인 게임은 게임의 모든 상태와 로직이 퍼블릭 블록체인 네트워크상에 저장되"
"는 게임을 의미합니다. 이때, 클라이언트(예: 웹 브라우저)는 블록체인에 저장된 "
"정보와 상호작용하는 역할을 합니다."

#: src/theory/faqs.md:19
#, fuzzy
msgid "What is an autonomous world?"
msgstr "#### 자율 세계(autonomous world)란 무엇인가요?"

#: src/theory/faqs.md:21
msgid ""
"An autonomous world is one that exists entirely onchain. It's not controlled "
"by any single entity but is instead governed by the rules set within that "
"world. Dive deeper into the topic here: [Autonomous Worlds](../theory/"
"autonomous-worlds.md)."
msgstr ""
"자율 세계는 블록체인 상에 완전하게 존재하는 가상 세계를 의미합니다. 이 세계"
"는 특정 개인 또는 조직에 의해 제어되지 않고, 세계 내에 정의된 규칙에 따라 운"
"영됩니다. 자세한 정보는[Autonomous Worlds](../theory/autonomous-worlds.md)를 "
"참조하세요."

#: src/theory/faqs.md:23
#, fuzzy
msgid "What is Cairo?"
msgstr "#### Cairo는 무엇인가요?"

#: src/theory/faqs.md:25
msgid ""
"Cairo is an opensource programming language invented by Starkware. It's a "
"Turing-complete language meant for general-purpose computation. It's a low-"
"level language designed to compile to the Cairo Virtual Machine. Learn more "
"about it here: [Cairo](../theory/cairo.md)."
msgstr ""
"Cairo는 Starkware에서 개발한 오픈소스 프로그래밍 언어입니다. 범용적인 계산을 "
"위한 튜링 완전 언어로, Cairo 가상 머신(CVM)을 위해 설계된 저수준 언어입니다. "
"더 자세한 정보는 [Cairo](../theory/cairo.md)에서 확인할 수 있습니다."

#: src/theory/faqs.md:27
#, fuzzy
msgid "What is a provable game?"
msgstr "#### 증명 가능한 게임이란 무엇인가요?"

#: src/theory/faqs.md:29
msgid ""
"Thanks to the magic of zero-knowledge proofs, we can ensure a game is fair "
"by verifying a zk proof created off-chain. But what does that entail? "
"Consider a game of chess. We aim for an experience where players trust each "
"other's moves. In a straightforward approach — and given the simple rules of "
"chess — if this were in a blockchain environment, every move would be a "
"transaction on the blockchain. This is costly. We just want to know the "
"winner, not every move."
msgstr ""
"영지식 증명 기술을 이용하여, 오프체인에서 생성된 zk 증명의 검증을 통해 게임"
"의 공정성을 보장합니다. 체스 게임을 예로 들면, 모든 움직임이 블록체인에 기록"
"되면 큰 비용이 발생합니다. 우리는 게임의 승자만 알고자 하는데, 모든 수를 기록"
"할 필요는 없습니다."

#: src/theory/faqs.md:31
msgid ""
"With zk proofs and client communications, players can establish a state "
"channel, sharing moves off-chain and ensuring their validity. At the end, a "
"zk proof can be submitted to the blockchain to confirm the game's fairness. "
"This constitutes a provable game."
msgstr ""
"플레이어는 zk 증명과 클라이언트 간 통신을 활용해 상태 채널을 설정하고 오프체"
"인에서 움직임을 공유하며 그 유효성을 보장합니다. 게임이 끝나면 공정성을 확인"
"하기 위해 블록체인에 zk 증명을 제출합니다. 이런 방식으로 게임이 진행되는 것"
"을 증명 가능한 게임이라고 합니다."

#: src/getting-started/quick-start.md:3
#, fuzzy
msgid ""
"It is worth reading [theory](../theory/autonomous-worlds.md) to familiarize "
"yourself with the concept of Autonomous Worlds (AWs) and the [Cairo "
"ecosystem](../theory/cairo.md) before diving into the code."
msgstr ""
"> 개발에 들어가기 전에, [자율 세계(AW)](../theory/autonomous-worlds.md)와 "
"[Cairo ecosystem](../theory/cairo.md)에 대한 기본 이론을 숙지하는 것이 권장됩"
"니다."

#: src/getting-started/quick-start.md:6
#, fuzzy
msgid "Install Dojoup"
msgstr "### Dojoup 설치"

#: src/getting-started/quick-start.md:8
msgid ""
"Dojo is built around a set of development tools - Katana, Torii and Sozo. "
"Install them all easily with Dojoup. You can find detailed information about "
"Dojoup [here](https://github.com/dojoengine/dojo/blob/master/dojoup/README."
"md)."
msgstr ""
"Dojo는 Katana, Torii, Sozo 등의 개발 도구 세트를 제공합니다. 이러한 도구들을 "
"Dojo를 통해 손쉽게 설치할 수 있습니다. Dojo에 관한 더 깊은 내용은 [여기]"
"(https://github.com/dojoengine/dojo/blob/master/dojoup/README.md)에서 확인할 "
"수 있습니다."

#: src/getting-started/quick-start.md:10 src/toolchain/dojoup.md:7
msgid ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"
msgstr ""
"```sh\n"
"curl -L https://install.dojoengine.org | bash\n"
"```"

#: src/getting-started/quick-start.md:14
#, fuzzy
msgid ""
"This will install Dojoup, then simply follow the instructions on-screen, "
"which will make the `dojoup` command available in your CLI."
msgstr ""
"Dojoup을 설치한 후, 화면에 나타나는 지시사항을 따라주세요. 설치가 완료되면 "
"CLI에서 dojoup 명령어를 사용할 수 있게 됩니다."

#: src/getting-started/quick-start.md:21
msgid ""
"For full `dojoup` reference and debugging see [Dojoup](../toolchain/dojoup."
"md)."
msgstr ""
"dojoup에 대한 자세한 명령어와 디버깅 방법은 [Dojoup](../toolchain/dojoup.md)"
"를 참조하세요."

#: src/getting-started/quick-start.md:23
#, fuzzy
msgid "Next steps"
msgstr "### 다음 단계"

#: src/getting-started/quick-start.md:25
#, fuzzy
msgid ""
"Head to [Hello Dojo](../cairo/hello-dojo.md) to get create your first Dojo "
"world."
msgstr ""
"> [헬로 Dojo](../cairo/hello-dojo.md)으로 이동하여 첫 번째 Dojo 월드를 만드세"
"요."

#: src/getting-started/from-source.md:1
#, fuzzy
msgid "Building from source"
msgstr "## 소스에서 빌드"

#: src/getting-started/from-source.md:3
#, fuzzy
msgid ""
"If you are just wanting to play with the toolchain, we strongly suggest "
"following the [Quick Start](./quick-start.md) guide."
msgstr ""
"> 툴체인만 사용해보고 싶다면 [빠른 시작](./quick-start.md) 가이드를 따르는 것"
"이 좋습니다."

#: src/getting-started/from-source.md:5 src/getting-started/setup.md:5
#, fuzzy
msgid "Prerequisites"
msgstr "### 전제 조건"

#: src/getting-started/from-source.md:7
#, fuzzy
msgid ""
"You will need the [Rust](https://rust-lang.org) compiler and Cargo, the Rust "
"package manager. The easiest way to install both is with [`rustup.rs`]"
"(https://rustup.rs/)."
msgstr ""
"[Rust](https://rust-lang.org) 컴파일러와 Rust 패키지 매니저인 Cargo가 필요합"
"니다.\n"
"두 가지를 모두 설치하는 가장 쉬운 방법은 [`rustup.rs`](https://rustup.rs/)를 "
"사용하는 것입니다."

#: src/getting-started/from-source.md:10
#, fuzzy
msgid ""
"On Windows, you will also need a recent version of [Visual Studio](https://"
"visualstudio.microsoft.com/downloads/), installed with the \"Desktop "
"Development With C++\" Workloads option."
msgstr ""
"Windows의 경우 최신 버전의 [Visual Studio](https://visualstudio.microsoft."
"com/downloads/)도 필요합니다,\n"
"\"C++를 사용한 데스크톱 개발\" 워크로드 옵션으로 설치합니다."

#: src/getting-started/from-source.md:13
#, fuzzy
msgid "Building"
msgstr "#### 빌드"

#: src/getting-started/from-source.md:15
msgid "You can either use the different [Dojoup](#using-dojoup) flags:"
msgstr "다른 [Dojoup](#using-dojoup) 플래그를 사용할 수 있습니다:"

#: src/getting-started/from-source.md:22
msgid "Or, by using a single Cargo command:"
msgstr "또는 단일 Cargo 명령을 사용하여:"

#: src/getting-started/from-source.md:24
msgid ""
"```sh\n"
"cargo install --git https://github.com/dojoengine/dojo --force sozo katana "
"torii\n"
"```"
msgstr ""
"```sh\n"
"cargo install —git https://github.com/dojoengine/dojo —force sozo katana "
"torii\n"
"```"

#: src/getting-started/from-source.md:28
msgid ""
"Or, by manually building from a local copy of the [Dojo repository](https://"
"github.com/dojoengine/dojo):"
msgstr ""
"또는 [Dojo repository](https://github.com/dojoengine/dojo)의 로컬 복사본에서 "
"수동으로 빌드할 수 있습니다:"

#: src/getting-started/from-source.md:30
msgid ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install --path ./crates/sozo --force\n"
"# install Katana\n"
"cargo install --path ./crates/katana --force\n"
"# install Torii\n"
"cargo install --path ./crates/torii --force\n"
"```"
msgstr ""
"```sh\n"
"# clone the repository\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"cd dojo\n"
"# install Sozo\n"
"cargo install —path ./crates/sozo —force\n"
"# install Katana\n"
"cargo install —path ./crates/katana —force\n"
"# install Torii\n"
"cargo install —path ./crates/torii —force\n"
"```"

#: src/getting-started/setup.md:3
#, fuzzy
msgid ""
"This article is a guide to setting up a development environment for Dojo. It "
"is not suggested to follow this guide if you are just wanting to play with "
"the toolchain. We strongly suggest following the [Quick Start](../getting-"
"started/quick-start.md) guide."
msgstr ""
"> 이 문서는 Dojo의 개발 환경 설정에 대한 안내서입니다. 단순히 툴체인만 사용하"
"고자 하는 경우 이 가이드를 따르지 않는 것이 좋습니다. [빠른 시작](../getting-"
"started/quick-start.md) 가이드를 따르는 것을 강력히 권장합니다."

#: src/getting-started/setup.md:7
msgid "Rust"
msgstr ""

#: src/getting-started/setup.md:12
#, fuzzy
msgid "Guide"
msgstr "## 가이드"

#: src/getting-started/setup.md:14
#, fuzzy
msgid "Clone"
msgstr "### 복사"

#: src/getting-started/setup.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo.git\n"
"```"

#: src/getting-started/setup.md:20
#, fuzzy
msgid "Linux & Mac"
msgstr "### Linux & Mac"

#: src/getting-started/setup.md:22
#, fuzzy
msgid "1. Install Rust and Dependencies"
msgstr "#### 1. Rust 및 종속성 설치"

#: src/getting-started/setup.md:24
msgid ""
"Start by installing Rust and running the test suite to confirm your setup:"
msgstr "먼저 Rust를 설치하고 테스트를 실행하여 설정이 정확한지 확인합니다:"

#: src/getting-started/setup.md:30
#, fuzzy
msgid ""
"Note: Depending on your Linux distribution, you may need to install "
"additional dependencies. Make sure to install any suggested or missing "
"dependencies that arise during the setup process."
msgstr ""
"> 참고: Linux 배포판에 따라 추가 종속성을 설치해야 할 수도 있습니다. 설치 과"
"정에서 제안되거나 누락된 종속성이 있으면 반드시 설치하세요."

#: src/getting-started/setup.md:32
#, fuzzy
msgid "2. Install Scarb Package Manager"
msgstr "#### 2. Scarb 패키지 관리자 설치"

#: src/getting-started/setup.md:34
msgid ""
"Next, install the [Scarb](https://docs.swmansion.com/scarb) package manager "
"by running:"
msgstr ""
"다음으로 [Scarb](https://docs.swmansion.com/scarb) 패키지 관리자를 실행하여 "
"설치합니다:"

#: src/getting-started/setup.md:36
msgid ""
"```sh\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""
"```sh\n"
"curl —proto ‘=https’ —tlsv1.2 -sSf https://docs.swmansion.com/scarb/install."
"sh | sh\n"
"```"

#: src/getting-started/setup.md:40
#, fuzzy
msgid "3. Add the Cairo 1.0 VSCode Extension"
msgstr "#### 3. Cairo 1.0 VSCode 확장 추가하기"

#: src/getting-started/setup.md:42
msgid ""
"Install the [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) extension for Visual Studio Code."
msgstr ""
"Visual Studio Code용 [Cairo 1.0](https://marketplace.visualstudio.com/items?"
"itemName=starkware.cairo1) 확장 프로그램을 설치합니다."

#: src/getting-started/setup.md:45
#, fuzzy
msgid "Windows"
msgstr "### Windows"

#: src/getting-started/setup.md:47 src/getting-started/setup.md:51
msgid "_Coming soon_"
msgstr "_Coming soon_"

#: src/getting-started/setup.md:49
#, fuzzy
msgid "Container"
msgstr "### Container"

#: src/getting-started/contributing.md:1
#, fuzzy
msgid "Contributing to the Core"
msgstr "# 기여하기"

#: src/getting-started/contributing.md:3
msgid ""
"Dojo is an open-source project, currently in its early development phase, "
"and warmly welcomes contributors."
msgstr ""
"Dojo는 현재 초기 개발 단계에 있는 오픈소스 프로젝트로, 기여자를 적극 환영합니"
"다."

#: src/getting-started/contributing.md:5
#, fuzzy
msgid "How to Contribute"
msgstr "## 기여 방법"

#: src/getting-started/contributing.md:7
msgid ""
"Head to the [Github](https://github.com/dojoengine/dojo/issues) for open "
"issues, if you see an issue that is unassigned, please request in the "
"comments to be assigned to it. If you have an idea for a new feature, please "
"create an issue with the `enhancement` tag."
msgstr ""
"[깃허브](https://github.com/dojoengine/dojo/issues)에서 이슈들를 확인하고, 할"
"당되지 않은 이슈가 있으면 댓글로 요청하여 할당받으세요. 새로운 기능에 대한 아"
"이디어가 있다면 `enhancement` 태그와 함께 이슈를 생성해 주세요."

#: src/community/get-started.md:3
#, fuzzy
msgid ""
"[Community Hub](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)"
msgstr ""
"-   [커뮤니티 허브](https://dojoengine.notion.site/Dojo-Engine-Community-Hub-"
"d316194b998941c48ddf771a4dd5ff08#bcd6a32db1b2406cb6c325f3b700d45a)\n"
"-   [디스코드](https://discord.gg/KG9w9BmDrV)\n"
"-   [트위터](https://twitter.com/dojostarknet)\n"
"-   [Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"

#: src/community/get-started.md:4
msgid "[Discord](https://discord.gg/KG9w9BmDrV)"
msgstr ""

#: src/community/get-started.md:5
#, fuzzy
msgid "[Twitter](https://twitter.com/dojostarknet)"
msgstr "[Repository](https://github.com/dojoengine/create-burner)"

#: src/community/get-started.md:6
#, fuzzy
msgid "[Awesome Dojo](https://github.com/dojoengine/awesome-dojo)"
msgstr "[Repository](https://github.com/dojoengine/create-burner)"

#: src/cairo/hello-dojo.md:3
#, fuzzy
msgid ""
"This section assumes that you have already installed the Dojo toolchain and "
"are familiar with Cairo. If not, please refer to the [Getting Started](../"
"getting-started/quick-start.md) section."
msgstr ""
"> 이 섹션에서는 이미 Dojo 툴체인을 설치했고 Cairo에 익숙하다고 가정합니다. 그"
"렇지 않은 경우, [시작하기](../getting-started/quick-start.md) 섹션을 참조하세"
"요."

#: src/cairo/hello-dojo.md:5
#, fuzzy
msgid "Dojo in 15 Minutes"
msgstr "## 15분 안에 Dojo 게임 만들기"

#: src/cairo/hello-dojo.md:7
msgid ""
"Think of Dojo as an abstraction over Cairo, similar to how React is to "
"JavaScript. It enables you to write shorthand commands that expand into "
"complex queries during compile time. Dojo is grounded in the well-known "
"architecture known as the Entity Component System (ECS)."
msgstr ""
"Dojo는 자바스크립트에서 React가 그러하듯 Cairo를 추상화한 것이라고 생각하면 "
"됩니다. 이를 통해 컴파일 시간 동안 복잡한 쿼리로 확장되는 단축 명령을 작성할 "
"수 있습니다. Dojo는 엔티티 컴포넌트 시스템(ECS)이라는 잘 알려진 아키텍처에 기"
"반을 두고 있습니다."

#: src/cairo/hello-dojo.md:9
msgid ""
"In Dojo, you design your worlds using Systems and Components. Systems "
"outline the logic of your world, while components signify the state. This "
"powerful pattern allows you to structure your logic in a highly modular way. "
"If you don't understand this yet, don't fret; we'll delve into it in detail "
"below."
msgstr ""
"Dojo에서는 시스템과 컴포넌트를 사용해 월드를 디자인합니다. 시스템은 월드의 로"
"직을, 컴포넌트는 상태를 나타냅니다. 이 강력한 패턴을 사용하면 고도로 모듈화"
"된 방식으로 로직을 구조화할 수 있습니다. 아직 이해가 안 되더라도 걱정하지 마"
"세요. 아래에서 자세히 설명해드리겠습니다."

#: src/cairo/hello-dojo.md:11
msgid ""
"To start, let's set up a project to run locally on your machine. From an "
"empty directory, execute:"
msgstr ""
"먼저 컴퓨터에서 로컬로 실행할 프로젝트를 설정해 보겠습니다. 빈 디렉토리에서 "
"실행합니다:"

#: src/cairo/hello-dojo.md:17
msgid ""
"Congratulations! You now have a local Dojo project. This command creates a "
"`dojo-starter` project in your current directory. It's the ideal starting "
"point for a new project and equips you with everything you need to begin."
msgstr ""
"축하합니다! 이제 로컬 Dojo 프로젝트가 생겼습니다. 이 명령은 현재 디렉토리에 "
"`dojo-starter` 프로젝트를 만듭니다. 이 프로젝트는 새 프로젝트를 시작하기에 이"
"상적인 시작점이며, 시작하는 데 필요한 모든 것을 갖추고 있습니다."

#: src/cairo/hello-dojo.md:19
#, fuzzy
msgid "Anatomy of a Dojo Project"
msgstr "#### Dojo 프로젝트 뜯어보기"

#: src/cairo/hello-dojo.md:21
msgid ""
"Inspect the contents of the `dojo-starter` project, and you'll notice the "
"following structure (excluding the non-cairo files):"
msgstr ""
"`dojo-starter` 프로젝트의 내용을 살펴보면 다음과 같은 구조를 확인할 수 있습니"
"다(Cairo가 아닌 파일 제외):"

#: src/cairo/hello-dojo.md:31
msgid ""
"Dojo projects largely resemble standard Cairo projects, with the distinction "
"being some special attribute tags you use when creating `Components` and "
"`Systems`. Let's explore this next."
msgstr ""
"Dojo 프로젝트는 표준 Cairo 프로젝트와 대체로 비슷하지만, `Components`와 "
"`Systems`을 생성할 때 사용하는 몇 가지 특수 속성 태그가 다릅니다. 이에 대해 "
"살펴보겠습니다."

#: src/cairo/hello-dojo.md:33
msgid "Open the `src/components.cairo` file to continue."
msgstr "계속하려면 `src/components.cairo` 파일을 엽니다."

#: src/cairo/hello-dojo.md:54
#, fuzzy
msgid ""
"Notice the `#[derive(Component, Copy, Drop, Serde, SerdeLen)]` attributes. "
"For a component to be recognized, we _must_ include `Component`. This "
"signals to the Dojo compiler that this struct should be treated as a "
"component."
msgstr ""
"`#[derive(Component, Copy, Drop, Serde, SerdeLen)]` 어트리뷰트를 주목하세요. "
"컴포넌트가 인식되려면 `Component`를 반드시 포함해야 합니다. 이것은 Dojo 컴파"
"일러에게 이 구조체를 컴포넌트로 취급해야 한다는 신호를 보냅니다."

#: src/cairo/hello-dojo.md:56
msgid ""
"Our `Moves` component houses a `remaining` value in its state. The `#[key]` "
"attribute informs Dojo that this component is indexed by the `player` field. "
"If this is unfamiliar to you, we'll clarify its importance later in the "
"chapter. Essentially, it implies that you can query this component using the "
"`player` field."
msgstr ""
"`Moves` 컴포넌트에는 `remaining` 값이 그 상태로 들어 있습니다. `#[key]` 속성"
"은 이 컴포넌트가 `player` 필드에 의해 인덱싱된다는 것을 Dojo에 알려줍니다. "
"이 속성이 익숙하지 않으시다면 이 장의 뒷부분에서 그 중요성을 설명하겠습니다. "
"기본적으로 `player` 필드를 사용하여 이 컴포넌트를 쿼리할 수 있음을 의미합니"
"다."

#: src/cairo/hello-dojo.md:58
msgid ""
"In a similar vein, we possess a `Position` component that holds `x` and `y` "
"values. Once again, this component is indexed by the `player` field."
msgstr ""
"비슷한 맥락에서 `x`와 `y` 값을 보유하는 `Position` 컴포넌트가 있습니다. 다시 "
"한 번, 이 컴포넌트는 `player` 필드에 의해 인덱싱됩니다."

#: src/cairo/hello-dojo.md:60
msgid "Now, let's examine the `src/systems.cairo` file:"
msgstr "이제 `src/systems.cairo` 파일을 살펴봅시다:"

#: src/cairo/hello-dojo.md:91
msgid "Let us break this down:"
msgstr "자세히 살펴보겠습니다:"

#: src/cairo/hello-dojo.md:97
msgid ""
"Just as we use the `#[derive(Component)]` attribute, the `#[system]` "
"attribute informs the Dojo compiler that this struct is a system, "
"instructing it to compile accordingly."
msgstr ""
"`#[derive(Component)]` 속성을 사용하는 것처럼, `#[system]` 속성은 Dojo 컴파일"
"러에 이 구조체가 `system` 임을 알려주고 그에 따라 컴파일하도록 지시합니다."

#: src/cairo/hello-dojo.md:103
msgid ""
"You'll observe that the system features an `execute` function. It's crucial "
"to note that all Dojo systems necessitate an `execute` function. This "
"function accepts a `Context` as its parameter. The `Context` is a distinct "
"struct that provides information about the world and the caller."
msgstr ""
"시스템에 `execute` 기능이 있는 것을 볼 수 있습니다. 모든 Dojo 시스템에는 "
"`execute` 함수가 필요하다는 점에 유의하는 것이 중요합니다. 이 함수는 "
"`Context`를 매개변수로 받습니다. `Context`는 세계와 호출자에 대한 정보를 제공"
"하는 별개의 구조체입니다."

#: src/cairo/hello-dojo.md:105
msgid ""
"It's worth mentioning that a system can contain more than just the `execute` "
"function. You're free to include numerous functions as needed. However, the "
"`execute` function is mandatory since it's invoked when your system is "
"executed."
msgstr ""
"시스템에는 `execute` 함수만 포함할 수 있는 것이 아니라는 점을 언급할 필요가 "
"있습니다. 필요에 따라 다양한 함수를 자유롭게 포함할 수 있습니다. 그러나 "
"`execute` 함수는 시스템이 실행될 때 호출되므로 필수입니다."

#: src/cairo/hello-dojo.md:107
msgid "Now lets look at the next line:"
msgstr "이제 다음 줄을 살펴보겠습니다:"

#: src/cairo/hello-dojo.md:113
msgid ""
"Here we use `get!` [command](./commands.md) to retrieve the `Position` "
"component for the `ctx.origin` entity. `ctx.origin` is the address of the "
"caller. When called for the first time, it will return:"
msgstr ""
"여기서는 `get!` [command](./commands.md)를 사용하여 `ctx.origin` 엔티티에 대"
"한 `Position` 구성 요소를 검색합니다. `ctx.origin`은 호출자의 주소입니다. 처"
"음 호출되면 다음과 같이 반환됩니다:"

#: src/cairo/hello-dojo.md:115
msgid ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"Position {\n"
"  player: 0x0, // zero address\n"
"  x: 0,\n"
"  y: 0\n"
"}\n"
"```"

#: src/cairo/hello-dojo.md:123
msgid "Now the next line:"
msgstr "이제 다음 줄입니다:"

#: src/cairo/hello-dojo.md:138
msgid ""
"Here we use the `set!` [command](./commands.md) to set the `Moves` and "
"`Position` components for the `ctx.origin` entity."
msgstr ""
"여기서는 `set!` [command](./commands.md)를 사용하여 `ctx.origin` 엔티티에 대"
"한 `Moves` 및 `Position` 구성 요소를 설정합니다."

#: src/cairo/hello-dojo.md:140
msgid "We covered a lot here in a short time. Let's recap:"
msgstr "짧은 시간에 많은 내용을 다루었습니다. 다시 한 번 요약해 보겠습니다:"

#: src/cairo/hello-dojo.md:142
#, fuzzy
msgid "Explained the anatomy of a Dojo project"
msgstr "#### Dojo 프로젝트 뜯어보기"

#: src/cairo/hello-dojo.md:143
msgid ""
"Explained the importace of the `#[derive(Component)]` and `#[system]` "
"attribute"
msgstr ""

#: src/cairo/hello-dojo.md:144
#, fuzzy
msgid "Explained the `execute` function"
msgstr "### 실행 함수"

#: src/cairo/hello-dojo.md:145
msgid "Explained the `Context` struct"
msgstr ""

#: src/cairo/hello-dojo.md:146
#, fuzzy
msgid "Touched on the `get!` and `set!` commands"
msgstr ""
"> 참고: [Commands](./commands.md)에서 `get!` 및 `set!` 매크로에 대해 읽어보세"
"요."

#: src/cairo/hello-dojo.md:149
#, fuzzy
msgid "Run it locally!"
msgstr "### 로컬에서 실행"

#: src/cairo/hello-dojo.md:151
msgid ""
"Now that we have some theory out of the way, lets build the Dojo project!"
msgstr ""
"몇 가지 이론을 정리해 보았으니, 이제 Dojo 프로젝트를 만들어 보겠습니다."

#: src/cairo/hello-dojo.md:157
msgid ""
"That compiled the components and system into an artifact that can be "
"deployed! Simple as that!"
msgstr ""
"컴포넌트와 시스템을 배포할 수 있는 아티팩트로 컴파일했습니다! 아주 간단합니"
"다 :)"

#: src/cairo/hello-dojo.md:159
msgid ""
"Now lets deploy it to [Katana](../toolchain/katana/overview.md)! First we "
"need to get Katana running:"
msgstr ""
"이제 [Katana](../toolchain/katana/overview.md)에 배포해 보겠습니다! 먼저 "
"Katana를 실행해야 합니다:"

#: src/cairo/hello-dojo.md:165
msgid ""
"Success! [Katana](../toolchain/katana/overview.md) should now be running "
"locally on your machine. Now lets deploy!"
msgstr ""
"성공! 이제 [Katana](../toolchain/katana/overview.md)가 머신에서 로컬로 실행되"
"고 있을 것입니다. 이제 배포해 봅시다!"

#: src/cairo/hello-dojo.md:171
msgid ""
"This will deploy the artifact to [Katana](../toolchain/katana/overview.md). "
"You should see terminal output similar to this:"
msgstr ""
"이렇게 하면 아티팩트가 [Katana](../toolchain/katana/overview.md)에 배포됩니"
"다. 이와 비슷한 터미널 출력이 보일 것입니다:"

#: src/cairo/hello-dojo.md:203
msgid ""
"Your 🌎 is now deployed at "
"`0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`!"
msgstr ""
"🌎는 이제 `0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16`"
"에 배포되었습니다!"

#: src/cairo/hello-dojo.md:205
msgid ""
"Let's discuss the `Scarb.toml` file in the project. This file contains "
"environment variables that make running CLI commands in your project a "
"breeze. (Read more about it [here](./config.md))."
msgstr ""
"프로젝트의 `Scarb.toml` 파일에 대해 설명하겠습니다. 이 파일에는 프로젝트에서 "
"CLI 명령을 쉽게 실행할 수 있는 환경 변수가 포함되어 있습니다. (자세한 내용은 "
"[여기](./config.md) 참조)."

#: src/cairo/hello-dojo.md:207
msgid "Add the world address to the bottom of the file:"
msgstr "파일 하단에 월드 주소를 추가합니다:"

#: src/cairo/hello-dojo.md:209
msgid ""
"```toml\n"
"world_address = "
"\"0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\"\n"
"```"
msgstr ""
"```toml\n"
"world_address = "
"“0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16”\n"
"```"

#: src/cairo/hello-dojo.md:213
msgid ""
"This establishes the world address for your project. You can then run "
"commands like:"
msgstr ""
"이렇게 하면 프로젝트의 월드 주소가 설정됩니다. 그런 다음, 다음과 같은 명령을 "
"실행할 수 있습니다:"

#: src/cairo/hello-dojo.md:219
msgid ""
"By doing so, you've just activated the spawn system. You now have a local "
"world that you can interact with."
msgstr ""
"이렇게 하면 spawn 시스템을 활성화한 것입니다. 이제 상호작용할 수 있는 로컬 월"
"드가 생겼습니다."

#: src/cairo/hello-dojo.md:221
#, fuzzy
msgid "Indexing"
msgstr "### 인덱싱"

#: src/cairo/hello-dojo.md:223
msgid ""
"With your local world set up, let's delve into indexing. You can index the "
"entire world with this simple command:"
msgstr ""
"로컬 월드가 설정되었으니 이제 인덱싱에 대해 자세히 알아봅시다. 이 간단한 명령"
"으로 전체 월드를 인덱싱할 수 있습니다:"

#: src/cairo/hello-dojo.md:229
msgid ""
"Executing the above activates a local torii server using SQLite as its "
"database, which is exposed at `http://0.0.0.0:8080`. It will automatically "
"index your world into tables, allowing you to query them using GraphQL."
msgstr ""
"위의 명령어를 실행하면 `http://0.0.0.0:8080`에 노출된 SQLite를 데이터베이스"
"로 사용하는 로컬 torii 서버가 활성화됩니다. 이 서버는 자동으로 월드를 테이블"
"로 인덱싱하여 GraphQL을 사용하여 쿼리할 수 있도록 합니다."

#: src/cairo/hello-dojo.md:231
msgid "We've covered quite a bit! Here's a recap:"
msgstr "꽤 많은 내용을 다루었습니다! 요약하면 다음과 같습니다:"

#: src/cairo/hello-dojo.md:233
msgid "Built a Dojo world"
msgstr ""

#: src/cairo/hello-dojo.md:234
#, fuzzy
msgid "Deployed the project to Katana"
msgstr "프로젝트를 Katana에 배포하려면 실행하세요:"

#: src/cairo/hello-dojo.md:235
msgid "Ran the spawn system locally"
msgstr ""

#: src/cairo/hello-dojo.md:236
msgid "Indexed the world with Torii"
msgstr ""

#: src/cairo/hello-dojo.md:238
#, fuzzy
msgid "Next Steps"
msgstr "### 다음 단계"

#: src/cairo/hello-dojo.md:240
msgid ""
"This overview provides a rapid end-to-end glimpse into Dojo. However, the "
"potential of these worlds is vast! Designed to manage hundreds of systems "
"and components, Dojo is equipped for expansive creativity. So, what will you "
"craft next?"
msgstr ""
"이 개요는 Dojo에 대한 간략한 개요를 제공합니다. 하지만 이 월드의 잠재력은 무"
"궁무진합니다! 수백 개의 시스템과 구성 요소를 관리할 수 있도록 설계된 Dojo는 "
"무한한 창의력을 발휘할 수 있는 환경을 갖추고 있습니다. 그렇다면 다음에는 무엇"
"을 제작할까요?"

#: src/cairo/config.md:3
msgid ""
"Dojo worlds are defined in their Scarb.toml files. This is just a [Scarb]"
"(https://docs.swmansion.com/scarb/) file which is an excellent Cairo package "
"manager and project manager."
msgstr ""
"Dojo 월드는 Scarb.toml 파일에 정의되어 있습니다. 이것은 훌륭한 Cairo 패키지 "
"관리자이자 프로젝트 매니징 툴인 [Scarb](https://docs.swmansion.com/scarb/) 파"
"일입니다."

#: src/cairo/config.md:5
msgid "Full example of a Scarb.toml file:"
msgstr "Scarb.toml 파일의 전체 예시입니다:"

#: src/cairo/config.md:7
msgid ""
"```toml\n"
"[package]\n"
"cairo-version = \"2.1.0-rc4\"\n"
"name = \"dojo_examples\"\n"
"version = \"0.1.0\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo\" }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = \"0xbeef\"\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = \"http://localhost:5050/\"\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"\"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\"\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"\"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\"\n"
"\n"
"# world contract address\n"
"world_address = "
"\"0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"cairo-version = “2.1.0-rc4”\n"
"name = “dojo_examples”\n"
"version = “0.1.0”\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = “https://github.com/dojoengine/dojo” }\n"
"\n"
"[[target.dojo]]\n"
"\n"
"[tool.dojo]\n"
"initializer_class_hash = “0xbeef”\n"
"\n"
"[tool.dojo.env]\n"
"rpc_url = “http://localhost:5050/“\n"
"\n"
"# account address of world deployer\n"
"account_address = "
"“0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c”\n"
"\n"
"# private key of world deployer\n"
"private_key = "
"“0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b”\n"
"\n"
"# world contract address\n"
"world_address = "
"“0x789c94ef39aeebc7f8c4c4633030faefb8bee454e358ae53d06ced36136d7d6”\n"
"```"

#: src/cairo/world.md:1
#, fuzzy
msgid "World Contract"
msgstr "## 월드 컨트랙트"

#: src/cairo/world.md:3
msgid ""
"The world contract functions as a central system kernel, serving as the "
"foundation for initiating and resolving all interactions. Within this "
"kernel, contracts are deployed, registered, and executed, streamlining the "
"process for downstream systems by enabling clients to engage with a single "
"contract rather than potentially hundreds."
msgstr ""
"월드 컨트랙트는 중앙 시스템 커널로 기능하며 모든 상호작용을 시작하고 해결하"
"기 위한 기반이 됩니다. 이 커널 내에서 컨트랙트가 배포, 등록, 실행되므로 클라"
"이언트가 수백 개의 컨트랙트가 아닌 단일 컨트랙트에 참여할 수 있어 다운스트림 "
"시스템의 프로세스를 간소화할 수 있습니다."

#: src/cairo/world.md:5
msgid ""
"Dojo core abstracts this contract away from the developer as a developer you "
"do not write it and it is not meant to be altered when building a world. "
"However, it's important to understand how it works and how it interacts with "
"the rest of the system."
msgstr ""
"Dojo는 컨트랙트를 개발자가 작성하지 않고 월드 빌드 시 변경할 수 없도록 추상화"
"하여 개발자가 신경써야 할 부분을 줄였습니다. 하지만 컨트랙트가 어떻게 작동하"
"고 나머지 시스템과 어떻게 상호 작용하는지 이해하는 것은 중요합니다."

#: src/cairo/world.md:8
#, fuzzy
msgid ""
"**To think about:** Consider Autonomous Worlds as sovereign blockchains "
"residing within another blockchain - a nested blockchain, so to speak. Just "
"as you can deploy contracts onto Ethereum to enhance its functionality, you "
"can similarly introduce systems into the World contract to enrich its "
"features. While anyone can contribute to the World, akin to Ethereum, "
"authorization is required to interact with component state. There is a "
"dedicated topic to Authorisation."
msgstr ""
"> **생각해볼 점:** 자율 월드는 다른 블록체인 안에 존재하는 주권 블록체인, 즉 "
"중첩된 블록체인으로 생각해볼 수 있습니다. 이더리움에 컨트랙트를 배포하여 기능"
"을 강화할 수 있는 것처럼, 월드 컨트랙트에도 마찬가지로 시스템을 도입하여 기능"
"을 강화할 수 있습니다. 이더리움과 마찬가지로 누구나 월드에 기여할 수 있지만, "
"구성 요소 상태와 상호 작용하려면 권한 부여가 필요합니다."

#: src/cairo/world.md:11
#, fuzzy
msgid "Context"
msgstr "### 컨텍스트"

#: src/cairo/world.md:13
msgid ""
"You will notice every System accepts a `Context` struct as the first "
"parameter. This is a special struct that contains information about the "
"world and the caller."
msgstr ""
"모든 시스템이 첫 번째 파라미터로 `Context` 구조체를 받는 것을 알 수 있습니"
"다. 이 구조체는 월드와 호출자에 대한 정보를 포함하는 특수한 구조체입니다."

#: src/cairo/world.md:15
msgid ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Copy, Drop, Serde)]\n"
"struct Context {\n"
"    world: IWorldDispatcher, // Dispatcher to the world contract\n"
"    origin: ContractAddress, // Address of the origin\n"
"    system: felt252, // Name of the calling system\n"
"    system_class_hash: ClassHash, // Class hash of the calling system\n"
"}\n"
"```"

#: src/cairo/world.md:25
#, fuzzy
msgid "The `uuid()` command"
msgstr "### `uuid()` 명령어"

#: src/cairo/world.md:27
msgid ""
"It is often useful to generate unique IDs for entities. The `uuid()` fn can "
"be used to generate a unique ID."
msgstr ""
"엔티티의 고유 ID를 생성하는 것이 유용한 경우가 많습니다. `uuid()` 함수를 사용"
"하여 고유 ID를 생성할 수 있습니다."

#: src/cairo/world.md:29 src/cairo/commands.md:20 src/cairo/commands.md:34
#: src/cairo/commands.md:56
msgid "Use it like this:"
msgstr "이렇게 사용하세요:"

#: src/cairo/world.md:36
#, fuzzy
msgid "Full World API"
msgstr "### 전체 월드 API"

#: src/cairo/world.md:38
msgid ""
"The world exposes an interface which can be interacted with by any client."
msgstr ""
"월드에는 모든 클라이언트가 상호 작용할 수 있는 인터페이스가 노출됩니다."

#: src/cairo/world.md:40
msgid ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"// World interface\n"
"#[starknet::interface]\n"
"trait IWorld<T> {\n"
"    fn component(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_component(ref self: T, class_hash: ClassHash);\n"
"    fn system(self: @T, name: felt252) -> ClassHash;\n"
"    fn register_system(ref self: T, class_hash: ClassHash);\n"
"    fn uuid(ref self: T) -> usize;\n"
"    fn emit(self: @T, keys: Array<felt252>, values: Span<felt252>);\n"
"    fn execute(ref self: T, system: felt252, calldata: Array<felt252>) -> "
"Span<felt252>;\n"
"    fn entity(\n"
"        self: @T, component: felt252, keys: Span<felt252>, offset: u8, "
"length: usize\n"
"    ) -> Span<felt252>;\n"
"    fn set_entity(\n"
"        ref self: T, component: felt252, keys: Span<felt252>, offset: u8, "
"value: Span<felt252>\n"
"    );\n"
"    fn entities(\n"
"        self: @T, component: felt252, index: felt252, length: usize\n"
"    ) -> (Span<felt252>, Span<Span<felt252>>);\n"
"    fn set_executor(ref self: T, contract_address: ContractAddress);\n"
"    fn executor(self: @T) -> ContractAddress;\n"
"    fn delete_entity(ref self: T, component: felt252, keys: Span<felt252>);\n"
"    fn origin(self: @T) -> ContractAddress;\n"
"\n"
"    fn is_owner(self: @T, account: ContractAddress, target: felt252) -> "
"bool;\n"
"    fn grant_owner(ref self: T, account: ContractAddress, target: felt252);\n"
"    fn revoke_owner(ref self: T, account: ContractAddress, target: "
"felt252);\n"
"\n"
"    fn is_writer(self: @T, component: felt252, system: felt252) -> bool;\n"
"    fn grant_writer(ref self: T, component: felt252, system: felt252);\n"
"    fn revoke_writer(ref self: T, component: felt252, system: felt252);\n"
"}\n"
"```"

#: src/cairo/components.md:3
#, fuzzy
msgid "Components = Data"
msgstr "> 구성 요소 = 데이터"

#: src/cairo/components.md:5
msgid ""
"Components serve as the foundation for defining the world's structure, "
"encapsulating state for systems to mutate. "
msgstr ""
"컴포넌트는 월드의 구조를 정의하는 기반이 되며, 시스템이 변경할 수 있는 상태"
"를 캡슐화합니다. "

#: src/cairo/components.md:7
msgid ""
"When designing a world's components, it is crucial to carefully consider the "
"abstractions you create, always keeping composability in mind."
msgstr ""
"월드의 컴포넌트를 디자인할 때는 항상 composability(조립성)을 염두에 두고 추상"
"화를 신중하게 고려하는 것이 중요합니다."

#: src/cairo/components.md:10
#, fuzzy
msgid "Components are Structs"
msgstr "### 컴포넌트는 구조체"

#: src/cairo/components.md:12
msgid ""
"Components are defined as structs in Cairo. They can contain any number of "
"fields, however it is best practice in ECS to have small isolated "
"components. This promotes modularity and composability, allowing you to "
"reuse components across multiple entity types."
msgstr ""
"컴포넌트는 Cairo에서 구조체로 정의됩니다. 컴포넌트에는 여러 필드를 포함할 수 "
"있지만, ECS에서는 작은 독립 컴포넌트를 사용하는 것이 가장 좋습니다. 이렇게 하"
"면 모듈성과 composability가 향상되어 여러 엔티티 유형에서 컴포넌트를 재사용"
"할 수 있습니다."

#: src/cairo/components.md:23
#, fuzzy
msgid "The #\\[key\\] attribute"
msgstr "#### #[key] 속성"

#: src/cairo/components.md:25
msgid ""
"The `#[key]` attribute indicates to Dojo that this component is indexed by "
"the `player` field. You need to define a key for each component, as this is "
"how you query the component. However, you can create composite keys by "
"defining multiple fields as keys. "
msgstr ""
"`#[key]` 속성은 이 컴포넌트가 `player` 필드에 의해 인덱싱되었음을 Dojo에 알려"
"줍니다. 컴포넌트를 쿼리하는 방식이므로 각 컴포넌트에 대해 키를 정의해야 합니"
"다. 그러나 여러 필드를 키로 정의하여 복합 키를 만들 수 있습니다. "

#: src/cairo/components.md:38
msgid ""
"In this case you then would set the component with both the player and "
"location fields:"
msgstr ""
"이 경우 플레이어 필드와 위치 필드를 모두 사용하여 컴포넌트를 설정합니다:"

#: src/cairo/components.md:53
#, fuzzy
msgid "Implementing Traits"
msgstr "#### 특성 구현하기"

#: src/cairo/components.md:55
msgid ""
"Components can implement traits. This is useful for defining common "
"functionality across components. For example, you may want to define a "
"`Position` component that implements a `PositionTrait` trait. This trait "
"could define functions such as `is_zero` and `is_equal` which could be used "
"when accessing the component."
msgstr ""
"컴포넌트는 특성을 구현할 수 있습니다. 이는 컴포넌트 간에 공통된 기능을 정의"
"할 때 유용합니다. 예를 들어, `Position` 컴포넌트에서 `PositionTrait` 특성을 "
"구현하는 것을 정의할 수 있습니다. 이 특성은 컴포넌트에 접근할 때 사용할 수 있"
"는 `is_zero` 및 `is_equal`과 같은 함수를 정의할 수 있습니다."

#: src/cairo/components.md:77
#, fuzzy
msgid "Custom Setting Components"
msgstr "#### 커스텀 컴포넌트(Components)"

#: src/cairo/components.md:79
msgid ""
"Suppose we need a place to keep a global value with the flexibility to "
"modify it in the future. Take, for instance, a global combat_cool_down "
"parameter that defines the duration required for an entity to be primed for "
"another attack. To achieve this, we can craft a component dedicated to "
"storing this value, while also allowing for its modification via a "
"decentralized governance model."
msgstr ""
"만일 차후 수정할 수 있는 유연성과 함께 전역 값을 유지할 수 있는 공간이 필요하"
"다고 가정해 봅시다. 예를 들어, 엔티티가 다른 공격에 대비하는 데 필요한 기간"
"을 정의하는 글로벌 combat_cool_down 매개변수를 생각해 봅시다. 이를 위해 이 값"
"을 저장하는 전용 컴포넌트를 만드는 동시에 분산형 거버넌스 모델을 통해 수정할 "
"수 있습니다."

#: src/cairo/components.md:81
msgid ""
"To establish these components, you'd follow the usual creation method. "
"However, when initializing them, employ a constant identifier, such as "
"GAME_SETTINGS_ID."
msgstr ""
"이러한 컴포넌트를 설정하려면 일반적인 생성 방법을 따릅니다. 하지만 초기화할 "
"때는 GAME_SETTINGS_ID 와 같은 상수 식별자를 사용하세요."

#: src/cairo/components.md:94
#, fuzzy
msgid "Types"
msgstr "#### 유형"

#: src/cairo/components.md:96
msgid "Support Component types:"
msgstr "지원 컴포넌트 유형:"

#: src/cairo/components.md:98
msgid "`u8`"
msgstr ""

#: src/cairo/components.md:99
msgid "`u16`"
msgstr ""

#: src/cairo/components.md:100
msgid "`u32`"
msgstr ""

#: src/cairo/components.md:101
msgid "`u64`"
msgstr ""

#: src/cairo/components.md:102
msgid "`u128`"
msgstr ""

#: src/cairo/components.md:103
msgid "`u256`"
msgstr ""

#: src/cairo/components.md:104
msgid "`ContractAddress`"
msgstr ""

#: src/cairo/components.md:106
msgid "It is currently not possible to use Arrays."
msgstr "현재 배열은 사용할 수 없습니다."

#: src/cairo/components.md:109
#, fuzzy
msgid "In practice with modularity in mind"
msgstr "### 모듈화를 염두에 둔 실제 사례"

#: src/cairo/components.md:111
msgid ""
"Consider a tangible analogy: Humans and Goblins. While they possess "
"intrinsic differences, they share common traits, such as having a position "
"and health. However, humans possess an additional component. Furthermore, we "
"introduce a Counter component, a distinct feature that tallies the numbers "
"of humans and goblins."
msgstr ""
"인간과 고블린을 비유로 들어보겠습니다. 인간과 고블린은 본질적인 차이가 있지"
"만, 지위와 건강 같은 공통된 특성을 공유합니다. 하지만 인간에게는 추가적인 구"
"성 요소가 있습니다. 바로 인간과 고블린의 수를 계산하는 카운터 구성 요소입니"
"다."

#: src/cairo/components.md:113
msgid ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Potions {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    quantity: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Health {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    health: u8,\n"
"}\n"
"\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Position {\n"
"    #[key]\n"
"    entity_id: u32,\n"
"    x: u32,\n"
"    y: u32\n"
"}\n"
"\n"
"// Special counter component\n"
"#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
"struct Counter {\n"
"    #[key]\n"
"    counter: u32,\n"
"    goblin_count: u32,\n"
"    human_count: u32,\n"
"}\n"
"```"

#: src/cairo/components.md:146
msgid ""
"So the Human will have a `Potions`, `Health` and `Position` component, and "
"the Goblin will have a `Health` and `Position` component. By doing we save "
"having to create Health and Position components for each entity type."
msgstr ""
"따라서 인간은 `Potions`, `Health`, `Position` 컴포넌트를 갖게 되고 고블린은 "
"`Health`과 `Position` 컴포넌트를 갖게 됩니다. 이렇게 하면 각 엔티티 유형에 대"
"해 체력 및 위치 컴포넌트를 생성할 필요가 없습니다."

#: src/cairo/components.md:148
msgid "So then a system would look like this:"
msgstr "그러면 시스템은 다음과 같이 보일 것입니다:"

#: src/cairo/components.md:150
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod spawnHuman {\n"
"    use array::ArrayTrait;\n"
"    use box::BoxTrait;\n"
"    use traits::Into;\n"
"    use dojo::world::Context;\n"
"\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::Health;\n"
"    use dojo_examples::components::Potions;\n"
"    use dojo_examples::components::Counter;\n"
"\n"
"    // we can set the counter value as a const, then query it easily! This "
"pattern is useful for settins.\n"
"    const COUNTER_ID: u32 = 9999999999999;\n"
"\n"
"    fn execute(ctx: Context, entity_id: u32) {\n"
"\n"
"        let counter = get!(ctx.world, COUNTER_ID, (Counter));\n"
"\n"
"        let human_count = counter.human_count + 1;\n"
"        let goblin_count = counter.goblin_count + 1;\n"
"\n"
"        // spawn a human\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: human_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: human_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    }, \n"
"                Potions {\n"
"                    entity_id: human_count, quantity: 10\n"
"                    \n"
"                },\n"
"            )\n"
"        );\n"
"\n"
"        // spawn a goblin\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Health {\n"
"                    entity_id: goblin_count, health: 100\n"
"                    }, \n"
"                Position {\n"
"                    entity_id: goblin_count, x: position.x + 10, y: position."
"y + 10,\n"
"                    },\n"
"            )\n"
"        );\n"
"\n"
"        // increment the counter\n"
"        set!(\n"
"            ctx.world,\n"
"            (\n"
"                Counter {\n"
"                    counter: COUNTER_ID, human_count: human_count, "
"goblin_count: goblin_count\n"
"                },\n"
"            )\n"
"        );\n"
"        \n"
"        return ();\n"
"    }\n"
"}\n"
"```"

#: src/cairo/components.md:218
#, fuzzy
msgid ""
"A complete example can be found in the [Dojo Starter](https://github.com/"
"dojoengine/dojo-starter)"
msgstr ""
"> 전체 예제는 [Dojo Starter](https://github.com/dojoengine/dojo-starter)에서 "
"확인할 수 있습니다"

#: src/cairo/systems.md:3
#, fuzzy
msgid "Systems = Logic"
msgstr "> 시스템 = 로직"

#: src/cairo/systems.md:5
msgid ""
"Systems underpin the logic of your world. While systems are inherently "
"stateless, their primary role is to modify the state of components. Every "
"system features an 'execute' function that's called upon during interactions "
"within the world."
msgstr ""
"시스템은 월드의 로직을 뒷받침합니다. 시스템은 본질적으로 상태가 없지만, 주요 "
"역할은 컴포넌트의 상태를 수정하는 것입니다. 모든 시스템에는 월드 내 상호작용 "
"중에 호출되는 `execute` 함수가 있습니다."

#: src/cairo/systems.md:7
msgid ""
"Let's look at the simplest possible system which mutates the state of the "
"`Moves` component."
msgstr "`Moves` 컴포넌트의 상태를 변경하는 가장 간단한 시스템을 살펴봅시다."

#: src/cairo/systems.md:31
#, fuzzy
msgid "The Execute function"
msgstr "### 실행 함수"

#: src/cairo/systems.md:33
msgid ""
"The `execute` function is mandatory in a system and runs when called, taking "
"`Context` as its first parameter. See more in [Context](./world.md)."
msgstr ""
"`execute` 함수는 시스템에서 필수이며 호출 시 `Context`를 첫 번째 매개변수로 "
"받아 실행됩니다. 자세한 내용은 [Context](./world.md)를 참조하세요."

#: src/cairo/systems.md:35
#, fuzzy
msgid "Other functions in a System"
msgstr "### 시스템의 기타 기능"

#: src/cairo/systems.md:37
msgid ""
"You are free to add other functions to your system, but they will not be "
"callable from the world. This is useful for breaking up your logic into "
"smaller chunks."
msgstr ""
"시스템에 다른 함수를 자유롭게 추가할 수 있지만 월드에서 호출할 수 없습니다. "
"이는 로직을 더 작은 덩어리로 나눌 때 유용합니다."

#: src/cairo/systems.md:39
#, fuzzy
msgid "Using View Functions"
msgstr "### 뷰 함수(View Functions) 사용"

#: src/cairo/systems.md:41
msgid ""
"There are times when we need to compute the value of a component "
"dynamically, rather than fetching its static state. For instance, in the "
"context of a VRGDA, if you want to ascertain the current price, merely "
"querying the component state won't suffice. Instead, you'd need to compute "
"the price based on certain parameters and the current state."
msgstr ""
"컴포넌트의 정적 상태를 가져오는 대신 동적으로 값을 계산해야 할 때가 있습니"
"다. 예를 들어, VRGDA의 경우 현재 가격을 확인하려면 단순히 컴포넌트 상태를 쿼"
"리하는 것만으로는 충분하지 않습니다. 대신 특정 파라미터와 현재 상태를 기반으"
"로 가격을 계산해야 합니다."

#: src/cairo/systems.md:43
msgid "This is where view functions come into play."
msgstr "여기서 뷰 기능이 중요한 역할을 합니다."

#: src/cairo/systems.md:45
msgid "**What are View Functions?**"
msgstr "**뷰 함수란 무엇인가요?**"

#: src/cairo/systems.md:47
msgid ""
"View functions are a way to derive or compute values from the existing state "
"of a component. They are invoked by the world and receive the current state "
"of the component as an argument. Subsequently, these functions return a "
"computed value based on this state."
msgstr ""
"뷰 함수는 컴포넌트의 기존 상태로부터 값을 도출하거나 계산하는 방법입니다. 뷰 "
"함수는 월드에서 호출되며 컴포넌트의 현재 상태를 인자로 받습니다. 이후 이 함수"
"는 이 상태를 기반으로 계산된 값을 반환합니다."

#: src/cairo/systems.md:49
msgid "**Example from VRGDA**:"
msgstr "**VRGDA의 예**:"

#: src/cairo/systems.md:51
msgid ""
"The below snippet, taken from the VRGDA example available on [this link]"
"(https://github.com/dojoengine/dojo-examples), illustrates how to implement "
"a view function:"
msgstr ""
"아래 코드는 [이 링크](https://github.com/dojoengine/dojo-examples)에서 제공되"
"는 VRGDA 예제에서 발췌한 것으로, 뷰 함수를 구현하는 방법을 설명합니다:"

#: src/cairo/systems.md:53
msgid ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //... other code ...\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[system]\n"
"mod view_price {\n"
"    //… other code …\n"
"\n"
"    fn execute(ctx: Context, game_id: u64, item_id: u128, amount: u128) -> "
"Fixed {\n"
"        let mut auction = get!(ctx.world, (game_id, item_id), Auction);\n"
"\n"
"        // Convert auction to VRGDA\n"
"        let VRGDA = auction.to_LogisticVRGDA();\n"
"\n"
"        // Calculate time since the auction began\n"
"        let time_since_start: u128 = get_block_timestamp().into() - auction."
"start_time.into();\n"
"\n"
"        // Compute the current price\n"
"        VRGDA.get_vrgda_price(\n"
"            FixedTrait::new(time_since_start, false), // Time elapsed since "
"auction start\n"
"            FixedTrait::new(auction.sold, false)      // Quantity sold\n"
"        )\n"
"    }\n"
"}\n"
"```"

#: src/cairo/systems.md:76
msgid ""
"In this example, the function computes and returns the current price of the "
"VRGDA based on the ongoing state of the auction."
msgstr ""
"이 예제에서 함수는 진행 중인 경매 상태를 기반으로 VRGDA의 현재 가격을 계산하"
"여 반환합니다."

#: src/cairo/systems.md:78
msgid "**How to Invoke View Functions?**"
msgstr "**뷰 함수를 호출하는 방법은?**"

#: src/cairo/systems.md:80
#, fuzzy
msgid ""
"**Using Dojo Core**: If you are working within the [Dojo Core](../client/npm/"
"core.md), utilize the `call` function. "
msgstr ""
"- **Dojo 사용**: [Dojo Core](../client/npm/core.md) 내에서 작업하는 경우, "
"`call` 기능을 활용하세요.\n"
"  \n"
"- **Rust 사용자를 위해**: [Starkli](https://book.starkli.rs/) 라이브러리는 "
"Rust에서 뷰 함수를 호출하는 편리한 방법을 제공합니다."

#: src/cairo/systems.md:82
#, fuzzy
msgid ""
"**For Rust Users**: The [Starkli](https://book.starkli.rs/) library provides "
"a handy method to invoke view functions in Rust."
msgstr ""
"- **Dojo 사용**: [Dojo Core](../client/npm/core.md) 내에서 작업하는 경우, "
"`call` 기능을 활용하세요.\n"
"  \n"
"- **Rust 사용자를 위해**: [Starkli](https://book.starkli.rs/) 라이브러리는 "
"Rust에서 뷰 함수를 호출하는 편리한 방법을 제공합니다."

#: src/cairo/systems.md:84
msgid ""
"I hope this revised version enhances the clarity and flow of the information "
"you want to convey!"
msgstr ""
"이번 개정판을 통해 전달하고자 하는 정보의 명확성과 흐름이 개선되기를 바랍니"
"다!"

#: src/cairo/systems.md:86
#, fuzzy
msgid "System Authentication"
msgstr "### 시스템 인증"

#: src/cairo/systems.md:88
msgid ""
"Systems must be given permission to write to components. By default they "
"have no permissions. With `sozo` we can however give them permissions to "
"write to components."
msgstr ""
"시스템에는 컴포넌트에 대한 쓰기 권한이 부여되어야 합니다. 기본적으로 시스템에"
"는 권한이 없습니다. 그러나 `sozo`를 사용하면 컴포넌트에 대한 쓰기 권한을 부여"
"할 수 있습니다."

#: src/cairo/systems.md:94
msgid ""
"Here we have authorised the `Spawn` system to write to the `Moves` "
"component. "
msgstr ""
"여기서는 `Spawn` 시스템이 `Moves` 컴포넌트에 쓸 수 있도록 권한을 부여했습니"
"다."

#: src/cairo/systems.md:96
msgid "Read more in the [sozo](../toolchain/sozo/overview.md) docs."
msgstr "[sozo](../toolchain/sozo/overview.md) 문서에서 자세히 알아보세요."

#: src/cairo/entities.md:3
#, fuzzy
msgid ""
"Entities are the primary key value within the world, to which components can "
"be attached."
msgstr "> 엔티티는 월드 내에서 컴포넌트들로 이루어진 기본 키 값입니다."

#: src/cairo/entities.md:5
msgid ""
"Different ECS systems handle entities in various ways. In Dojo, entities are "
"treated as a primary key value within the world, to which components can be "
"attached. To illustrate this concept, consider a simple example of a "
"character in a game that has a `Moves` and a `Position` component."
msgstr ""
"각기 다른 ECS 시스템은 다양한 방식으로 엔티티를 처리합니다. Dojo에서 엔티티"
"는 컴포넌트들을 붙일 수 있는 월드 내 기본 키 값으로 취급됩니다. 이 개념을 설"
"명하기 위해 게임 속 캐릭터에 `Moves`와 `Position` 컴포넌트가 있는 간단한 예"
"를 생각해 보겠습니다."

#: src/cairo/entities.md:7
msgid ""
"When defining the components for this entity, it is important to note that "
"we do not reference the entity directly. Instead, we simply provide two "
"structs that the entity will contain. "
msgstr ""
"이 엔티티의 컴포넌트를 정의할 때 엔티티를 직접 참조하지 않는다는 점에 유의하"
"는 것이 중요합니다. 대신 엔티티에 포함될 두 개의 구조체를 제공하기만 하면 됩"
"니다."

#: src/cairo/entities.md:26
msgid ""
"Now, let's create a `Spawn` for the character. It is important to note that "
"we have not explicitly defined an Entity anywhere. Instead, we use the `ctx."
"origin` to reference the current entity."
msgstr ""
"이제 캐릭터에 대한 `Spawn`을 생성해 봅시다. 여기서는 엔티티를 명시적으로 정의"
"하지 않았다는 점에 유의해야 합니다. 대신 `ctx.origin`을 사용하여 현재 엔티티"
"를 참조합니다."

#: src/cairo/entities.md:28
msgid ""
"In this example we are using the `ctx.origin` to reference the current "
"entity."
msgstr ""
"이 예제에서는 현재 엔티티를 참조하기 위해 `ctx.origin`을 사용하고 있습니다."

#: src/cairo/entities.md:58
#, fuzzy
msgid ""
"ECS Theory: Plenty has been written on ECS systems, to go deeper read [ECS-"
"FAQ](https://github.com/SanderMertens/ecs-faq)"
msgstr ""
"> ECS 이론: ECS 시스템에 대한 자세한 내용은 [ECS-FAQ](https://github.com/"
"SanderMertens/ecs-faq)를 참조하십시오"

#: src/cairo/authorization.md:3
#, fuzzy
msgid ""
"Authorization is crucial to a world, just like how authorization is crucial "
"to any smart contract."
msgstr ""
"> 모든 스마트 컨트랙트에서 권한 부여가 중요한 것과 마찬가지로 이는 월드에서"
"도 매우 중요합니다."

#: src/cairo/authorization.md:5
msgid ""
"As discussed in the [World](./world.md) chapter, Autonomous Worlds (AWs) "
"function as sovereign chains nested within a public blockchain. These Worlds "
"are also open to the public. This structure allows anyone to enhance a World "
"by deploying components or systems. However, this openness also introduces "
"security considerations. Similar to Ethereum, interacting with a component's "
"state within a System requires the appropriate authorization from the "
"component owner."
msgstr ""
"[World](./world.md) 챕터에서 설명한 것처럼, 자율 월드(AW)는 퍼블릭 블록체인 "
"내에 중첩된 주권 체인으로 기능합니다. 이러한 월드는 모두에세 공개됩니다. 이러"
"한 구조를 통해 누구나 구성 요소나 시스템을 배포하여 월드를 개선할 수 있습니"
"다. 그러나 이러한 개방성에는 보안에 대한 고려 사항도 있습니다. 이더리움과 마"
"찬가지로 시스템 내에서 구성 요소의 상태와 상호 작용하려면 컴포넌트 소유자의 "
"적절한 승인이 필요합니다."

#: src/cairo/authorization.md:7
#, fuzzy
msgid "Auth Architecture"
msgstr "### 인증 아키텍처"

#: src/cairo/authorization.md:9
msgid ""
"Every time a `set!` is called in a `System`, the world checks if the "
"`System` has authorization to update the component state. Only when the "
"`System` possesses the necessary authorization, the `set!` is executed. The "
"following diagram illustrates the authorization architecture."
msgstr ""
"`System`에서 `set!`이 호출될 때마다 월드에서는 `System`이 컴포넌트 상태를 업"
"데이트할 수 있는 권한을 가지고 있는지 확인합니다. `System`에 필요한 권한이 있"
"을 때만 `set!`이 실행됩니다. 다음 다이어그램은 권한 아키텍처를 보여줍니다."

#: src/cairo/authorization.md:11
#, fuzzy
msgid "![Authorization Architecture](../images/dojo-auth.png)"
msgstr "권한 아키텍처"

#: src/cairo/authorization.md:13
#, fuzzy
msgid "Providing Authorization"
msgstr "## 권한 부여 하기"

#: src/cairo/authorization.md:15
#, fuzzy
msgid ""
"The deployer of the Component is its initial owner. A Component owner is "
"able to grant the `owner` and `writer` roles. Only owners can grant a System "
"the `writer` role which allows it to update the Component."
msgstr ""
"> 컴포넌트의 배포자가 초기 소유자입니다. 컴포넌트 소유자는 `owner` 및 "
"`writer` 역할을 부여할 수 있습니다. 소유자만 시스템에 컴포넌트를 업데이트할 "
"수 있는 `writer` 역할을 부여할 수 있습니다."

#: src/cairo/authorization.md:17
msgid "`sozo` offers a convenient tool to authorize systems."
msgstr "`sozo`는 시스템을 인증하는 편리한 도구를 제공합니다."

#: src/cairo/authorization.md:23
msgid ""
"This command will generate a `writer` authorization for the `spawn` system "
"to update the `Moves` component."
msgstr ""
"이 명령은 `spawn` 시스템이 `Moves` 컴포넌트를 업데이트할 수 있는 `writer` 권"
"한을 생성합니다."

#: src/cairo/commands.md:3
msgid ""
"Understanding commands is key to understanding Dojo. You will leverage them "
"heavily within the systems you design."
msgstr ""
"명령어를 이해하는 것은 Dojo를 이해하는 데 핵심입니다. 게임을 설계하는 동안 명"
"령어를 많이 활용하게 되기 때문입니다."

#: src/cairo/commands.md:5
msgid ""
"Commands in Dojo are generalized functions that are expanded at compile time "
"to facilitate system execution. They provide a convenient way for systems to "
"interact with the world state by abstracting common operations, such as "
"retrieving or updating components, and generating unique IDs. By leveraging "
"these commands, developers can streamline their system implementations and "
"improve code readability."
msgstr ""
"Dojo의 명령어는 시스템 실행을 용이하게 하기 위해 컴파일 시 확장되는 일반화된 "
"함수입니다. 컴포넌트 검색 또는 업데이트, 고유 ID 생성 등 일반적인 작업을 추상"
"화하여 시스템이 월드 상태와 상호 작용할 수 있는 편리한 방법을 제공합니다. 개"
"발자는 이러한 명령을 활용하여 시스템 구현을 간소화하고 코드 가독성을 개선할 "
"수 있습니다."

#: src/cairo/commands.md:8
#, fuzzy
msgid "Using commands"
msgstr "### 명령어 사용"

#: src/cairo/commands.md:10
msgid ""
"Commands are used within systems to interact with the world state. They are "
"called using the following syntax:"
msgstr ""
"명령어는 시스템 내에서 월드 상태와 상호작용하는 데 사용됩니다. 명령은 다음 구"
"문을 사용하여 호출됩니다:"

#: src/cairo/commands.md:16
#, fuzzy
msgid "The `get!` command"
msgstr "### `get!` 명령어"

#: src/cairo/commands.md:18
msgid "The `get!` command is used to retrieve components from the world state."
msgstr "`get!` 명령어은 월드에서 컴포넌트를 검색하는 데 사용됩니다."

#: src/cairo/commands.md:26
msgid ""
"Here we are retrieving the `Position` and `Moves` components from the world "
"state. We are also using the `ctx.origin` to retrieve the components for the "
"current entity."
msgstr ""
"여기서는 월드에서 `Position` 및 `Moves` 컴포넌트를 검색하고 있습니다. 또한 "
"`ctx.origin`를 사용하여 현재 엔티티의 컴포넌트를 검색하고 있습니다."

#: src/cairo/commands.md:28
msgid ""
"You can then use `position` and `moves` as you would as any other Cairo "
"struct."
msgstr ""
"그런 다음 다른 Cairo 구조체와 마찬가지로 `position`과 `moves`를 사용할 수 있"
"습니다."

#: src/cairo/commands.md:30
#, fuzzy
msgid "The `set!` command"
msgstr "### `set!` 명령어"

#: src/cairo/commands.md:32
msgid "The `set!` command is used to update components state."
msgstr "`set!` 명령은 컴포넌트 상태를 업데이트하는 데 사용됩니다."

#: src/cairo/commands.md:36
msgid ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"
msgstr ""
"```rust,ignore\n"
"set !(ctx.world, (\n"
"    Moves {\n"
"        player: ctx.origin, remaining: 10\n"
"    }, \n"
"    Position {\n"
"        player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
"    },\n"
"));\n"
"\n"
"// If the structs are already defined it can also be written as:\n"
"set!(ctx.world, (moves, position));\n"
"```"

#: src/cairo/commands.md:50
msgid ""
"Here we are updating the `Moves` and `Position` components in the world "
"state using the `ctx.origin` as the entity id."
msgstr ""
"여기서는 `ctx.origin`를 엔티티 ID로 사용하여 월드의 `Moves` 및 `Position` 컴"
"포넌트를 업데이트하고 있습니다."

#: src/cairo/commands.md:52
#, fuzzy
msgid "The `emit!` command"
msgstr "### `emit!` 명령어"

#: src/cairo/commands.md:54
msgid "The `emit!` command is used to emit custom events."
msgstr "`emit!` 명령은 사용자 지정 이벤트를 내보내는 데 사용됩니다."

#: src/cairo/events.md:3
msgid ""
"Events play a pivotal role in decoding the dynamics of a Dojo world. Every "
"time there's an update to a `Component`, the `World` contract emits these "
"events. What's even more exciting is that you can craft your own custom "
"events to fit specific needs! Moreover, thanks to [Torii](../toolchain/torii/"
"overview.md), all these events are seamlessly indexed, ensuring easy and "
"efficient querying."
msgstr ""
"이벤트는 Dojo 월드의 전체적인 구성을 이해하는 데 중요한 역할을 합니다. "
"`Component`에 업데이트가 있을 때마다 `World` 컨트랙트는 이러한 이벤트를 발생"
"시킵니다. 더욱 흥미로운 점은 특정 요구에 맞게 맞춤형 이벤트를 만들 수 있다는 "
"것입니다! 또한, [Torii](../toolchain/torii/overview.md) 덕분에 이러한 모든 이"
"벤트가 원활하게 인덱스 되어서 쉽고 효율적으로 쿼리할 수 있습니다."

#: src/cairo/events.md:6
#, fuzzy
msgid "Component Events"
msgstr "### 컴포넌트 이벤트"

#: src/cairo/events.md:8
msgid "Consider this example of a `Moves` component:"
msgstr "`Moves` 컴포넌트의 예를 생각해 보겠습니다:"

#: src/cairo/events.md:19
msgid ""
"When this component is updated, the `World` contract will emit an event with "
"the following structure:"
msgstr ""
"이 컴포넌트가 업데이트되면 `World` 컨트랙트는 다음과 같은 구조의 이벤트를 발"
"생시킵니다:"

#: src/cairo/events.md:21
msgid ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[derive(Drop, starknet::Event)]\n"
"struct StoreSetRecord {\n"
"    table: felt252, // Moves\n"
"    keys: Span<felt252>, // [player]\n"
"    offset: u8, // 0\n"
"    value: Span<felt252>, // [remaining]\n"
"}\n"
"```"

#: src/cairo/events.md:31
msgid ""
"This will then be captured by [Torii](../toolchain/torii/overview.md) and "
"indexed for querying. This will allow you to then reconstruct the state of "
"your world."
msgstr ""
"그러면 [Torii](../toolchain/torii/overview.md)에 캡처되어 쿼리를 위해 인덱싱"
"됩니다. 이를 통해 월드의 상태를 재구성할 수 있습니다."

#: src/cairo/events.md:33
msgid ""
"Similarly, when a component is deleted, the `World` contract will emit an "
"event with the following structure:"
msgstr ""
"마찬가지로 컴포넌트가 삭제되면 `World` 컨트랙트는 다음과 같은 구조의 이벤트"
"를 발생시킵니다:"

#: src/cairo/events.md:43
#, fuzzy
msgid "World Events"
msgstr "### 월드 이벤트"

#: src/cairo/events.md:45
msgid ""
"The `World` contract also emits events when it's initialized and when new "
"components and systems are registered. These events are emitted with the "
"following structures:"
msgstr ""
"`World` 컨트랙트는 초기화될 때와 새로운 컴포넌트와 시스템이 등록될 때에도 이"
"벤트를 발생시킵니다. 이러한 이벤트는 다음과 같은 구조로 발생합니다:"

#: src/cairo/events.md:71
msgid ""
"These events are also captured by [Torii](../toolchain/torii/overview.md) "
"and indexed for querying."
msgstr ""
"이러한 이벤트는 [Torii](../toolchain/torii/overview.md)에서도 캡처되어 쿼리"
"를 위해 인덱싱 됩니다."

#: src/cairo/events.md:74
#, fuzzy
msgid "Custom Events"
msgstr "### 사용자 지정 이벤트"

#: src/cairo/events.md:76
msgid ""
"Within your systems, emitting custom events can be highly beneficial. "
"Fortunately, there's a handy `emit!` macro that lets you release events "
"directly from your world. Use it like so:"
msgstr ""
"시스템 내에서 커스텀 이벤트를 방출하면 매우 유용할 수 있습니다. 다행히도 월드"
"에서 직접 이벤트를 출력할 수 있는 편리한 `emit!` 매크로가 있습니다. 이렇게 사"
"용하세요:"

#: src/cairo/events.md:82
msgid ""
"Include this in your system and it will emit an event with the following "
"structure:"
msgstr "이를 시스템에 포함하면 다음과 같은 구조의 이벤트가 발생하게 됩니다:"

#: src/cairo/events.md:92
msgid "Now a full example using a custom event: "
msgstr "이제 사용자 지정 이벤트를 사용한 전체 예제입니다:"

#: src/cairo/events.md:107
#, fuzzy
msgid ""
"Note: Read about the `get!` and `set!` macros in [Commands](./commands.md)."
msgstr ""
"> 참고: [Commands](./commands.md)에서 `get!` 및 `set!` 매크로에 대해 읽어보세"
"요."

#: src/cairo/testing.md:3
msgid ""
"Testing is a crucial part of any software development process. Dojo provides "
"a testing framework that allows you to write tests for your smart contracts. "
"Since Dojo uses a custom compiler, you need to use `sozo` to test your "
"contracts."
msgstr ""
"테스트는 모든 소프트웨어 개발 프로세스에서 중요한 부분입니다. Dojo는 스마트 "
"컨트랙트에 대한 테스트를 작성할 수 있는 테스트 프레임워크를 제공합니다. Dojo"
"는 커스텀 컴파일러를 사용하기 때문에 컨트랙트를 테스트하려면 `sozo`를 사용해"
"야 합니다."

#: src/cairo/testing.md:5
msgid "From your project directory, simply:"
msgstr "프로젝트 디렉토리에서 간단히 실행할 수 있습니다:"

#: src/cairo/testing.md:11
msgid "This will search for all tests within your project and run them."
msgstr "프로젝트 내의 모든 테스트를 검색하여 실행합니다."

#: src/cairo/testing.md:14
#, fuzzy
msgid "Writing Unit Tests"
msgstr "### 유닛 테스트 작성"

#: src/cairo/testing.md:16
msgid ""
"It is best practise to include unit tests in the same file as the Component/"
"System you are writing."
msgstr ""
"유닛 테스트는 작성 중인 컴포넌트/시스템과 동일한 파일에 포함하는 것이 가장 좋"
"습니다."

#: src/cairo/testing.md:18
msgid ""
"Lets show a `Component` test example from the [dojo-starter](https://github."
"com/dojoengine/dojo-starter):"
msgstr ""
"[dojo-starter](https://github.com/dojoengine/dojo-starter)의 `Component` 테스"
"트 예제를 확인해 봅시다:"

#: src/cairo/testing.md:20
msgid "`components.cairo`"
msgstr "`components.cairo`"

#: src/cairo/testing.md:49
msgid ""
"In this test we are testing the `is_zero` and `is_equal` functions of the "
"`Position` component. It is good practise to test all functions of your "
"components."
msgstr ""
"이 테스트에서는 `Position` 컴포넌트의 `is_zero` 및 `is_equal` 함수를 테스트합"
"니다. 컴포넌트의 모든 함수를 테스트하는 것이 좋습니다."

#: src/cairo/testing.md:52
#, fuzzy
msgid "Writing Integration Tests"
msgstr "### 통합 테스트 작성하기"

#: src/cairo/testing.md:54
msgid ""
"Integration tests are e2e tests that test the entire system. You can write "
"integration tests for your world by creating a `tests` directory in your "
"project root. Then create a file for each integration test you want to write."
msgstr ""
"통합 테스트는 전체 시스템을 테스트하는 e2e 테스트입니다. 프로젝트 루트에서 "
"`tests` 디렉토리를 생성하여 월드에 대한 통합 테스트를 작성할 수 있습니다. 그"
"런 다음 작성하려는 각 통합 테스트에 대한 파일을 만듭니다."

#: src/cairo/testing.md:56
msgid ""
"This is the example from the [dojo-starter](https://github.com/dojoengine/"
"dojo-starter):"
msgstr ""
"[dojo-starter](https://github.com/dojoengine/dojo-starter)의 예제입니다:"

#: src/cairo/testing.md:58
msgid "`systems.cairo`"
msgstr "`systems.cairo`"

#: src/cairo/testing.md:59
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute('spawn', spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute('move', move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity('Moves', keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, 'moves is wrong');\n"
"        let new_position = world\n"
"            .entity('Position', keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, 'position x is wrong');\n"
"        assert(*new_position[1] == 10, 'position y is wrong');\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use core::traits::Into;\n"
"    use array::ArrayTrait;\n"
"\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"\n"
"    use dojo::test_utils::spawn_test_world;\n"
"\n"
"    use dojo_examples::components::position;\n"
"    use dojo_examples::components::Position;\n"
"    use dojo_examples::components::moves;\n"
"    use dojo_examples::components::Moves;\n"
"    use dojo_examples::systems::spawn;\n"
"    use dojo_examples::systems::move;\n"
"\n"
"    #[test]\n"
"    #[available_gas(30000000)]\n"
"    fn test_move() {\n"
"        let caller = starknet::contract_address_const::<0x0>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(position::TEST_CLASS_HASH);\n"
"        components.append(moves::TEST_CLASS_HASH);\n"
"\n"
"        // systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(spawn::TEST_CLASS_HASH);\n"
"        systems.append(move::TEST_CLASS_HASH);\n"
"\n"
"        // deploy executor, world and register components/systems\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let spawn_call_data = array::ArrayTrait::new();\n"
"        world.execute(‘spawn’, spawn_call_data);\n"
"\n"
"        let mut move_calldata = array::ArrayTrait::new();\n"
"        move_calldata.append(move::Direction::Right(()).into());\n"
"        world.execute(‘move’, move_calldata);\n"
"        let mut keys = array::ArrayTrait::new();\n"
"        keys.append(caller.into());\n"
"\n"
"        let moves = world.entity(‘Moves’, keys.span(), 0, dojo::SerdeLen::"
"<Moves>::len());\n"
"        assert(*moves[0] == 9, ‘moves is wrong’);\n"
"        let new_position = world\n"
"            .entity(‘Position’, keys.span(), 0, dojo::SerdeLen::<Position>::"
"len());\n"
"        assert(*new_position[0] == 11, ‘position x is wrong’);\n"
"        assert(*new_position[1] == 10, ‘position y is wrong’);\n"
"    }\n"
"}\n"
"```"

#: src/cairo/testing.md:113
#, fuzzy
msgid "Useful Dojo Test Functions"
msgstr "#### 유용한 Dojo 테스트 함수들"

#: src/cairo/testing.md:115
msgid ""
"`spawn_test_world(components, systems)` - This function will create a test "
"world with the components and systems you pass in. It will also deploy the "
"world and register the components and systems."
msgstr ""
"`spawn_test_world(components, systems)` - 이 함수는 사용자가 전달한 컴포넌트"
"와 시스템으로 테스트 월드를 생성합니다. 또한 월드를 배포하고 컴포넌트와 시스"
"템을 등록합니다."

#: src/cairo/modules.md:3
msgid ""
"With standardization of Systems and Components we can create a module "
"architecture for Dojo. This allows us to create reusable modules that can be "
"used in any Dojo world."
msgstr ""
"시스템과 구성 요소의 표준화를 통해 Dojo를 위한 모듈 아키텍처를 만들 수 있습니"
"다. 이를 통해 모든 Dojo 월드에서 사용할 수 있는 재사용 가능한 모듈을 만들 수 "
"있습니다."

#: src/cairo/modules.md:5
#, fuzzy
msgid "Module Architecture"
msgstr "### 모듈 아키텍처"

#: src/cairo/modules.md:7
msgid ""
"Think of modules as ERCs for Dojo. They are a standard way to create and "
"share functionality. Modules are a collection of Systems and Components that "
"can be imported into a Dojo world. Dojo is following the ERC patterns and "
"has modules already defined for ERC20, ERC721, and ERC1155."
msgstr ""
"모듈을 Dojo의 ERC라고 생각하세요. 모듈은 기능을 만들고 공유하는 표준 방법입니"
"다. 모듈은 Dojo 월드로 가져올 수 있는 시스템과 컴포넌트의 모음입니다. Dojo는 "
"ERC 패턴을 따르고 있으며 ERC20, ERC721, ERC1155에 대한 모듈이 이미 정의되어 "
"있습니다."

#: src/cairo/modules/erc20.md:3
msgid ""
"Dojo's ERC20 module is a standard implementation of the ERC20 token "
"standard, but it utilizes Dojo Systems and Components. This allows us to "
"leverage the excellent properties of the ERC20 standard and use it natively "
"within the Dojo environment."
msgstr ""
"Dojo의 ERC20 모듈은 ERC20 토큰의 표준 구현이지만, Dojo 시스템 및 구성 요소를 "
"활용합니다. 이를 통해 ERC20 표준의 우수한 특성을 활용하고 Dojo 환경 내에서 기"
"본적으로 사용할 수 있습니다."

#: src/cairo/modules/erc20.md:5
#, fuzzy
msgid "Integration into Your World"
msgstr "### 월드에 통합하기"

#: src/cairo/modules/erc20.md:7
msgid ""
"To integrate the ERC20 module into your world, you must first deploy the "
"ERC20 Dojo contract. Subsequently, install the systems and components into "
"your world."
msgstr ""
"ERC20 모듈을 월드에 통합하려면 먼저 ERC20 Dojo 컨트랙트를 배포해야 합니다. 그"
"런 다음 시스템과 컴포넌트를 월드에 설치합니다."

#: src/client/overview.md:3
msgid ""
"Dojo is BYO client, meaning that you can use any client you want to connect "
"to the Dojo network."
msgstr ""
"Dojo는 BYO 클라이언트로, Dojo 네트워크에 연결하고 싶은 모든 클라이언트를 사용"
"할 수 있습니다."

#: src/client/overview.md:5
msgid "Reference clients are available for the following platforms:"
msgstr "참조 클라이언트는 다음 플랫폼에서 이용 가능합니다:"

#: src/client/overview.md:7
#, fuzzy
msgid "[npm](./npm.md)"
msgstr "- [npm](./npm.md)"

#: src/client/npm.md:1
#, fuzzy
msgid "Javascript Libraries"
msgstr "# 자바스크립트 라이브러리"

#: src/client/npm.md:3
#, fuzzy
msgid ""
"Javascript is a great way to get started with Dojo. It's easy to use, and "
"you can get started in minutes."
msgstr ""
"> 자바스크립트는 Dojo를 시작하는 좋은 방법입니다. 사용하기 쉬우며 몇 분 안에 "
"시작할 수 있습니다."

#: src/client/npm.md:5
#, fuzzy
msgid "Examples using these:"
msgstr "### 이를 사용한 예제:"

#: src/client/npm.md:7
#, fuzzy
msgid ""
"[Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-react-app)"
msgstr ""
"이것은 [Dojo 리액트 앱](https://github.com/dojoengine/dojo-starter-react-app)"
"의 예시입니다"

#: src/client/npm.md:8
#, fuzzy
msgid ""
"[Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
msgstr ""
"[dojo-starter](https://github.com/dojoengine/dojo-starter)의 예제입니다:"

#: src/client/npm.md:10 src/client/npm/core.md:1
#, fuzzy
msgid "@dojoengine/core"
msgstr "## @dojoengine/core"

#: src/client/npm.md:12
msgid ""
"This is the lowest level library, and is used by all other downstream "
"libraries. It contains the core functionality of Dojo and exposes the "
"contract interfaces. Use it if you want to build your own library on top of "
"Dojo."
msgstr ""
"저수준의 라이브러리로, 다른 모든 다운스트림 라이브러리에서 사용됩니다. Dojo"
"의 핵심 기능을 포함하고 컨트랙트 인터페이스를 노출합니다. Dojo 위에 자신만의 "
"라이브러리를 구축하려는 경우 이 라이브러리를 사용하세요."

#: src/client/npm.md:14
msgid "[Documentation](./npm/core.md)"
msgstr "[Documentation](./npm/core.md)"

#: src/client/npm.md:20
#, fuzzy
msgid "@dojoengine/react"
msgstr "### @dojoengine/react"

#: src/client/npm.md:22
msgid ""
"This is a direct fork of [Mud React](https://github.com/latticexyz/mud/tree/"
"main/packages)"
msgstr ""
"[Mud React](https://github.com/latticexyz/mud/tree/main/packages)의 직접적인 "
"포크입니다"

#: src/client/npm.md:24
msgid ""
"This library contains a set of React components that can be used when "
"building React apps using Dojo."
msgstr ""
"이 라이브러리에는 Dojo를 사용하여 React 앱을 빌드할 때 사용할 수 있는 React "
"컴포넌트 세트가 포함되어 있습니다."

#: src/client/npm.md:26
msgid "[Documentation](./npm/react.md)"
msgstr "[Documentation](./npm/react.md)"

#: src/client/npm.md:33
#, fuzzy
msgid "@dojoengine/create-burner"
msgstr "### @dojoengine/create-burner"

#: src/client/npm.md:35
msgid ""
"Create burner is a simply way to incorporate burner wallets into your Dojo "
"app."
msgstr "버너 생성은 Dojo 앱에 버너 지갑을 통합하는 간단한 방법입니다."

#: src/client/npm.md:37
msgid "[Reopsitory](https://github.com/dojoengine/create-burner)"
msgstr "[Repository](https://github.com/dojoengine/create-burner)"

#: src/client/npm/core.md:3
msgid ""
"This library abstracts away the world interface and provides a set of helper "
"functions to interact with the world. It is preferred to use this library "
"over interacting with the world directly."
msgstr ""
"이 라이브러리는 월드 인터페이스를 추상화하고 월드와 상호작용할 수 있는 "
"helper 함수를 제공합니다. 월드와 직접 상호작용하는 것보다 이 라이브러리를 사"
"용하는 것이 좋습니다."

#: src/client/npm/core.md:5
msgid "World explorers"
msgstr ""

#: src/client/npm/core.md:6
msgid "World deployers"
msgstr ""

#: src/client/npm/core.md:7
msgid "Games"
msgstr ""

#: src/client/npm/core.md:8
msgid "Anaylitics"
msgstr ""

#: src/client/npm/core.md:16
#, fuzzy
msgid "Example Usage"
msgstr "### 사용 예시"

#: src/client/npm/core.md:18
msgid ""
"This is an example from [Dojo React App](https://github.com/dojoengine/dojo-"
"starter-react-app)"
msgstr ""
"이것은 [Dojo 리액트 앱](https://github.com/dojoengine/dojo-starter-react-app)"
"의 예시입니다"

#: src/client/npm/core.md:20
msgid ""
"```javascript\n"
"import { defineContractComponents } from \"./contractComponents\";\n"
"import { world } from \"./world\";\n"
"import { RPCProvider, Query, } from \"@dojoengine/core\";\n"
"import { Account, num } from \"starknet\";\n"
"import { GraphQLClient } from 'graphql-request';\n"
"import { getSdk } from '../generated/graphql';\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"import { defineContractComponents } from “./contractComponents”;\n"
"import { world } from “./world”;\n"
"import { RPCProvider, Query, } from “@dojoengine/core”;\n"
"import { Account, num } from “starknet”;\n"
"import { GraphQLClient } from ‘graphql-request’;\n"
"import { getSdk } from ‘../generated/graphql’;\n"
"\n"
"export type SetupNetworkResult = Awaited<ReturnType<typeof setupNetwork>>;\n"
"\n"
"export async function setupNetwork() {\n"
"\n"
"    const provider = new RPCProvider(import.meta.env."
"VITE_PUBLIC_WORLD_ADDRESS, import.meta.env.VITE_PUBLIC_NODE_URL);\n"
"\n"
"    return {\n"
"        contractComponents: defineContractComponents(world),\n"
"        provider,\n"
"        execute: async (signer: Account, system: string, call_data: num."
"BigNumberish[]) => provider.execute(signer, system, call_data),\n"
"        entity: async (component: string, query: Query) => provider."
"entity(component, query),\n"
"        entities: async (component: string, partition: number) => provider."
"entities(component, partition),\n"
"        world,\n"
"        graphSdk: getSdk(new GraphQLClient(import.meta.env."
"VITE_PUBLIC_TORII)),\n"
"        call: async (selector: string, call_data: num.BigNumberish[]) => "
"provider.call(selector, call_data),\n"
"    };\n"
"}\n"
"```"

#: src/toolchain/dojoup.md:1
#, fuzzy
msgid "`dojoup`"
msgstr "# `dojoup`"

#: src/toolchain/dojoup.md:3
msgid "Update or revert to a specific Dojo branch with ease."
msgstr "특정 Dojo 브랜치를 쉽게 업데이트하거나 되돌릴 수 있습니다."

#: src/toolchain/dojoup.md:5
#, fuzzy
msgid "Installing"
msgstr "## 설치"

#: src/toolchain/dojoup.md:11 src/toolchain/katana/overview.md:22
#, fuzzy
msgid "Usage"
msgstr "## 사용법"

#: src/toolchain/dojoup.md:13
msgid "To install latest **stable** version:"
msgstr "최신 **stable** 버전을 설치하려면:"

#: src/toolchain/dojoup.md:18
#, fuzzy
msgid ""
"Note: You may have to install `jq` to use `dojoup`. You can do so with the "
"following commands:"
msgstr ""
"> 참고: `dojoup`을 사용하려면 `jq`를 설치해야 할 수 있습니다. 다음 명령어를 "
"사용하여 설치할 수 있습니다:"

#: src/toolchain/dojoup.md:28
msgid "To install a specific **version** (in this case the `nightly` version):"
msgstr "특정 **버전**(이 경우 `nightly`버전)을 설치합니다:"

#: src/toolchain/dojoup.md:34
msgid ""
"To install a specific **branch** (in this case the `release/0.1.0` branch's "
"latest commit):"
msgstr ""
"특정 **브랜치**(이 경우 `release/0.1.0` 브랜치의 최신 커밋)를 설치하려면:"

#: src/toolchain/dojoup.md:40
msgid ""
"To install a **fork's main branch** (in this case `tarrencev/dojo`'s main "
"branch):"
msgstr ""
"**포크의 메인 브랜치**를 설치하려면(이 경우 `tarrencev/dojo`의 메인 브랜치):"

#: src/toolchain/dojoup.md:46
msgid ""
"To install a **specific branch in a fork** (in this case the `patch-10` "
"branch's latest commit in `tarrencev/dojo`):"
msgstr ""
"포크에 **특정 브랜치**를 설치하려면(이 경우 `patch-10` 브랜치의 최신 커밋이 "
"`tarrencev/dojo`에 있습니다):"

#: src/toolchain/dojoup.md:52
msgid "To install from a **specific Pull Request**:"
msgstr "**특정 풀 리퀘스트**에서 설치하려면:"

#: src/toolchain/dojoup.md:58
msgid "To install from a **specific commit**:"
msgstr "**특정 커밋**에서 설치하려면:"

#: src/toolchain/dojoup.md:64
msgid ""
"To install a local directory or repository (e.g. one located at `~/git/"
"dojo`, assuming you're in the home directory)"
msgstr ""
"로컬 디렉터리 또는 레포지토리(예: 홈 디렉터리에 있다고 가정할 때 `~/git/dojo`"
"에 있는 디렉터리)를 설치하려면 다음과 같이 합니다."

#: src/toolchain/dojoup.md:66
#, fuzzy
msgid ""
"Note: --branch, --repo, and --version flags are ignored during local "
"installations."
msgstr ""
"##### 참고: --branch, --repo 및 --version 플래그는 로컬 설치 시 무시됩니다."

#: src/toolchain/dojoup.md:74
msgid ""
"**Tip**: All flags have a single character shorthand equivalent! You can use "
"`-v` instead of `--version`, etc."
msgstr ""
"**팁**: 모든 플래그는 한 글자씩 약어로 표기할 수 있습니다! `—version` 대신 `-"
"v` 등을 사용할 수 있습니다."

#: src/toolchain/dojoup.md:78
#, fuzzy
msgid "Precompiled binaries"
msgstr "### 미리 컴파일된 바이너리"

#: src/toolchain/dojoup.md:80
#, fuzzy
msgid ""
"Precompiled binaries are available from the [GitHub releases page](https://"
"github.com/dojoengine/dojo/releases). These are better managed by using "
"[Dojoup](#using-dojoup)."
msgstr ""
"미리 컴파일된 바이너리는 [GitHub 릴리스 페이지](https://github.com/"
"dojoengine/dojo/releases)에서 사용할 수 있습니다.\n"
"[Dojoup](#using-dojoup)를 사용하면 더 잘 관리할 수 있습니다."

#: src/toolchain/dojoup.md:84
msgid "ℹ️ **Note**"
msgstr ""

#: src/toolchain/dojoup.md:86
#, fuzzy
msgid ""
"If you're on Windows, you will need to install and use [Git BASH](https://"
"gitforwindows.org/) or [WSL](https://learn.microsoft.com/en-us/windows/wsl/"
"install), as your terminal, since Dojoup currently does not support "
"Powershell or Cmd."
msgstr ""
"> ℹ️ **참고**\n"
">\n"
"> Windows를 사용하는 경우, [Git BASH](https://gitforwindows.org/) 또는 [WSL]"
"(https://learn.microsoft.com/en-us/windows/wsl/install)을 설치하여,\n"
"> 이를 터미널로 사용해야 합니다. Dojoup은 현재 파워쉘이나 Cmd를 지원하지 않습"
"니다."

#: src/toolchain/sozo/overview.md:3
msgid ""
"`sozo` is a powerful all-in-one tool for managing your Dojo projects. It "
"helps with everything from scaffolding a new project, all the way to "
"deploying and interacting with your Dojo Worlds. It includes a migration "
"planning tool, designed to streamline the updating and deployment of AWs. It "
"provides a robust command-line interface (CLI) that simplifies World "
"management tasks, enabling you to focus on the creative aspects of World-"
"building. In the future, it may include a GUI."
msgstr ""
"`sozo`는 Dojo 프로젝트를 관리할 수 있는 강력한 올인원 도구입니다. 새 프로젝트"
"의 템플릿부터 Dojo 월드 배포 및 상호 작용에 이르기까지 모든 것을 도와줍니다. "
"여기에는 AW의 업데이트와 배포를 간소화하도록 설계된 마이그레이션 도구가 포함"
"되어 있습니다. 월드 관리 작업을 간소화하는 강력한 명령줄 인터페이스(CLI)를 제"
"공하여 월드 구축의 창의적인 측면에 집중할 수 있도록 지원합니다. 향후에는 GUI"
"가 포함될 수 있습니다."

#: src/toolchain/sozo/overview.md:5 src/toolchain/katana/overview.md:5
#, fuzzy
msgid "Features"
msgstr "## 특징"

#: src/toolchain/sozo/overview.md:7
#, fuzzy
msgid ""
"**Binary CLI**: Sozo provides an intuitive binary CLI, ensuring easy "
"management of your Worlds, whether you're updating existing ones or "
"deploying new ones."
msgstr ""
"-   **바이너리 CLI**: Sozo는 직관적인 바이너리 CLI를 제공하여 기존 월드를 업"
"데이트 하거나 새 월드를 배포하여 월드를 쉽게 관리할 수 있습니다."

#: src/toolchain/sozo/overview.md:9 src/toolchain/katana/overview.md:10
#: src/toolchain/torii/overview.md:14
#, fuzzy
msgid "Installation"
msgstr "## 설치"

#: src/toolchain/sozo/overview.md:11
msgid ""
"`sozo` binary can be installed via [`dojoup`](../../getting-started/quick-"
"start.md), our dedicated installation package manager."
msgstr ""
"`sozo` 바이너리는 전용 설치 패키지 관리자인 [`dojoup`](../../getting-started/"
"quick-start.md)를 통해 설치할 수 있습니다."

#: src/toolchain/sozo/overview.md:13 src/toolchain/torii/overview.md:18
#, fuzzy
msgid "Installing from Source"
msgstr "### 소스 코드로 부터 설치하기"

#: src/toolchain/sozo/overview.md:15
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/sozo --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install —path ./crates/sozo —locked —force\n"
"```"

#: src/toolchain/sozo/overview.md:21
msgid ""
"This will install Sozo and the required dependencies on your local system."
msgstr "이렇게 하면 로컬 시스템에 Sozo와 필요한 종속성이 설치됩니다."

#: src/toolchain/sozo/overview.md:23 src/toolchain/katana/overview.md:60
#: src/toolchain/torii/overview.md:28
#, fuzzy
msgid "📚 **Reference**"
msgstr "참고"

#: src/toolchain/sozo/overview.md:25
#, fuzzy
msgid ""
"See the [`sozo` Reference](./reference.md) for a complete overview of all "
"the available subcommands."
msgstr ""
"> 📚 **참조**\n"
">\n"
"> 사용 가능한 모든 하위 명령에 대한 전체 개요는 [`sozo` Reference](./"
"reference.md)를 참조하세요."

#: src/toolchain/sozo/reference.md:1
#, fuzzy
msgid "sozo reference"
msgstr "## sozo reference"

#: src/toolchain/sozo/reference.md:3
#, fuzzy
msgid "Project Commands"
msgstr "### 프로젝트 명령문"

#: src/toolchain/sozo/reference.md:5
msgid "[init](./project-commands/init.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:6
msgid "[build](./project-commands/build.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:7
msgid "[test](./project-commands/test.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:8
msgid "[migrate](./project-commands/migrate.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:10
#, fuzzy
msgid "World Commands"
msgstr "### 월드 명령문"

#: src/toolchain/sozo/reference.md:12
msgid "[execute](./world-commands/execute.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:13
msgid "[register](./world-commands/register.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:14
msgid "[system](./world-commands/system.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:15
msgid "[component](./world-commands/component.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:16
msgid "[events](./world-commands/events.md)"
msgstr ""

#: src/toolchain/sozo/reference.md:17
msgid "[auth](./world-commands/auth.md)"
msgstr ""

#: src/toolchain/sozo/project-commands/init.md:1
#, fuzzy
msgid "sozo init"
msgstr "## sozo init"

#: src/toolchain/sozo/project-commands/init.md:3
msgid ""
"`init` is used to initialize a new project. It will initialize a new project "
"in the current directory by cloning the [dojo-starter](https://github.com/"
"dojoengine/dojo-starter)."
msgstr ""
"`init`은 새 프로젝트를 초기화하는 데 사용됩니다.[dojo-starter](https://"
"github.com/dojoengine/dojo-starter)를 복제하여 현재 디렉토리에 새 프로젝트를 "
"초기화합니다."

#: src/toolchain/sozo/project-commands/build.md:1
#, fuzzy
msgid "sozo build"
msgstr "## sozo build"

#: src/toolchain/sozo/project-commands/build.md:3
msgid ""
"`build` is used to compile the cairo contracts, generating the necessary "
"artifacts for deployment."
msgstr ""
"`build`는 cairo 컨트랙트를 컴파일하여 배포에 필요한 아티팩트를 생성하는 데 사"
"용됩니다."

#: src/toolchain/sozo/project-commands/test.md:1
#, fuzzy
msgid "sozo test"
msgstr "## sozo test"

#: src/toolchain/sozo/project-commands/test.md:3
msgid ""
"`test` is used to test the project's cairo contracts. It will run all tests "
"found within the project."
msgstr ""
"`test`는 프로젝트의 cairo 컨트랙트들을 테스트하는 데 사용됩니다. 프로젝트 내"
"에서 발견되는 모든 테스트를 실행합니다."

#: src/toolchain/sozo/project-commands/migrate.md:1
#, fuzzy
msgid "sozo migrate"
msgstr "## sozo migrate"

#: src/toolchain/sozo/project-commands/migrate.md:3
msgid ""
"`migrate` is used to perform the migration (deployment) process, declaring "
"and deploying contracts as necessary to deploy or update the World."
msgstr ""
"`migrate`은 마이그레이션(배포) 프로세스를 수행하는 데 사용되며, 월드 배포 또"
"는 업데이트에 필요한 컨트랙트를 선언하고 배포합니다."

#: src/toolchain/sozo/project-commands/migrate.md:5
msgid ""
"Changes made to the local World after the initial deployment, can easily be "
"pushed to the remote counterpart by running `sozo migrate --world "
"<WORLD_ADDRESS>` with `WORLD_ADDRESS` being the address of the remote World. "
"In the background, `migrate` will compute the diffs of the local and remote "
"World, then, start constructing a migration strategy to determine, if any, "
"which part of the local World needs to be pushed upstream."
msgstr ""
"최초 배포 후 로컬 월드에 대한 변경 사항은 `sozo migrate --world "
"<WORLD_ADDRESS>`를 실행하여 원격 월드에 쉽게 푸시할 수 있으며, 여기서 "
"`WORLD_ADDRESS`는 원격 월드의 주소입니다. `migrate`는 백그라운드에서 로컬 월"
"드와 원격 월드의 차이를 계산한 다음, 로컬 월드의 어느 부분을 업스트림으로 푸"
"시해야 하는지 결정하기 위한 마이그레이션 전략 구성을 시작합니다."

#: src/toolchain/sozo/project-commands/migrate.md:7
#: src/toolchain/sozo/world-commands/execute.md:7
#: src/toolchain/sozo/world-commands/system.md:5
#: src/toolchain/sozo/world-commands/component.md:5
#: src/toolchain/katana/reference.md:7 src/toolchain/torii/reference.md:7
#, fuzzy
msgid "USAGE"
msgstr "### 사용 방법"

#: src/toolchain/sozo/project-commands/migrate.md:13
#: src/toolchain/sozo/world-commands/execute.md:13
#: src/toolchain/sozo/world-commands/system.md:43
#: src/toolchain/sozo/world-commands/component.md:61
#: src/toolchain/katana/reference.md:105 src/toolchain/torii/reference.md:33
#, fuzzy
msgid "OPTIONS"
msgstr "### 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:15
#: src/toolchain/sozo/world-commands/execute.md:15
#: src/toolchain/katana/reference.md:107 src/toolchain/torii/reference.md:35
#, fuzzy
msgid "General Options"
msgstr "#### 일반 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:17
#, fuzzy
msgid ""
"`--name` _NAME_  \n"
"    Name of the World. At the moment, the only usage for this option is to "
"be used as a salt when deploying the World contract to avoid address "
"conflicts. This option is **required** when performing the initial migration "
"of the World."
msgstr ""
"`—name` _NAME_ \n"
"&nbsp;&nbsp;&nbsp;&nbsp;월드의 이름입니다. 현재 이 옵션의 유일한 용도는 주소 "
"충돌을 피하기 위해 월드 컨트랙트를 배포할 때 솔트로 사용하는 것입니다. 이 옵"
"션은 월드의 초기 마이그레이션을 수행할 때 **필수**입니다."

#: src/toolchain/sozo/project-commands/migrate.md:20
#: src/toolchain/sozo/world-commands/execute.md:21
#: src/toolchain/sozo/world-commands/system.md:45
#: src/toolchain/sozo/world-commands/component.md:63
#, fuzzy
msgid "World Options"
msgstr "#### 월드 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:22
#: src/toolchain/sozo/world-commands/execute.md:23
#: src/toolchain/sozo/world-commands/system.md:47
#: src/toolchain/sozo/world-commands/component.md:65
#, fuzzy
msgid ""
"`--world` _WORLD_ADDRESS_  \n"
"    The address of the World contract.  \n"
"    ENV: `DOJO_WORLD_ADDRESS`"
msgstr ""
"`—world` _WORLD_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;월드 컨트랙트의 주소입니다.   \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_WORLD_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:26
#: src/toolchain/sozo/world-commands/execute.md:27
#: src/toolchain/sozo/world-commands/system.md:51
#: src/toolchain/sozo/world-commands/component.md:69
#: src/toolchain/katana/reference.md:139
#, fuzzy
msgid "Starknet Options"
msgstr "#### 스타크넷 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:28
#: src/toolchain/sozo/world-commands/execute.md:29
#: src/toolchain/sozo/world-commands/system.md:53
#: src/toolchain/sozo/world-commands/component.md:71
#, fuzzy
msgid ""
"`--rpc-url` _URL_  \n"
"    The Starknet RPC endpoint. \\[default: http://localhost:5050\\]  \n"
"    ENV: `STARKNET_RPC_URL`"
msgstr ""
"`—rpc-url` _URL_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;스타크넷 RPC 엔드포인트입니다. [default: http://"
"localhost:5050]  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `STARKNET_RPC_URL`"

#: src/toolchain/sozo/project-commands/migrate.md:32
#: src/toolchain/sozo/world-commands/execute.md:33
#, fuzzy
msgid "Account Options"
msgstr "#### 계정 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:34
#: src/toolchain/sozo/world-commands/execute.md:35
#, fuzzy
msgid ""
"`--account-address` _ACCOUNT_ADDRESS_  \n"
"    The Starknet account address.  \n"
"    ENV: `DOJO_ACCOUNT_ADDRESS`"
msgstr ""
"`—account-address` _ACCOUNT_ADDRESS_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;스타크넷 계정 주소입니다.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_ACCOUNT_ADDRESS`"

#: src/toolchain/sozo/project-commands/migrate.md:38
#: src/toolchain/sozo/world-commands/execute.md:39
#, fuzzy
msgid "Signer Options - Raw"
msgstr "#### 서명자 옵션"

#: src/toolchain/sozo/project-commands/migrate.md:40
#: src/toolchain/sozo/world-commands/execute.md:41
#, fuzzy
msgid ""
"`--private-key` _PRIVATE_KEY_  \n"
"    The raw private key associated with the account contract.  \n"
"    ENV: `DOJO_PRIVATE_KEY`"
msgstr ""
"`—private-key` _PRIVATE_KEY_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;계정 컨트랙트와 연결된 프라이빗 키입니다.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_PRIVATE_KEY`"

#: src/toolchain/sozo/project-commands/migrate.md:44
#: src/toolchain/sozo/world-commands/execute.md:45
#, fuzzy
msgid "Signer Options - Keystore"
msgstr "#### 서명자 옵션 - 키스토어"

#: src/toolchain/sozo/project-commands/migrate.md:46
#: src/toolchain/sozo/world-commands/execute.md:47
#, fuzzy
msgid ""
"`--keystore` _PATH_  \n"
"    Use the keystore in the given folder or file."
msgstr ""
"`—keystore` _PATH_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;지정된 폴더 또는 파일에 있는 키스토어를 사용합니다."

#: src/toolchain/sozo/project-commands/migrate.md:49
#: src/toolchain/sozo/world-commands/execute.md:50
#, fuzzy
msgid ""
"`--password` _PASSWORD_  \n"
"    The keystore password. Used with --keystore.  \n"
"    ENV: `DOJO_KEYSTORE_PASSWORD`"
msgstr ""
"`—password` _PASSWORD_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;키스토어 비밀번호. 키스토어와 함께 사용됩니다.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;ENV: `DOJO_KEYSTORE_PASSWORD`"

#: src/toolchain/sozo/project-commands/migrate.md:53
#: src/toolchain/sozo/world-commands/execute.md:54
#: src/toolchain/sozo/world-commands/system.md:57
#: src/toolchain/katana/reference.md:178 src/toolchain/katana/reference.md:186
#, fuzzy
msgid "EXAMPLES"
msgstr "### 예제"

#: src/toolchain/sozo/project-commands/migrate.md:55
#, fuzzy
msgid "Deploying your World for the first time to a local Katana node"
msgstr "1. 로컬 Katana 노드에 처음으로 월드 배포하기"

#: src/toolchain/sozo/project-commands/migrate.md:57
msgid ""
"```sh\n"
"sozo migrate --name ohayo --rpc-url http://localhost:5050\n"
"```"
msgstr ""
"```sh\n"
"sozo migrate —name ohayo —rpc-url http://localhost:5050\n"
"```"

#: src/toolchain/sozo/project-commands/migrate.md:61
#, fuzzy
msgid "Updating a remote World after making some changes"
msgstr "2. 수정 사항 적용 후 원격 월드 업데이트하기"

#: src/toolchain/sozo/world-commands/execute.md:1
#, fuzzy
msgid "sozo execute"
msgstr "## sozo execute"

#: src/toolchain/sozo/world-commands/execute.md:3
msgid "`execute` is used to execute a World's system."
msgstr "`execute`은 월드의 시스템을 실행하는 데 사용됩니다."

#: src/toolchain/sozo/world-commands/execute.md:5
msgid ""
"Performing a system execution requires sending a transaction, therefore, "
"`execute` expects an account address as well as its respective private key "
"in order to sign the transaction before sending it."
msgstr ""
"시스템을 실행하려면 트랜잭션을 전송해야 하므로 `execute`은 트랜잭션을 전송하"
"기 전에 트랜잭션에 서명하기 위한 계정 주소와 해당 개인키를 요구합니다."

#: src/toolchain/sozo/world-commands/execute.md:17
#, fuzzy
msgid ""
"`--calldata` _CALLDATA_  \n"
"    The calldata to be passed to the system that you want to execute.  \n"
"    Comma seperated values e.g., 0x12345,0x69420."
msgstr ""
"`—calldata` _CALLDATA_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;실행하려는 시스템에 전달할 호출 데이터입니다.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;쉼표로 구분된 값(e.g., 0x12345,0x69420)."

#: src/toolchain/sozo/world-commands/execute.md:56
#, fuzzy
msgid ""
"Executing the _position_ system which takes two values (_x_: 0x77 and _y_: "
"0x44)"
msgstr ""
"1. 두 개의 값(_x_: 0x77, _y_: 0x44)을 가지는 _position_ 시스템을 실행합니다"

#: src/toolchain/sozo/world-commands/register.md:1
#, fuzzy
msgid "sozo register"
msgstr "## sozo register"

#: src/toolchain/sozo/world-commands/register.md:3
msgid "`register` is used to register new systems and components."
msgstr "`register`은 새 시스템과 컴포넌트를 등록하는 데 사용됩니다."

#: src/toolchain/sozo/world-commands/system.md:1
#, fuzzy
msgid "sozo system"
msgstr "## sozo system"

#: src/toolchain/sozo/world-commands/system.md:3
msgid ""
"`system` is used to interact with a World's systems. It is useful for "
"querying about a system's information."
msgstr ""
"`system`은 월드의 시스템과 상호작용하는 데 사용됩니다. 시스템 정보를 쿼리할 "
"때 유용합니다."

#: src/toolchain/sozo/world-commands/system.md:15
#: src/toolchain/sozo/world-commands/component.md:16
#, fuzzy
msgid "SUBCOMMANDS"
msgstr "### 하위 명령"

#: src/toolchain/sozo/world-commands/system.md:17
#: src/toolchain/sozo/world-commands/component.md:18
#, fuzzy
msgid "`get`"
msgstr "#### `get`"

#: src/toolchain/sozo/world-commands/system.md:19
msgid "Get the class hash of a system"
msgstr "시스템의 클래스 해시 가져오기"

#: src/toolchain/sozo/world-commands/system.md:25
#: src/toolchain/sozo/world-commands/system.md:38
#: src/toolchain/sozo/world-commands/component.md:26
#: src/toolchain/sozo/world-commands/component.md:39
#: src/toolchain/sozo/world-commands/component.md:52
#, fuzzy
msgid "Arguments"
msgstr "##### 인자들"

#: src/toolchain/sozo/world-commands/system.md:27
#: src/toolchain/sozo/world-commands/system.md:40
#, fuzzy
msgid ""
"_`NAME`_  \n"
"    The name of the system"
msgstr ""
"_`NAME`_  \n"
"&nbsp;&nbsp;&nbsp;&nbsp;시스템의 이름"

#: src/toolchain/sozo/world-commands/system.md:30
#, fuzzy
msgid "`dependency`"
msgstr "#### `종속성`"

#: src/toolchain/sozo/world-commands/system.md:32
msgid "Retrieve the component dependencies of a system"
msgstr "시스템의 컴포넌트 종속성 검색"

#: src/toolchain/sozo/world-commands/system.md:59
#, fuzzy
msgid "Get the class hash of the _spawn_ system"
msgstr "1. _spawn_ 시스템의 클래스 해시를 가져옵니다"

#: src/toolchain/sozo/world-commands/system.md:65
#, fuzzy
msgid "Get the component dependencies of the _spawn_ system"
msgstr "2. _spawn_ 시스템의 컴포넌트 종속성 가져오기"

#: src/toolchain/sozo/world-commands/component.md:1
#, fuzzy
msgid "sozo component"
msgstr "## sozo 컴포넌트"

#: src/toolchain/sozo/world-commands/component.md:3
msgid ""
"`component` is used to interact with a World's components. It is useful for "
"querying about a component's information, or a component value of an entity."
msgstr ""
"`component`는 월드의 컴포넌트와 상호작용하는 데 사용됩니다. 컴포넌트의 정보"
"나 엔티티의 컴포넌트 값을 쿼리할 때 유용합니다."

#: src/toolchain/sozo/world-commands/component.md:20
msgid "Get the class hash of a component"
msgstr "컴포넌트의 클래스 해시 가져오기"

#: src/toolchain/sozo/world-commands/component.md:28
#: src/toolchain/sozo/world-commands/component.md:41
#: src/toolchain/sozo/world-commands/component.md:54
#, fuzzy
msgid ""
"_`NAME`_  \n"
"    The name of the component"
msgstr ""
"_`NAME`_\n"
"&nbsp;&nbsp;&nbsp;&nbsp;컴포넌트의 이름"

#: src/toolchain/sozo/world-commands/component.md:31
#, fuzzy
msgid "`schema`"
msgstr "#### `schema`"

#: src/toolchain/sozo/world-commands/component.md:33
msgid "Retrieve the schema for a component"
msgstr "컴포넌트에 대한 스키마 검색"

#: src/toolchain/sozo/world-commands/component.md:44
#, fuzzy
msgid "`entity`"
msgstr "#### `entity`"

#: src/toolchain/sozo/world-commands/component.md:46
msgid "Get the component value for an entity"
msgstr "엔티티의 컴포넌트 값 가져오기"

#: src/toolchain/sozo/world-commands/component.md:57
#, fuzzy
msgid ""
"_`KEYS`_  \n"
"    The keys of the entity that you want to query.  \n"
"    Comma seperated values e.g., 0x12345,0x69420,..."
msgstr ""
"_`KEYS`_\n"
" &nbsp;&nbsp;&nbsp;&nbsp;쿼리하려는 엔티티의 키입니다.  \n"
" &nbsp;&nbsp;&nbsp;&nbsp;쉼표로 구분된 값(예: 0x12345,0x69420,...)."

#: src/toolchain/sozo/world-commands/events.md:1
#, fuzzy
msgid "sozo events"
msgstr "## sozo 이벤트"

#: src/toolchain/sozo/world-commands/events.md:3
msgid "`events` is used to queries world events."
msgstr "`events`는 월드 이벤트를 쿼리하는 데 사용됩니다."

#: src/toolchain/sozo/world-commands/auth.md:1
#, fuzzy
msgid "sozo auth"
msgstr "## sozo 인증"

#: src/toolchain/sozo/world-commands/auth.md:3
msgid "`auth` is used to manage world authorization."
msgstr "`auth`은 월드 인증을 관리하는 데 사용됩니다."

#: src/toolchain/katana/overview.md:3
msgid ""
"`katana` is a _blazingly fast_ local Starknet node, designed to support "
"local development with Dojo."
msgstr ""
"`katana`는 Dojo와 함께 로컬 개발을 지원하기 위해 설계된 _엄청나게 빠른_ 로컬 "
"스타크넷 노드입니다."

#: src/toolchain/katana/overview.md:7
#, fuzzy
msgid ""
"[Starknet JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-specs/"
"tree/v0.3.0) support"
msgstr ""
"-   [스타크넷 JSON-RPC v0.3.0](https://github.com/starkware-libs/starknet-"
"specs/tree/v0.3.0) 지원\n"
"-   블록체인 상태 조작을 위한 사용자 정의 메서드들"

#: src/toolchain/katana/overview.md:8
msgid "Custom methods for manipulating the blockchain states"
msgstr ""

#: src/toolchain/katana/overview.md:12
msgid ""
"`katana` binary is available via [`dojoup`](../../getting-started/quick-"
"start.md)."
msgstr ""
"`katana` 바이너리는 [`dojoup`](../../getting-started/quick-start.md)를 통해 "
"사용할 수 있습니다."

#: src/toolchain/katana/overview.md:14
#, fuzzy
msgid "Installing from source"
msgstr "### 소스 코드로 부터 설치하기"

#: src/toolchain/katana/overview.md:16
msgid ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""
"```sh\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install —path ./crates/katana —locked —force\n"
"```"

#: src/toolchain/katana/overview.md:24
msgid ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"
msgstr ""
"```console\n"
"$ katana\n"
"\n"
"\n"
"\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x3ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x1b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x4486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://127.0.0.1:5050\n"
"\n"
"\n"
"```"

#: src/toolchain/katana/overview.md:62
#, fuzzy
msgid ""
"See the [`katana` Reference](./reference.md) for an in depth reference and "
"documentation on Katana."
msgstr ""
"> 📚 **참조**\n"
">\n"
"> katana에 대한 자세한 참조 및 문서는 [`katana` Reference](./reference.md)를 "
"참조하세요."

#: src/toolchain/katana/reference.md:1
#, fuzzy
msgid "katana reference"
msgstr "## katana reference"

#: src/toolchain/katana/reference.md:3
#, fuzzy
msgid "NAME"
msgstr "### 이름"

#: src/toolchain/katana/reference.md:5
msgid ""
"katana - Create a local testnet node for deploying and testing Starknet "
"smart contracts."
msgstr ""
"katana - 스타크넷 스마트 컨트랙트를 배포하고 테스트하기 위한 로컬 테스트넷 노"
"드를 생성합니다."

#: src/toolchain/katana/reference.md:13 src/toolchain/torii/reference.md:13
#, fuzzy
msgid "DESCRIPTION"
msgstr "### 설명"

#: src/toolchain/katana/reference.md:15
msgid ""
"Create a local testnet node for deploying and testing Starknet smart "
"contracts. Katana supports deployment and execution of the **new** as well "
"as the **legacy** (Cairo 0) Cairo contracts."
msgstr ""
"스타크넷 스마트 컨트랙트를 배포하고 테스트하기 위한 로컬 테스트넷 노드를 생성"
"합니다. Katana **새로운** Cairo 컨트랙트뿐만 아니라 **레거시**(Cairo 0) "
"Cairo 컨트랙트의 배포와 실행을 지원합니다."

#: src/toolchain/katana/reference.md:17
msgid ""
"This section covers an extensive list of information about Mining Modes, "
"Supported RPC Methods, Katana flags and their usages. You can run multiple "
"flags at the same time."
msgstr ""
"이 섹션에서는 마이닝 모드, 지원되는 RPC 메서드, Katana 플래그와 그 사용법에 "
"대한 광범위한 정보를 다룹니다. 여러 플래그를 동시에 실행할 수 있습니다."

#: src/toolchain/katana/reference.md:19
#, fuzzy
msgid "Mining Modes"
msgstr "#### 마이닝 모드"

#: src/toolchain/katana/reference.md:21
msgid ""
"In Katana, mining modes determine how frequent blocks are mined. By default, "
"a new block is automatically mined as soon as a transaction is submitted."
msgstr ""
"Katana에서는 마이닝 모드에 따라 블록이 채굴되는 빈도가 결정됩니다. 기본적으"
"로 트랜잭션이 제출되는 즉시 새 블록이 자동으로 채굴됩니다."

#: src/toolchain/katana/reference.md:23
msgid ""
"You can switch from the default mining behaviour to interval mining, where a "
"new block is created at a fixed time interval selected by the user. To "
"enable this mode of mining, use the `--block-time <SECONDS>` flag, as "
"demonstrated in the following example."
msgstr ""
"기본 마이닝 동작에서 사용자가 선택한 고정된 시간 간격으로 새 블록이 생성되는 "
"간격 채굴로 전환할 수 있습니다. 이 채굴 모드를 활성화하려면 다음 예시와 같이 "
"`—block-time <SECONDS>` 플래그를 사용하세요."

#: src/toolchain/katana/reference.md:30
#, fuzzy
msgid "Supported Transport Layers"
msgstr "#### 지원되는 전송 계층"

#: src/toolchain/katana/reference.md:32
msgid ""
"Only HTTP connection is supported at the moment. The server listens on port "
"5050 by default, but it can be changed by running the following command:"
msgstr ""
"현재는 HTTP 연결만 지원됩니다. 서버는 기본적으로 포트 5050에서 수신 대기하지"
"만 다음 명령을 실행하여 변경할 수 있습니다:"

#: src/toolchain/katana/reference.md:38
#, fuzzy
msgid "Starknet Feature Compatibility"
msgstr "#### 스타크넷 기능 호환성"

#: src/toolchain/katana/reference.md:40
#, fuzzy
msgid "Supported Transaction Type"
msgstr "##### 지원되는 트랜잭션 유형"

#: src/toolchain/katana/reference.md:42
msgid "Type"
msgstr ""

#: src/toolchain/katana/reference.md:42
msgid "Version"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "INVOKE"
msgstr ""

#: src/toolchain/katana/reference.md:44
msgid "1"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "DECLARE"
msgstr ""

#: src/toolchain/katana/reference.md:45
msgid "1, 2"
msgstr ""

#: src/toolchain/katana/reference.md:46
msgid "DEPLOY_ACCOUNT"
msgstr ""

#: src/toolchain/katana/reference.md:48
#, fuzzy
msgid "Supported RPC Methods"
msgstr "#### 지원되는 RPC 매서드"

#: src/toolchain/katana/reference.md:50
#, fuzzy
msgid "Starknet Methods"
msgstr "##### 스타크넷 매서드"

#: src/toolchain/katana/reference.md:52
msgid ""
"Katana supports version **v0.3.0** of the Starknet JSON-RPC specifications. "
"The standard methods are based on [this](https://github.com/starkware-libs/"
"starknet-specs/tree/v0.3.0) reference."
msgstr ""
"Katana 스타크넷 JSON-RPC 사양의 **v0.3.0** 버전을 지원합니다. 표준 메서드는 "
"[여기](https://github.com/starkware-libs/starknet-specs/tree/v0.3.0)를 기반으"
"로 합니다."

#: src/toolchain/katana/reference.md:54
msgid "`starknet_blockNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:55
msgid "`starknet_blockHashAndNumber`"
msgstr ""

#: src/toolchain/katana/reference.md:56
msgid "`starknet_getBlockWithTxs`"
msgstr ""

#: src/toolchain/katana/reference.md:57
msgid "`starknet_getBlockWithTxHashes`"
msgstr ""

#: src/toolchain/katana/reference.md:58
msgid "`starknet_getBlockTransactionCount`"
msgstr ""

#: src/toolchain/katana/reference.md:59
msgid "`starknet_getTransactionByHash`"
msgstr ""

#: src/toolchain/katana/reference.md:60
msgid "`starknet_getTransactionByBlockIdAndIndex`"
msgstr ""

#: src/toolchain/katana/reference.md:61
msgid "`starknet_getTransactionReceipt`"
msgstr ""

#: src/toolchain/katana/reference.md:62
msgid "`starknet_pendingTransactions`"
msgstr ""

#: src/toolchain/katana/reference.md:63
msgid "`starknet_getStateUpdate`"
msgstr ""

#: src/toolchain/katana/reference.md:65
msgid "`starknet_call`"
msgstr ""

#: src/toolchain/katana/reference.md:66
msgid "`starknet_estimateFee`"
msgstr ""

#: src/toolchain/katana/reference.md:68
msgid "`starknet_chainId`"
msgstr ""

#: src/toolchain/katana/reference.md:70
msgid "`starknet_getNonce`"
msgstr ""

#: src/toolchain/katana/reference.md:71
msgid "`starknet_getEvents`"
msgstr ""

#: src/toolchain/katana/reference.md:72
msgid "`starknet_getStorageAt`"
msgstr ""

#: src/toolchain/katana/reference.md:73
msgid "`starknet_getClassHashAt`"
msgstr ""

#: src/toolchain/katana/reference.md:74
msgid "`starknet_getClass`"
msgstr ""

#: src/toolchain/katana/reference.md:75
msgid "`starknet_getClassAt`"
msgstr ""

#: src/toolchain/katana/reference.md:77
msgid "`starknet_syncing`"
msgstr ""

#: src/toolchain/katana/reference.md:79
msgid "`starknet_addInvokeTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:80
msgid "`starknet_addDeclareTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:81
msgid "`starknet_addDeployAccountTransaction`"
msgstr ""

#: src/toolchain/katana/reference.md:83
#, fuzzy
msgid "Custom Methods"
msgstr "##### 사용자 지정 매서드"

#: src/toolchain/katana/reference.md:85
msgid ""
"Katana provides a convenient set of custom RPC methods to quickly and easily "
"configure the node to suit your testing environment."
msgstr ""
"Katana는 테스트 환경에 맞게 노드를 빠르고 쉽게 구성할 수 있는 편리한 사용자 "
"지정 RPC 메서드를 제공합니다."

#: src/toolchain/katana/reference.md:87
msgid ""
"`katana_generateBlock`  \n"
"Mine a new block which includes all currently pending transactions."
msgstr ""
"`katana_generateBlock` \n"
"현재 보류 중인 모든 트랜잭션을 포함하는 새 블록을 채굴합니다."

#: src/toolchain/katana/reference.md:90
msgid ""
"`katana_nextBlockTimestamp`  \n"
"Get the time for the next block."
msgstr ""
"`katana_nextBlockTimestamp`\n"
"다음 블록의 시간을 가져옵니다."

#: src/toolchain/katana/reference.md:93
msgid ""
"`katana_increaseNextBlockTimestamp`  \n"
"Increase the time for the block by a given amount of time, in seconds."
msgstr ""
"`katana_increaseNextBlockTimestamp`  \n"
"블록의 시간을 주어진 시간만큼(초 단위) 늘립니다."

#: src/toolchain/katana/reference.md:96
msgid ""
"`katana_setNextBlockTimestamp`  \n"
"Similar to `katana_increaseNextBlockTimestamp` but takes the exact timestamp "
"that you want in the next block."
msgstr ""
"`katana_setNextBlockTimestamp`  \n"
"`katana_increaseNextBlockTimestamp`와 유사하지만 다음 블록에서 원하는 정확한 "
"타임스탬프를 가져옵니다."

#: src/toolchain/katana/reference.md:99
msgid ""
"`katana_predeployedAccounts`  \n"
"Get the info for all of the predeployed accounts."
msgstr ""
"`katana_predeployedAccounts`  \n"
"사전 배포된 모든 계정에 대한 정보를 가져옵니다."

#: src/toolchain/katana/reference.md:102
msgid ""
"`katana_setStorageAt`  \n"
"Set an exact value of a contract's storage slot."
msgstr ""
"`katana_setStorageAt`  \n"
"컨트랙트의 스토리지 슬롯의 정확한 값을 설정합니다."

#: src/toolchain/katana/reference.md:109
#, fuzzy
msgid ""
"`--silent`  \n"
"     Don't print anything on startup."
msgstr ""
"`—silent`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 시작 시 아무 것도 출력하지 않습니다."

#: src/toolchain/katana/reference.md:112
#, fuzzy
msgid ""
"`--no-mining`  \n"
"     Disable auto and interval mining, and mine on demand instead."
msgstr ""
"`—no-mining`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 자동 마이닝 및 간격 마이닝을 비활성화하고 대신 요청"
"에 따라 채굴하는 방식을 사용합니다."

#: src/toolchain/katana/reference.md:115
#, fuzzy
msgid ""
"`-b, --block-time <SECONDS>`  \n"
"     Block time in seconds for interval mining."
msgstr ""
"`-b, —block-time <SECONDS>`  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 인터벌 마이닝을 위한 블록 시간(초) 입니다."

#: src/toolchain/katana/reference.md:118
#, fuzzy
msgid ""
"`--dump-state <PATH>`  \n"
"     Dump the state of chain on exit to the given file.  \n"
"     If the value is a directory, the state will be written to `<PATH>/state."
"bin`."
msgstr ""
"`—dump-state <PATH>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 종료 시 체인의 상태를 지정된 파일에 덤프합니다.  \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 값이 디렉터리인 경우 상태는 `<PATH>/state.bin`에 기"
"록됩니다."

#: src/toolchain/katana/reference.md:122
#, fuzzy
msgid ""
"`--load-state <PATH>`  \n"
"     Initialize the chain from a previously saved state snapshot."
msgstr ""
"`—load-state <PATH>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 이전에 저장한 상태 스냅샷에서 체인을 시작합니다."

#: src/toolchain/katana/reference.md:125
#, fuzzy
msgid ""
"`-h, --help`  \n"
"     Print help (see a summary with '-h')."
msgstr ""
"`h, --help`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 도움말을 출력합니다('-h' 요약 참조)."

#: src/toolchain/katana/reference.md:128
#, fuzzy
msgid ""
"`-V, --version`  \n"
"     Print version information."
msgstr ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp;버전 정보를 출력합니다."

#: src/toolchain/katana/reference.md:131
#, fuzzy
msgid "Server Options"
msgstr "#### 서버 옵션"

#: src/toolchain/katana/reference.md:133
#, fuzzy
msgid ""
"`-p, --port <PORT>`  \n"
"     Port number to listen on. \\[default: 5050\\]"
msgstr ""
"`-p, —port <PORT>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 수신할 포트 번호입니다. [기본값: 5050]"

#: src/toolchain/katana/reference.md:136
#, fuzzy
msgid ""
"`--host <HOST>`  \n"
"     The IP address the server will listen on."
msgstr ""
"`--host <HOST>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 서버가 수신 대기할 IP 주소입니다."

#: src/toolchain/katana/reference.md:141
#, fuzzy
msgid ""
"`--seed <SEED>`  \n"
"     Specify the seed for randomness of accounts to be predeployed."
msgstr ""
"`—seed <SEED>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 사전 배포할 계정의 무작위성을 위한 시드를 지정합니"
"다."

#: src/toolchain/katana/reference.md:144
#, fuzzy
msgid ""
"`--accounts <NUM>`  \n"
"     Number of pre-funded accounts to generate. \\[default: 10\\]"
msgstr ""
"`—accounts<NUM>` \n"
"&nbsp;&nbsp;&nbsp;&nbsp; 생성할 미리 펀딩된 계정 수입니다. [기본값: 10]"

#: src/toolchain/katana/reference.md:147
#, fuzzy
msgid ""
"`--disable-fee`  \n"
"     Disable charging fee for transactions."
msgstr ""
"`—disable-fee`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 거래 수수료 청구를 비활성화합니다."

#: src/toolchain/katana/reference.md:150
#, fuzzy
msgid "Environment Options"
msgstr "#### 환경 옵션"

#: src/toolchain/katana/reference.md:152
#, fuzzy
msgid ""
"`--chain-id <CHAIN_ID>`  \n"
"     The chain ID. \\[default: KATANA\\]"
msgstr ""
"`--chain-id <CHAIN_ID>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 체인 ID입니다. [기본값: KATANA]"

#: src/toolchain/katana/reference.md:155
#, fuzzy
msgid ""
"`--gas-price <GAS_PRICE>`  \n"
"     The gas price."
msgstr ""
"`—gas-price <GAS_PRICE>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 가스 가격입니다."

#: src/toolchain/katana/reference.md:158
#, fuzzy
msgid ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account validation logic."
msgstr ""
"`--validate-max-steps <VALIDATE_MAX_STEPS>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 계정 유효성 검사 로직에 사용할 수 있는 최대 단계 수"
"입니다."

#: src/toolchain/katana/reference.md:161
#, fuzzy
msgid ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`  \n"
"     The maximum number of steps available for the account execution logic."
msgstr ""
"`--invoke-max-steps <INVOKE_MAX_STEPS>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 계정 실행 로직에 사용할 수 있는 최대 스텝 수입니다."

#: src/toolchain/katana/reference.md:164
#, fuzzy
msgid "Shell Completions"
msgstr "### 셸 완성"

#: src/toolchain/katana/reference.md:166
msgid "`katana` completions shell"
msgstr "`katana` 완성 셸"

#: src/toolchain/katana/reference.md:168
msgid "Generates a shell completions script for the given shell."
msgstr "주어진 셸에 대한 셸 완성 스크립트를 생성합니다."

#: src/toolchain/katana/reference.md:170
msgid "Supported shells are:"
msgstr "지원되는 셸은 다음과 같습니다:"

#: src/toolchain/katana/reference.md:172
msgid "bash"
msgstr ""

#: src/toolchain/katana/reference.md:173
msgid "elvish"
msgstr ""

#: src/toolchain/katana/reference.md:174
msgid "fish"
msgstr ""

#: src/toolchain/katana/reference.md:175
msgid "powershell"
msgstr ""

#: src/toolchain/katana/reference.md:176
msgid "zsh"
msgstr ""

#: src/toolchain/katana/reference.md:180
msgid ""
"Generate shell completions script for `bash` and appends it to a `.bashrc` "
"file:"
msgstr "`bash`에 대한 셸 완성 스크립트를 생성하여 `.bashrc` 파일에 추가합니다:"

#: src/toolchain/katana/reference.md:188
#, fuzzy
msgid "Create 15 dev accounts and disable transaction fee mechanism"
msgstr "1. 15개의 개발용 계정 생성 및 거래 수수료 메커니즘 비활성화"

#: src/toolchain/katana/reference.md:194
#, fuzzy
msgid "Set the chain id to `SN_GOERLI` and run the server on port 8545"
msgstr ""
"2. 체인 아이디를 `SN_GOERLI`로 설정하고 포트 8545에서 서버를 실행합니다"

#: src/toolchain/katana/reference.md:200
#, fuzzy
msgid ""
"Load previously stored state and dump the state of this session to a file on "
"shutdown"
msgstr ""
"3. 이전에 저장된 상태를 로드하고 종료 시 이 세션의 상태를 파일로 덤프합니다"

#: src/toolchain/torii/overview.md:1
#, fuzzy
msgid "Torii - Networking & Indexing"
msgstr "## Torii - 네트워킹 및 인덱싱"

#: src/toolchain/torii/overview.md:3
msgid ""
"Torii is an automatic indexer for dojo worlds. Built in rust to be blazingly "
"fast and exceptionally scalable."
msgstr ""
"Torii는 dojo 월드를 위한 자동 인덱서입니다. Rust로 제작되어 매우 빠르고 확장"
"성이 뛰어납니다."

#: src/toolchain/torii/overview.md:5
#, fuzzy
msgid "Dojo indexer"
msgstr "### Dojo 인덱서"

#: src/toolchain/torii/overview.md:7
msgid ""
"Torii indexes your dojo worlds and exposes a GraphQL API to query them. "
"Simply run:"
msgstr ""
"Torii는 Dojo 월드를 인덱싱하고 이를 쿼리할 수 있는 GraphQL API를 노출합니다. "
"다음과 같이 실행할 수 있습니다:"

#: src/toolchain/torii/overview.md:12
msgid "and you'll have a GraphQL API running on `http://localhost:8080`!"
msgstr "그러면 `http://localhost:8080`에서 GraphQL API가 실행됩니다!"

#: src/toolchain/torii/overview.md:16
msgid ""
"The `torii` binary can be installed via [`dojoup`](../../getting-started/"
"quick-start.md), our dedicated installation package manager."
msgstr ""
"`torii` 바이너리는 전용 설치 패키지 관리자인 [`dojoup`](../../getting-"
"started/quick-start.md) 통해 설치할 수 있습니다."

#: src/toolchain/torii/overview.md:20
msgid "If you prefer to install from the source code:"
msgstr "소스 코드에서 설치하는 것을 선호하는 경우:"

#: src/toolchain/torii/overview.md:26
msgid ""
"This will install Torii and the required dependencies on your local system."
msgstr "이렇게 하면 로컬 시스템에 Torii 및 필수 종속성들이 설치됩니다."

#: src/toolchain/torii/overview.md:30
#, fuzzy
msgid "See the [`torii` Reference](./reference.md) for a complete reference."
msgstr ""
"> 📚 **참조**\n"
">\n"
"> 전체 참조 내용은 [`torii` Reference](./reference.md)를 참조하세요."

#: src/toolchain/torii/reference.md:1
#, fuzzy
msgid "torii reference"
msgstr "## torii 참조"

#: src/toolchain/torii/reference.md:3
#, fuzzy
msgid "Name"
msgstr "### 이름"

#: src/toolchain/torii/reference.md:5
msgid "torii - An automatic indexer and networking layer for a world contract."
msgstr "torii - 월드 컨트랙트를 위한 자동 인덱서 및 네트워킹 레이어입니다."

#: src/toolchain/torii/reference.md:15
msgid ""
"`torii` starts the indexer and exposes GraphQL/gRPC API endpoints. The "
"indexer queries the specified Starknet RPC endpoint for transaction blocks "
"and listens for transactions related to the world contract. These "
"transactions can include component/system registrations, entity state "
"updates, system calls, and events. The parsed data is then stored in a local "
"SQLite database."
msgstr ""
"`torii` 는 인덱서를 시작하고 GraphQL/gRPC API 엔드포인트를 노출합니다. 인덱서"
"는 지정된 스타크넷 RPC 엔드포인트에서 트랜잭션 블록을 쿼리하고 월드 컨트랙트"
"와 관련된 트랜잭션을 수신 대기합니다. 이러한 트랜잭션에는 컴포넌트/시스템 등"
"록, 엔티티 상태 업데이트, 시스템 호출 및 이벤트가 포함될 수 있습니다. 파된 데"
"이터는 로컬 SQLite 데이터베이스에 저장됩니다."

#: src/toolchain/torii/reference.md:17
msgid ""
"The GraphQL and gRPC API endpoints run in tandem with the indexer, providing "
"custom queries specific to the world contract for client applications."
msgstr ""
"GraphQL 및 gRPC API 엔드포인트는 인덱서와 함께 실행되어 클라이언트 애플리케이"
"션을 위한 월드 컨트랙트에 특정한 사용자 지정 쿼리를 제공합니다."

#: src/toolchain/torii/reference.md:19
#, fuzzy
msgid "Database URL"
msgstr "#### 데이터베이스 URL"

#: src/toolchain/torii/reference.md:21
msgid ""
"`torii` uses a sqlite database to store indexed data. The database can be "
"stored either in-memory or persistently on the filesystem."
msgstr ""
"`torii`는 색인된 데이터를 저장하기 위해 sqlite 데이터베이스를 사용합니다. 데"
"이터베이스는 인메모리에 저장하거나 파일 시스템에 영구적으로 저장할 수 있습니"
"다."

#: src/toolchain/torii/reference.md:23
#, fuzzy
msgid ""
"The in-memory database is ephermal and only lasts as long as the indexer is "
"running. This is a fast and simple option to start the indexer for "
"development/testing."
msgstr ""
"- 인메모리 데이터베이스는 임시적으로 인덱서가 실행되는 동안에만 지속됩니다. "
"이것은 개발/테스트를 위해 인덱서를 시작하는 빠르고 간단한 옵션입니다.\n"
"- 프로덕션 환경에서는 영구 저장소를 사용해야 합니다. 로컬 파일 시스템을 저장"
"소로 사용합니다."

#: src/toolchain/torii/reference.md:24
msgid ""
"Presistent storage should be used in production. It relies on the local "
"filesystem for storage."
msgstr ""

#: src/toolchain/torii/reference.md:26
msgid ""
"Note: If using in-memory db, the memory will be garbage collected after a "
"period of inactivity, causing queries to result in errors. A workaround is "
"to start `katana` with the `--block-time` option or use a persistent "
"database."
msgstr ""
"참고: 인메모리 데이터베이스를 사용하는 경우, 일정 시간 동안 사용하지 않으면 "
"메모리가 수집되어(Garbage Collect) 쿼리에서 오류가 발생할 수 있습니다. 해결 "
"방법은 `--block-time` 옵션으로 `katana`를 시작하거나 영구 데이터베이스를 사용"
"하는 것입니다."

#: src/toolchain/torii/reference.md:37
#, fuzzy
msgid "`-w, --world`      Address of the world contract to index"
msgstr ""
"`-w, —world`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 인덱싱할 월드 컨트랙트의 주소"

#: src/toolchain/torii/reference.md:40
#, fuzzy
msgid ""
"`--rpc`      Starknet RPC endpoing to use \\[default: http//localhost:5050\\]"
msgstr ""
"`--rpc`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 사용할 스타크넷 RPC 주소 [기본값: http//"
"localhost:5050]"

#: src/toolchain/torii/reference.md:43
#, fuzzy
msgid ""
"`-m, --manifest <MANIFEST>`      Specify a local manifest to initialize from"
msgstr ""
"`-m, —manifest <MANIFEST>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 초기화할 로컬 매니페스트를 지정합니다"

#: src/toolchain/torii/reference.md:46
#, fuzzy
msgid ""
"`-d, --database-url <DATABASE_URL>`      Database URL (read more above) "
"\\[default: sqlite::memory:\\]"
msgstr ""
"`-d, --database-url <DATABASE_URL>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 데이터베이스 URL(위 내용 참조) [기본값: sqlite::"
"memory:]"

#: src/toolchain/torii/reference.md:49
#, fuzzy
msgid ""
"`-s, --start-block <START_BLOCK>`      Specify a block to start indexing "
"from, ignored if stored head exists \\[default: 0\\]"
msgstr ""
"`-s, --start-block <START_BLOCK>`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 인덱싱을 시작할 블록 지정, 저장된 시작 지점이 있는 "
"경우 무시됨 [기본값: 0]"

#: src/toolchain/torii/reference.md:52
msgid "`-h, --help`      Print help"
msgstr ""

#: src/toolchain/torii/reference.md:55
#, fuzzy
msgid "`-V, --version`      Print version"
msgstr ""
"`-V, --version`\n"
"&nbsp;&nbsp;&nbsp;&nbsp; 버전 정보 출력"

#: src/deployment/locally.md:1
#, fuzzy
msgid "Deploying Locally"
msgstr "## 로컬 배포하기"

#: src/deployment/locally.md:3
msgid ""
"Dojo is engineered for rapid development, boasting a lightning-fast local "
"development environment named [Katana](./toolchain/katana/overview.md). "
"Katana serves as an on-device Starknet blockchain, allowing you to "
"rigorously test your smart contracts before transitioning them to the a "
"remote testnet."
msgstr ""
"Dojo는 빠른 개발을 위해 설계되었으며, [Katana](./toolchain/katana/overview."
"md)라는 초고속 로컬 개발 환경을 지원합니다. Katana는 온디바이스 스타크넷 블록"
"체인의 역할을 하며, 스마트 컨트랙트를 테스트넷으로 배포하기 전에 Katana에서 "
"테스트할 수 있습니다."

#: src/deployment/locally.md:5
#, fuzzy
msgid "Katana Deployments"
msgstr "### Katana 배포하기"

#: src/deployment/locally.md:7
msgid "Deploying to Katana could not be easier."
msgstr "Katana에 배포하는 것은 정말 간단합니다."

#: src/deployment/locally.md:9
#, fuzzy
msgid ""
"This assumes you have followed the [Quick Start](./getting-started/quick-"
"start.md) guide and have a project initialized."
msgstr ""
"> [빠른 시작](./getting-started/quick-start.md) 가이드를 따랐고 기본 프로젝트"
"가 이미 설정 되어 있다고 가정합니다."

#: src/deployment/locally.md:11
msgid "From your project directory, run:"
msgstr "프로젝트 디렉토리에서 실행합니다:"

#: src/deployment/locally.md:17
msgid "This has started a local Katana which you can now deploy on!"
msgstr "이제 로컬 Katana를 시작하여 배포할 수 있습니다!"

#: src/deployment/locally.md:19
#, fuzzy
msgid "Deploying to Katana"
msgstr "### Katana에 배포하기"

#: src/deployment/locally.md:21
msgid "To deploy your project to Katana, run:"
msgstr "프로젝트를 Katana에 배포하려면 실행하세요:"

#: src/deployment/locally.md:27
msgid ""
"Note - this will only work if you have compiled your contracts. If you have "
"not, run:"
msgstr ""
"참고 - 이 방법은 컨트랙트를 이미 컴파일한 경우에만 작동합니다. 컴파일하지 않"
"았다면 다음을 실행하세요:"

#: src/deployment/remote.md:1
#, fuzzy
msgid "Deployment to Remote Network"
msgstr "## 원격 네트워크에 배포"

#: src/deployment/remote.md:3
#, fuzzy
msgid "_IMPORTANT: Dojo is unaudited. Use at your own risk._"
msgstr "> *중요: Dojo는 audit을 받지 않았습니다. 본인 책임하에 사용하세요.*"

#: src/deployment/remote.md:5
msgid ""
"Dojo makes it easy to deploy to remote networks, you just need to have a "
"valid account and network endpoint."
msgstr ""
"유효한 계정과 네트워크 엔드포인트만 있으면 Dojo를 사용하여 원격 네트워크에 쉽"
"게 배포할 수 있습니다."

#: src/deployment/remote.md:7
msgid "Scarb.toml"
msgstr "Scarb.toml"

#: src/deployment/remote.md:9
msgid ""
"```toml\n"
"[package]\n"
"name = \"ohayoo\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.1.1\"\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = \"https://github.com/dojoengine/dojo.git\" }\n"
"\n"
"# # Katana\n"
"# rpc_url = \"http://localhost:5050\"\n"
"# account_address = "
"\"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\"\n"
"# private_key = "
"\"0x0300001800000000300000180000000000030000000000003006001800006600\"\n"
"\n"
"#Madara\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"#world_address = "
"\"0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201\"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = “ohayoo”\n"
"version = “0.1.0”\n"
"cairo-version = “2.1.1”\n"
"\n"
"[cairo]\n"
"sierra-replace-ids = true\n"
"\n"
"[dependencies]\n"
"dojo = { git = “https://github.com/dojoengine/dojo.git” }\n"
"\n"
"# # Katana\n"
"# rpc_url = “http://localhost:5050”\n"
"# account_address = "
"“0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0”\n"
"# private_key = "
"“0x0300001800000000300000180000000000030000000000003006001800006600”\n"
"\n"
"#Madara\n"
"rpc_url = “https://api.cartridge.gg/x/shinai/madara”\n"
"account_address = “0x2”\n"
"private_key = "
"“0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d”\n"
"#world_address = "
"“0x5b328933afdbbfd44901fd69a2764a254edbb6e992ae87cf958c70493f2d201”\n"
"```"

#: src/deployment/remote.md:33
#, fuzzy
msgid "Remote Katana"
msgstr "### 원격 Katana"

#: src/deployment/remote.md:35
msgid ""
"Katanas are able to be hosted and run as remote testnets, however this is "
"not recommended for production use."
msgstr ""
"Katana는 원격 테스트넷으로 호스팅하고 실행할 수 있지만 프로덕션 사용에는 권장"
"되지 않습니다."

#: src/deployment/remote.md:37
#, fuzzy
msgid "**todo**: add instructions for deploying to remote katana"
msgstr "__todo__: 원격 Katana에 배포하기 위한 가이드 추가"

#: src/deployment/remote.md:40
#, fuzzy
msgid "Madara"
msgstr "### Madara "

#: src/deployment/remote.md:42
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a blazinly fast "
"Starknet sequencer. Built on the robust Substrate framework and fast, thanks "
"to Rust 🦀, Madara delivers unmatched performance and scalability to power "
"your Starknet-based Validity Rollup chain."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara)는 엄청나게 빠른 스"
"타크넷 시퀀서입니다. 견고한 Substrate 프레임워크에 구축되었으며, Rust 🦀 덕분"
"에 빠른 속도를 자랑하는 Madara는 스타크넷 기반 유효성 롤업 체인을 구동할 수 "
"있는 탁월한 성능과 확장성을 제공합니다."

#: src/deployment/remote.md:44
msgid "A public Madara testnet is available for deployment:"
msgstr "퍼블릭 Madara 테스트넷이 개발용으로 이용가능합니다:"

#: src/deployment/remote.md:46
msgid "**Testnet RPC:** https://api.cartridge.gg/x/shinai/madara"
msgstr "**테스트넷 RPC:** https://api.cartridge.gg/x/shinai/madara"

#: src/deployment/remote.md:48
msgid "You can use the following account to deploy:"
msgstr "다음 계정을 사용하여 배포할 수 있습니다:"

#: src/deployment/remote.md:50
msgid ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"
msgstr ""
"```toml\n"
"# ...rest of Scarb.toml\n"
"\n"
"rpc_url = \"https://api.cartridge.gg/x/shinai/madara\"\n"
"account_address = \"0x2\"\n"
"private_key = "
"\"0xc1cf1490de1352865301bb8705143f3ef938f97fdf892f1090dcb5ac7bcd1d\"\n"
"```"

#: src/deployment/remote.md:59
#, fuzzy
msgid "Starknet"
msgstr "### Starknet "

#: src/deployment/remote.md:61
#, fuzzy
msgid "**todo**: add instructions for deploying to remote Starknet"
msgstr "__todo__: 원격 스타크넷에 배포하기 위한 가이드 추가"

#: src/tutorial/onchain-chess/index.md:1
#, fuzzy
msgid "Building a Chess Game"
msgstr "# 체스 게임 만들기"

#: src/tutorial/onchain-chess/index.md:3
msgid "_\"I just finished reading The Dojo Book. What should I do next?\"_"
msgstr "_”방금 Dojo 책을 다 읽었습니다. 다음에는 무엇을 해야 하나요?\"_"

#: src/tutorial/onchain-chess/index.md:5
msgid ""
"The answers to this question are always \"Make something!\", sometimes "
"followed by a list of cool projects. This is a great answer for some people, "
"but others might be looking for a little more direction."
msgstr ""
"이 질문에 대한 답은 항상 \"무언가를 만들어보세요!\"이며, 때로는 멋진 프로젝"
"트 목록이 뒤따릅니다. 이는 어떤 사람들에게는 훌륭한 대답이지만, 어떤 사람들"
"은 좀 더 구체적인 방향을 제공받길 원합니다."

#: src/tutorial/onchain-chess/index.md:7
msgid ""
"This guide is intended to fill the gap between heavily directed beginner "
"tutorials and working on your projects. The primary goal here is to get you "
"to write code. The secondary goal is to get you reading documentation."
msgstr ""
"이 가이드는 초보자 튜토리얼과 실제 프로젝트 사이의 간극을 메우기 위한 것입니"
"다. 이 가이드의 주요 목표는 코드를 작성하도록 돕는 것입니다. 두 번째 목표는 "
"문서를 다시 읽도록 하는 것입니다."

#: src/tutorial/onchain-chess/index.md:9
msgid ""
"If you haven't read the Dojo Book yet, it is highly encouraged for you to do "
"so before starting this project."
msgstr ""
"아직 Dojo 문서를 읽지 않으셨다면 이 프로젝트를 시작하기 전에 읽어보시기를 적"
"극 권장합니다."

#: src/tutorial/onchain-chess/index.md:11
#, fuzzy
msgid "What are we building?"
msgstr "## 무엇을 만들게 되나요?"

#: src/tutorial/onchain-chess/index.md:13
msgid ""
"We're building an on-chain chess game contract that lets you start a new "
"game and play chess. This guide does not cover every rules of the chess "
"game. You will build step by step as follows:"
msgstr ""
"저희는 새로운 게임을 시작하고 체스를 플레이할 수 있는 온체인 체스 게임 컨트랙"
"트를 만들어 보려 합니다. 이 가이드는 체스 게임의 모든 규칙을 다루지는 않습니"
"다. 다음과 같이 단계별로 구축할 것입니다:"

#: src/tutorial/onchain-chess/index.md:15
msgid "A system to spawn all the chess pieces"
msgstr ""

#: src/tutorial/onchain-chess/index.md:16
msgid "A system to make pieces move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:17
msgid "Add some functions to check a legal move"
msgstr ""

#: src/tutorial/onchain-chess/index.md:18
msgid "Play chess ♟♙ - integration test!"
msgstr ""

#: src/tutorial/onchain-chess/index.md:20
msgid ""
"The full code of tutorial is based on [this repo](https://github.com/"
"rkdud007/chess-dojo/tree/tutorialv2)."
msgstr ""
"튜토리얼의 전체 코드는 [이 리포지토리](https://github.com/rkdud007/chess-"
"dojo/tree/tutorialv2)를 기반으로 합니다."

#: src/tutorial/onchain-chess/index.md:22
msgid ""
"If this seems too hard, don't worry! This guide is for beginners. If you "
"know some basics about Cairo and Dojo, you're good. We won't make a full "
"chess game with all the rules. We're keeping it simple."
msgstr ""
"너무 어렵게 느껴지더라도 걱정하지 마세요! 이 가이드는 초보자를 위한 가이드입"
"니다. Cairo와 Dojo에 대한 기본 지식만 알고 있다면 괜찮습니다. 모든 규칙이 포"
"함된 완전한 체스 게임이 아니라 간단한 설명을 바탕으로 간단하게 완성하는 프로"
"젝트 입니다."

#: src/tutorial/onchain-chess/index.md:24
#, fuzzy
msgid "What after this guide?"
msgstr "## 이 가이드 이후에는 어떻게 하나요?"

#: src/tutorial/onchain-chess/index.md:26
msgid ""
"We're making another guide to help design the frontend. This will make our "
"chess game complete."
msgstr ""
"프론트엔드 연결을 돕기 위해 또 다른 가이드를 만들고 있습니다. 이렇게 하면 완"
"전한 체스 게임이 완성됩니다."

#: src/tutorial/onchain-chess/index.md:28
msgid ""
"After you finish all the five chapters, we can move on to the frontend guide."
msgstr ""
"5개의 챕터를 모두 완료한 후에는 프론트엔드 가이드로 넘어갈 수 있습니다."

#: src/tutorial/onchain-chess/0-setup.md:3
msgid ""
"_Before starting recommend following the [`hello-dojo`](../../cairo/hello-"
"dojo.md) chapter to gain a basic understanding of the Dojo game._"
msgstr ""
"_시작하기 전에 [`헬로 Dojo`](../../cairo/hello-dojo.md) 챕터에서 Dojo 게임에 "
"대한 기본적인 이해를 돕는 것을 추천합니다_"

#: src/tutorial/onchain-chess/0-setup.md:5
#, fuzzy
msgid "Initializing the Project"
msgstr "## 프로젝트 초기화하기"

#: src/tutorial/onchain-chess/0-setup.md:7
msgid ""
"Create a new Dojo project folder. You can name your project what you want."
msgstr ""
"새 Dojo 프로젝트 폴더를 만듭니다. 프로젝트 이름은 원하는 대로 지을 수 있습니"
"다."

#: src/tutorial/onchain-chess/0-setup.md:13
msgid "Open the project folder."
msgstr "프로젝트 폴더를 엽니다."

#: src/tutorial/onchain-chess/0-setup.md:19
msgid "And initialize the project using sozo init."
msgstr "그리고 sozo init을 사용하여 프로젝트를 초기화합니다."

#: src/tutorial/onchain-chess/0-setup.md:25
#, fuzzy
msgid "Cleaning Up the Boilerplate"
msgstr "## 기본 템플릿 정리하기"

#: src/tutorial/onchain-chess/0-setup.md:27
msgid ""
"The project comes with a lot of boilerplate codes. Clear it all. Make sure "
"both `components.cairo` and `systems.cairo` files are empty."
msgstr ""
"이 프로젝트에는 많은 기본 템플릿 코드가 포함되어 있습니다. 프로젝트에서 필요"
"하지 않습니다, 모두 지우세요. `components.cairo`와 `systems.cairo` 파일이 모"
"두 비어 있는지 확인합니다."

#: src/tutorial/onchain-chess/0-setup.md:29
msgid "In `lib.cairo`, retain only:"
msgstr "`lib.cairo`에서는 다음의 코드만 유지 합니다:"

#: src/tutorial/onchain-chess/0-setup.md:36
msgid "Compile your project with:"
msgstr "프로젝트를 컴파일합니다:"

#: src/tutorial/onchain-chess/0-setup.md:42
#, fuzzy
msgid "Basic components"
msgstr "## 기본 컴포넌트(Components)"

#: src/tutorial/onchain-chess/0-setup.md:44
msgid ""
"While there are many ways to design a chess game using the ECS model, we'll "
"follow this approach:"
msgstr ""
"ECS 모델을 사용하여 체스 게임을 디자인하는 방법은 여러 가지가 있지만, 여기서"
"는 이 접근 방식을 따르겠습니다:"

#: src/tutorial/onchain-chess/0-setup.md:46
#, fuzzy
msgid ""
"Every square of the chess board (e.g., A1) will be treated as an entity. If "
"a piece exists on a square, the square entity will hold that piece."
msgstr ""
"> 체스판의 모든 사각형(예: A1)은 엔티티로 취급됩니다. 사각형에 말이 존재하면 "
"사각형 엔티티가 해당 말을 보유합니다."

#: src/tutorial/onchain-chess/0-setup.md:48
msgid ""
"First, add this basic component to `components.cairo` file. If you are not "
"familar with component syntax in Dojo engine, go back to this [chapter]"
"(../../cairo/components.md)."
msgstr ""
"먼저 이 기본 컴포넌트를 `components.cairo` 파일에 추가합니다. Dojo 엔진의 컴"
"포넌트 구문에 익숙하지 않다면 이 [챕터](../../cairo/components.md)로 돌아가세"
"요."

#: src/tutorial/onchain-chess/0-setup.md:78
#, fuzzy
msgid "Basic systems"
msgstr "## 기본 시스템(systems)"

#: src/tutorial/onchain-chess/0-setup.md:80
msgid ""
"Starting from the next chapter, you will implement `initiate` and `move` "
"systems one in each chapter. Let's create each system in its own file for "
"better modularity."
msgstr ""
"다음 챕터부터는 각 챕터에서 `initiate`과 `move` 시스템을 하나씩 구현할 것입니"
"다. 모듈성을 높이기 위해 각 시스템을 자체 파일로 만들어 보겠습니다."

#: src/tutorial/onchain-chess/0-setup.md:82
msgid ""
"Create a `systems` folder at `src`. Create `initiate.cairo`and `move.cairo` "
"two files inside the folder. Each file should contain a basic system "
"structure."
msgstr ""
"`src`에 `systems` 폴더를 생성합니다. 폴더 안에 `initiate.cairo`와 `move."
"cairo` 두 개의 파일을 생성합니다. 각 파일에는 기본적인 시스템 구조가 포함되어"
"야 합니다."

#: src/tutorial/onchain-chess/0-setup.md:84
msgid "For example, `initiate.cairo` look like this:"
msgstr "예를 들어 `initiate.cairo`는 다음과 같습니다:"

#: src/tutorial/onchain-chess/0-setup.md:93
msgid "and in `systems.cairo` we will use `initiate_system` like this:"
msgstr "`systems.cairo`에서는 `initiate_system`을 다음과 같이 사용합니다:"

#: src/tutorial/onchain-chess/0-setup.md:101
msgid "Do the same with the other systems. Update `systems.cairo` to:"
msgstr ""
"다른 시스템에서도 동일하게 수행합니다. `systems.cairo`를 다음과 같이 업데이트"
"합니다:"

#: src/tutorial/onchain-chess/0-setup.md:111
#, fuzzy
msgid "Compile your project"
msgstr "## 프로젝트 컴파일하기"

#: src/tutorial/onchain-chess/0-setup.md:113
msgid "Now try `sozo build` to build. Faced some errors?"
msgstr "이제 빌드하려면 `sozo build`를 시도하십시오. 오류가 발생했나요?"

#: src/tutorial/onchain-chess/0-setup.md:119
msgid ""
"You would probably faced some trait implementation errors, which you can "
"implement as a derive like:"
msgstr ""
"아마도 몇 가지 특성 구현 오류를 만났을 것입니다. 이는 다음과 같이 derive로 구"
"현할 수 있습니다:"

#: src/tutorial/onchain-chess/0-setup.md:151
msgid "Great! then let's solve this error."
msgstr "좋습니다! 그럼 이 오류를 해결해 보겠습니다."

#: src/tutorial/onchain-chess/0-setup.md:160
msgid ""
"One thing you have to make sure is, that `<Option<PieceType>>` is the type "
"that we created. So this type does not implement basic traits like SerdeLen. "
"You need to define the implementation by your own."
msgstr ""
"`<Option<PieceType>>`은 우리가 만든 타입입니다. 따라서 이 타입은 SerdeLen과 "
"같은 기본 특성을 가지지 않습니다. 여러분이 직접 정의해야 합니다."

#: src/tutorial/onchain-chess/0-setup.md:171
msgid ""
"Fix other issues as above, so that you can run the `sozo build` command runs "
"successfully."
msgstr ""
"위와 같이 다른 문제를 수정하여 `sozo build` 명령이 성공적으로 실행될 수 있도"
"록 합니다."

#: src/tutorial/onchain-chess/0-setup.md:173
#, fuzzy
msgid "Run test"
msgstr "## 테스트 실행"

#: src/tutorial/onchain-chess/0-setup.md:175
msgid ""
"Before proceeding to the next chapter, remember that `sozo build` and `sozo "
"test` are important steps to ensure your code is correct."
msgstr ""
"다음 챕터로 넘어가기 전에 `sozo build`와 `sozo test`는 코드가 올바른지 확인하"
"는 중요한 단계라는 점을 기억하세요."

#: src/tutorial/onchain-chess/0-setup.md:177
msgid "Run sozo test. Did you face any errors?"
msgstr "sozo test를 실행합니다. 오류가 발생했나요?"

#: src/tutorial/onchain-chess/0-setup.md:187
msgid ""
"For the no implementation error, implement the PrintTrait to run sozo test "
"successfully. For the not dropped error, add the Drop trait. Address other "
"errors by adding derives or implementing them on a case-by-case basis."
msgstr ""
"no implementation 에러의 경우 PrintTrait을 구현하여 sozo test를 성공적으로 실"
"행합니다. not dropped 에러의 경우 Drop 특성을 추가합니다. 다른 오류는 파생 요"
"소를 추가하거나 직접 구현하여 해결합니다."

#: src/tutorial/onchain-chess/0-setup.md:189
#, fuzzy
msgid "Add more components"
msgstr "## 더 많은 컴포넌트 추가하기"

#: src/tutorial/onchain-chess/0-setup.md:191
msgid ""
"Before you move on, add more components so we can use them in the next "
"chapter when creating systems."
msgstr ""
"계속 진행하기 전에 다음 장에서 시스템을 만들 때 사용할 수 있도록 더 많은 컴포"
"넌트를 추가하세요."

#: src/tutorial/onchain-chess/0-setup.md:193
#: src/tutorial/onchain-chess/1-initiate.md:12
#: src/tutorial/onchain-chess/2-move.md:9
#, fuzzy
msgid "Requirements"
msgstr "## 요구 사항"

#: src/tutorial/onchain-chess/0-setup.md:195
#, fuzzy
msgid "`Color` enum enum with values White and Black"
msgstr ""
"- 값이 흰색과 검은색인 `Color` enum\n"
"- `Game` 컴포넌트:"

#: src/tutorial/onchain-chess/0-setup.md:196
#, fuzzy
msgid "`Game` component:"
msgstr "- `GameTurn` 컴포넌트:"

#: src/tutorial/onchain-chess/0-setup.md:205
#, fuzzy
msgid "`GameTurn` component:"
msgstr "- `GameTurn` 컴포넌트:"

#: src/tutorial/onchain-chess/0-setup.md:212
#, fuzzy
msgid ""
"We will later set game entity composed of the `Game` and `GameTurn` "
"components."
msgstr ""
"- `Game`과 `GameTurn` 컴포넌트로 구성된 게임 엔티티를 설정합니다.\n"
"- `sozo build`와 `sozo test`를 실행하고 모든 테스트가 통과했는지 확인합니다."

#: src/tutorial/onchain-chess/0-setup.md:213
msgid "Run `sozo build` and `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/0-setup.md:215
msgid ""
"Try to solve on your own, and before you move on check the answer below."
msgstr "스스로 도전해보고, 다음 장으로 넘어가기 전에 아래의 답을 확인하세요."

#: src/tutorial/onchain-chess/0-setup.md:220
msgid ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                'BlackBishop'.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                'BlackRook'.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                'BlackQueen'.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                'BlackKing'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust,ignore\n"
"use debug::PrintTrait;\n"
"use starknet::ContractAddress;\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Square {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    #[key]\n"
"    x: u32,\n"
"    #[key]\n"
"    y: u32,\n"
"    piece: Option<PieceType>,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum PieceType {\n"
"    WhitePawn,\n"
"    WhiteKnight,\n"
"    WhiteBishop,\n"
"    WhiteRook,\n"
"    WhiteQueen,\n"
"    WhiteKing,\n"
"    BlackPawn,\n"
"    BlackKnight,\n"
"    BlackBishop,\n"
"    BlackRook,\n"
"    BlackQueen,\n"
"    BlackKing,\n"
"}\n"
"\n"
"#[derive(Serde, Drop, Copy, PartialEq)]\n"
"enum Color {\n"
"    White,\n"
"    Black,\n"
"}\n"
"\n"
"\n"
"impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        2\n"
"    }\n"
"}\n"
"\n"
"impl ColorPrintTrait of PrintTrait<Color> {\n"
"    #[inline(always)]\n"
"    fn print(self: Color) {\n"
"        match self {\n"
"            Color::White(_) => {\n"
"                'White'.print();\n"
"            },\n"
"            Color::Black(_) => {\n"
"                'Black'.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorOptionPrintTrait of PrintTrait<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<Color>) {\n"
"        match self {\n"
"            Option::Some(color) => {\n"
"                color.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl BoardPrintTrait of PrintTrait<(u32, u32)> {\n"
"    #[inline(always)]\n"
"    fn print(self: (u32, u32)) {\n"
"        let (x, y): (u32, u32) = self;\n"
"        x.print();\n"
"        y.print();\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypeOptionPrintTrait of PrintTrait<Option<PieceType>> {\n"
"    #[inline(always)]\n"
"    fn print(self: Option<PieceType>) {\n"
"        match self {\n"
"            Option::Some(piece_type) => {\n"
"                piece_type.print();\n"
"            },\n"
"            Option::None(_) => {\n"
"                'None'.print();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"\n"
"impl PieceTypePrintTrait of PrintTrait<PieceType> {\n"
"    #[inline(always)]\n"
"    fn print(self: PieceType) {\n"
"        match self {\n"
"            PieceType::WhitePawn(_) => {\n"
"                'WhitePawn'.print();\n"
"            },\n"
"            PieceType::WhiteKnight(_) => {\n"
"                'WhiteKnight'.print();\n"
"            },\n"
"            PieceType::WhiteBishop(_) => {\n"
"                'WhiteBishop'.print();\n"
"            },\n"
"            PieceType::WhiteRook(_) => {\n"
"                'WhiteRook'.print();\n"
"            },\n"
"            PieceType::WhiteQueen(_) => {\n"
"                'WhiteQueen'.print();\n"
"            },\n"
"            PieceType::WhiteKing(_) => {\n"
"                'WhiteKing'.print();\n"
"            },\n"
"            PieceType::BlackPawn(_) => {\n"
"                'BlackPawn'.print();\n"
"            },\n"
"            PieceType::BlackKnight(_) => {\n"
"                'BlackKnight'.print();\n"
"            },\n"
"            PieceType::BlackBishop(_) => {\n"
"                ‘BlackBishop’.print();\n"
"            },\n"
"            PieceType::BlackRook(_) => {\n"
"                ‘BlackRook’.print();\n"
"            },\n"
"            PieceType::BlackQueen(_) => {\n"
"                ‘BlackQueen’.print();\n"
"            },\n"
"            PieceType::BlackKing(_) => {\n"
"                ‘BlackKing’.print();\n"
"            },\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"impl ColorSerdeLen of dojo::SerdeLen<Color> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct Game {\n"
"    /// game id, computed as follows pedersen_hash(player1_address, "
"player2_address)\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    winner: Option<Color>,\n"
"    white: ContractAddress,\n"
"    black: ContractAddress\n"
"}\n"
"\n"
"\n"
"#[derive(Component, Drop, SerdeLen, Serde)]\n"
"struct GameTurn {\n"
"    #[key]\n"
"    game_id: felt252,\n"
"    turn: Color,\n"
"}\n"
"\n"
"impl OptionPieceColorSerdeLen of dojo::SerdeLen<Option<Color>> {\n"
"    #[inline(always)]\n"
"    fn len() -> usize {\n"
"        1\n"
"    }\n"
"}\n"
"\n"
"```"

#: src/tutorial/onchain-chess/0-setup.md:399
msgid ""
"Congratulations! You've completed the basic setup for building an on-chain "
"chess game 🎉"
msgstr ""
"축하합니다! 온체인 체스 게임을 구축하기 위한 기본 설정을 완료하셨습니다 🎉"

#: src/tutorial/onchain-chess/1-initiate.md:1
#, fuzzy
msgid "1. Initiate System"
msgstr "# 1. 시작 시스템"

#: src/tutorial/onchain-chess/1-initiate.md:3
msgid ""
"This chapter will address implementing `initiate_system`, which spawns the "
"game and squares containing pieces."
msgstr ""
"이 장에서는 게임과 기물이 들어있는 보드 사각을 생성하는 `initiate_system`을 "
"구현하는 방법을 다룹니다."

#: src/tutorial/onchain-chess/1-initiate.md:5
#, fuzzy
msgid "What is `initiate_system`?"
msgstr "## `initiate_system`이란 무엇인가요?"

#: src/tutorial/onchain-chess/1-initiate.md:7
msgid ""
"To play chess, you need to start the game and spawn the pieces. "
"`initiate_system` will spawn the game entity and then place each piece in "
"its proper position. Ensure the game status matches the correct piece type, "
"and the right piece color is in its designated position on the board."
msgstr ""
"체스를 플레이하려면 게임을 시작하고 말들을 스폰해야 합니다. `initiate_system`"
"은 게임 엔티티를 스폰한 다음 각 말을 적절한 위치에 배치합니다. 게임 상태가 올"
"바른 말 종류와 일치하는지, 올바른 말 색상이 보드의 지정된 위치에 있는지 확인"
"합니다."

#: src/tutorial/onchain-chess/1-initiate.md:14
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"initiate.cairo` file._"
msgstr ""
"아래의 단위 테스트를 복사하여 `systems/initiate.cairo` 파일 하단에 붙여넣습니"
"다"

#: src/tutorial/onchain-chess/1-initiate.md:16
#, fuzzy
msgid ""
"Write an `execute` function in the system that accepts the world context, "
"white address, and black address as input."
msgstr "1. 시스템에서 `execute` 함수를 작성하고 다음을 인풋값으로 부여합니다:"

#: src/tutorial/onchain-chess/1-initiate.md:17
#, fuzzy
msgid ""
"Implement the game entity, comprised of the `Game` component and `GameTurn` "
"component we created in the previous step."
msgstr ""
"- `Game`과 `GameTurn` 컴포넌트로 구성된 게임 엔티티를 설정합니다.\n"
"- `sozo build`와 `sozo test`를 실행하고 모든 테스트가 통과했는지 확인합니다."

#: src/tutorial/onchain-chess/1-initiate.md:18
msgid ""
"Implement square entities by `Square` component, from a1 to h8 containing "
"the correct `PieceType`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:19
msgid "Run `sozo test` and pass all the tests."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:21
#: src/tutorial/onchain-chess/2-move.md:29
#, fuzzy
msgid "Test Flow"
msgstr "## 테스트 흐름"

#: src/tutorial/onchain-chess/1-initiate.md:23
msgid ""
"Spawn the test world that imports the components and systems used in testing."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:24
msgid ""
"Execute `initiate_system` by providing white and black player's wallet "
"addresses as inputs."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:25
msgid ""
"Retrieve the game entity and piece entity created during `initiate_system`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:26
msgid "Ensure the game has been correctly created."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:27
msgid "Verify that each `Piece` is located in the correct `Square`."
msgstr ""

#: src/tutorial/onchain-chess/1-initiate.md:29
#: src/tutorial/onchain-chess/2-move.md:35
#, fuzzy
msgid "Unit Tests"
msgstr "### 유닛 테스트 작성하기"

#: src/tutorial/onchain-chess/1-initiate.md:31
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_initiate() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //get game\n"
"        let game = get!(world, (game_id), (Game));\n"
"        assert(game.white == white, 'white address is incorrect');\n"
"        assert(game.black == black, 'black address is incorrect');\n"
"\n"
"        //get a1 square\n"
"        let a1 = get!(world, (game_id, 0, 0), (Square));\n"
"        match a1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteRook, 'should be White "
"Rook');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/1-initiate.md:85
#: src/tutorial/onchain-chess/2-move.md:108
#: src/tutorial/onchain-chess/3-legal.md:165
#, fuzzy
msgid "Need help?"
msgstr "## 도움이 필요하세요?"

#: src/tutorial/onchain-chess/1-initiate.md:87
#: src/tutorial/onchain-chess/2-move.md:110
#: src/tutorial/onchain-chess/3-legal.md:167
msgid ""
"If you're stuck, don't hesitate to ask questions at the [Dojo community]"
"(https://discord.gg/akd2yfuRS3)!"
msgstr ""
"막히는 부분이 있으면 [Dojo 커뮤니티](https://discord.gg/akd2yfuRS3)에서 주저"
"하지 말고 질문하세요!"

#: src/tutorial/onchain-chess/1-initiate.md:89
msgid ""
"You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
"tutorialv2/src/systems/initiate.cairo) for chapter 1 here."
msgstr ""
"1장에 대한 [정답](https://github.com/rkdud007/chess-dojo/blob/tutorialv2/src/"
"systems/initiate.cairo)은 여기에서 확인할 수 있습니다."

#: src/tutorial/onchain-chess/2-move.md:1
#, fuzzy
msgid "2. Move System"
msgstr "# 2. 이동 시스템"

#: src/tutorial/onchain-chess/2-move.md:3
msgid ""
"This chapter will address the implementation of `move_system`, which "
"relocates a piece on the board."
msgstr ""
"이 장에서는 보드에서 말을 이동시키는 `move_system`의 구현에 대해 설명합니다."

#: src/tutorial/onchain-chess/2-move.md:5
#, fuzzy
msgid "What is `move_system`?"
msgstr "## `move_system`이란 무엇인가요?"

#: src/tutorial/onchain-chess/2-move.md:7
msgid ""
"To play chess, one must move the pieces on the board. Since we represent "
"piece locations with a Square entity, the `move_system` retrieves the "
"current position as (x,y). It also fetches the next position as (x,y), "
"treating the piece in the current position square as the target to be moved "
"to the next position."
msgstr ""
"체스를 두려면 체스판의 말들을 움직여야 합니다. 말의 위치를 정사각형 엔티티로 "
"표현하기 때문에 `move_system`은 현재 위치를 (x,y)로 검색합니다. 또한 다음 위"
"치를 (x,y)로 가져와 현재 위치 정사각형에 있는 말을 다음 위치로 이동해야 할 대"
"상으로 취급합니다."

#: src/tutorial/onchain-chess/2-move.md:11
msgid ""
"_Copy the unit tests below and paste them at the bottom of your `systems/"
"move.cairo` file._"
msgstr ""
"_아래의 단위 테스트를 복사하여 `systems/move.cairo` 파일 하단에 붙여넣습니다_"

#: src/tutorial/onchain-chess/2-move.md:13
#, fuzzy
msgid "Write an `execute` function in the system with the following inputs:"
msgstr "1. 시스템에서 `execute` 함수를 작성하고 다음을 인풋값으로 부여합니다:"

#: src/tutorial/onchain-chess/2-move.md:25
#, fuzzy
msgid ""
"Update the Square with the `next_position` to contain the new piece and "
"ensure the Square with the `curr_position` no longer holds a piece."
msgstr ""
"2. `next_position`이 있는 정사각형을 새 조각을 포함하도록 업데이트하고 "
"`curr_position`이 있는 정사각형에 더 이상 조각이 들어 있지 않은지 확인합니"
"다.\n"
"\n"
"3. `sozo test`를 실행하고 모든 테스트가 통과되었는지 확인합니다."

#: src/tutorial/onchain-chess/2-move.md:27
msgid "Run `sozo test` and ensure all tests pass."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:31
msgid "Follow the same logic as `test_initiate` from the previous chapter."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:32
msgid "Move the White Knight from (1,0) to (2,2) using the `move_system`."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:33
msgid ""
"Retrieve the updated position and verify that the piece has successfully "
"moved to its new location."
msgstr ""

#: src/tutorial/onchain-chess/2-move.md:37
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"         //White Knight is in (1,0)\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (1,0)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,0)'),\n"
"        };\n"
"\n"
"        // Move White Knight (1,0) -> (2,2)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White Knight is in (2,2)\n"
"        let c3 = get!(world, (game_id, 2, 2), (Square));\n"
"        match c3.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight in (2,2)');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (2,2)'),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:3
msgid "In this chapter, we'll make functions to check:"
msgstr "이 장에서는 확인할 함수를 만들어 보겠습니다:"

#: src/tutorial/onchain-chess/3-legal.md:5
#, fuzzy
msgid "If the next move goes outside the board."
msgstr "2. 다음 위치가 보드위에 있는지 확인합니다."

#: src/tutorial/onchain-chess/3-legal.md:6
msgid "If there's a piece that can be captured."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:7
#, fuzzy
msgid "If the next move is allowed for the type of piece."
msgstr "1. 이동하는 기물의 유형이 다음 위치를 허용하는지 확인합니다."

#: src/tutorial/onchain-chess/3-legal.md:8
msgid "If the user can allow to make a action (based on the piece's color)."
msgstr ""

#: src/tutorial/onchain-chess/3-legal.md:9
#, fuzzy
msgid "... You can also add other custom check functions."
msgstr ""
"4. 다른 체크 기능을 추가하여 이동이 허용되는지 추가로 확인할 수도 있습니다."

#: src/tutorial/onchain-chess/3-legal.md:11
#, fuzzy
msgid "Make Check Functions"
msgstr "## 체크 함수 만들기"

#: src/tutorial/onchain-chess/3-legal.md:13
msgid ""
"We need to add some check functions in `move_system`. These will help make "
"sure the next move is allowed."
msgstr ""
"`move_system`에 몇 가지 체크 함수를 추가해야 합니다. 이는 다음 수가 허용되는"
"지 확인하는 데 도움이 됩니다."

#: src/tutorial/onchain-chess/3-legal.md:15
#, fuzzy
msgid "See if the next spot is allowed for the type of piece moving."
msgstr "1. 이동하는 기물의 유형이 다음 위치를 허용하는지 확인합니다."

#: src/tutorial/onchain-chess/3-legal.md:23
#, fuzzy
msgid "See if the next spot is still on the board."
msgstr "2. 다음 위치가 보드위에 있는지 확인합니다."

#: src/tutorial/onchain-chess/3-legal.md:29
#, fuzzy
msgid ""
"See if the person trying the move is doing it at the right time and with "
"their piece color."
msgstr ""
"3. 수를 시도하는 사람이 적절한 타이밍에 적절한 색상으로 움직이고 있는지 확인"
"합니다."

#: src/tutorial/onchain-chess/3-legal.md:35
#, fuzzy
msgid ""
"You can also add other check functions to be extra sure the move is allowed."
msgstr ""
"4. 다른 체크 기능을 추가하여 이동이 허용되는지 추가로 확인할 수도 있습니다."

#: src/tutorial/onchain-chess/3-legal.md:37
msgid ""
"Once you've made these check functions, you can use them in the main "
"`move_system` function. You can decide how to set them up and which ones to "
"use. We'll give an example to help:"
msgstr ""
"이러한 검사 함수를 만들었으면 기본 `move_system` 함수에서 사용할 수 있습니"
"다. 함수를 설정하는 방법과 사용할 함수를 결정할 수 있습니다. 도움이 되도록 예"
"제를 제공하겠습니다:"

#: src/tutorial/onchain-chess/3-legal.md:39
msgid ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //... upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), 'Should be inside board');\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            'Should be right piece move'\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array!['Already same color piece exist'])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // ... below code is the same\n"
"\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    fn execute(\n"
"        ctx: Context,\n"
"        curr_position: (u32, u32),\n"
"        next_position: (u32, u32),\n"
"        caller: ContractAddress,\n"
"        game_id: felt252\n"
"    ) {\n"
"        //… upper code is the same\n"
"        //Check if next_position is out of board or not\n"
"        assert(is_out_of_board(next_position), ‘Should be inside board’);\n"
"\n"
"        //Check if this is the right piece type move\n"
"\n"
"        assert(\n"
"            is_right_piece_move(current_square.piece, curr_position, "
"next_position),\n"
"            ‘Should be right piece move’\n"
"        );\n"
"\n"
"        let target_piece = current_square.piece;\n"
"\n"
"        // make current_square piece none and move piece to next_square\n"
"        current_square.piece = Option::None(());\n"
"        let mut next_square = get!(ctx.world, (game_id, next_x, next_y), "
"(Square));\n"
"\n"
"        //Check the piece already in next_suqare\n"
"        let maybe_next_square_piece = next_square.piece;\n"
"        match maybe_next_square_piece {\n"
"            Option::Some(maybe_piece) => {\n"
"                if is_piece_is_mine(maybe_piece) {\n"
"                    panic(array![‘Already same color piece exist’])\n"
"                } else {\n"
"                    //Occupy the piece\n"
"                    next_square.piece = target_piece;\n"
"                }\n"
"            },\n"
"            //if not exist, then just move the original piece\n"
"            Option::None(_) => {\n"
"                next_square.piece = target_piece;\n"
"            },\n"
"        };\n"
"        // … below code is the same\n"
"\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:85
#, fuzzy
msgid "Testing Each Function"
msgstr "## 각 함수 테스트하기"

#: src/tutorial/onchain-chess/3-legal.md:87
msgid ""
"Since we have different check functions, we need to test each one. To make "
"this easier, let's use parts that are the same for many tests."
msgstr ""
"체크 함수들이 서로 다르기 때문에 각각을 테스트해야 합니다. 이 작업을 더 쉽게 "
"하기 위해 여러 테스트에 공통 함수를 만들어 사용하겠습니다."

#: src/tutorial/onchain-chess/3-legal.md:89
msgid ""
"First, make a helper function called `init_world_test`. This will give back "
"an `IWorldDispatcher` that we can use many times in the move system tests."
msgstr ""
"먼저 `init_world_test`라는 헬퍼 함수를 만듭니다. 이렇게 하면 이동 시스템 테스"
"트에서 여러 번 사용할 수 있는 `IWorldDispatcher`가 반환됩니다."

#: src/tutorial/onchain-chess/3-legal.md:91
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn init_world_test() -> IWorldDispatcher {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"        world\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:118
msgid "Then, our main `test_move` function will be simpler."
msgstr "그러면 기본 `test_move` 함수가 더 간단해집니다."

#: src/tutorial/onchain-chess/3-legal.md:120
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn test_move() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"        // other codes are same\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:132
msgid ""
"Now we can make tests that show errors if we try moves that aren't allowed. "
"Let's make a `test_piecetype_illegal` function. This will check if the "
"`is_right_piece_move` function, that you implemented in the move system, "
"works right."
msgstr ""
"이제 허용되지 않는 수를 시도하면 오류가 나도록 테스트를 만들 수 있습니다. "
"`test_piecetype_illegal` 함수를 만들어 봅시다. 이 함수는 이동 시스템에서 구현"
"한 `is_right_piece_move` 함수가 제대로 작동하는 지 확인합니다."

#: src/tutorial/onchain-chess/3-legal.md:134
msgid ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, 'should be White "
"Knight');\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece'),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"    }\n"
"```"
msgstr ""
"```rust,ignore\n"
"    #[test]\n"
"    #[should_panic]\n"
"    fn test_piecetype_ilegal() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"        let world = init_world_test();\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        let b1 = get!(world, (game_id, 1, 0), (Square));\n"
"        match b1.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhiteKnight, ‘should be White "
"Knight’);\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece’),\n"
"        };\n"
"\n"
"        // Knight cannot move to that square\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(2);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute(‘move_system’.into(), move_calldata);\n"
"    }\n"
"```"

#: src/tutorial/onchain-chess/3-legal.md:163
msgid ""
"Finish by making your tests. These should find wrong moves and give back "
"errors."
msgstr ""
"잘못된 기물 움직임을 찾아내고 오류를 반환하는 테스트를 작성하면서 마무리 해봅"
"시다."

#: src/tutorial/onchain-chess/4-test.md:1
#, fuzzy
msgid "4. Test Contract"
msgstr "# 4. 테스트 컨트랙트"

#: src/tutorial/onchain-chess/4-test.md:3
msgid ""
"In this chapter, we'll use everything we've learned to run a full chess game "
"scenario."
msgstr ""
"이 장에서는 지금까지 배운 모든 것을 사용하여 전체 체스 게임 시나리오를 실행"
"해 보겠습니다."

#: src/tutorial/onchain-chess/4-test.md:5
msgid "Here's what we'll do in our test:"
msgstr "테스트에서 수행할 작업은 다음과 같습니다:"

#: src/tutorial/onchain-chess/4-test.md:7
msgid "Spawn `white_pawn_1` to (0,1)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:8
msgid "Move `white_pawn_1` to (0,3)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:9
msgid "Move `black_pawn_2` to (1,6)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:10
msgid "Move `white_pawn_1` to (0,4)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:11
msgid "Move `black_pawn_2` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:12
msgid "Move `white_pawn_1` to (1,5)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:13
msgid "Capture `black_pawn_2`"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:15
msgid ""
"To place the pieces, use our `initiate_system`. For moving them, use the "
"`move_system`. Remember to check if a piece can be captured when using "
"`move_system`."
msgstr ""
"기물을 배치하려면 `initiate_system`을 사용합니다. 조각을 이동하려면 "
"`move_system`을 사용합니다.`move_system`을 사용할 때 다른 기물을 잡을 수 있는"
"지 확인하는 것을 잊지 마세요."

#: src/tutorial/onchain-chess/4-test.md:17
msgid "Before we get to the code, set up your integration test like this:"
msgstr "코드를 시작하기 전에 다음과 같이 통합 테스트를 설정합니다:"

#: src/tutorial/onchain-chess/4-test.md:19
#, fuzzy
msgid "Copy the test below and add it to your `src/tests.cairo` file."
msgstr ""
"_아래의 단위 테스트를 복사하여 `systems/move.cairo` 파일 하단에 붙여넣습니다_"

#: src/tutorial/onchain-chess/4-test.md:20
#, fuzzy
msgid ""
"Make a `test.cairo` in your src and update `lib.cairo` by adding the `mod "
"tests;` line."
msgstr ""
"- 아래 테스트를 복사하여 `src/tests.cairo` 파일에 추가합니다.\n"
"- src에 `test.cairo`를 생성하고 `mod tests;` 줄을 추가하여 `lib.cairo`를 업데"
"이트합니다."

#: src/tutorial/onchain-chess/4-test.md:22
#, fuzzy
msgid "Full Code"
msgstr "## 전체 코드"

#: src/tutorial/onchain-chess/4-test.md:24
msgid ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```rust,ignore\n"
"#[cfg(test)]\n"
"mod tests {\n"
"    use starknet::ContractAddress;\n"
"    use dojo::test_utils::spawn_test_world;\n"
"    use dojo_chess::components::{Game, game, GameTurn, game_turn, Square, "
"square, PieceType};\n"
"\n"
"    use dojo_chess::systems::initiate_system;\n"
"    use dojo_chess::systems::move_system;\n"
"    use array::ArrayTrait;\n"
"    use core::traits::Into;\n"
"    use dojo::world::IWorldDispatcherTrait;\n"
"    use core::array::SpanTrait;\n"
"\n"
"\n"
"    #[test]\n"
"    #[available_gas(3000000000000000)]\n"
"    fn integration() {\n"
"        let white = starknet::contract_address_const::<0x01>();\n"
"        let black = starknet::contract_address_const::<0x02>();\n"
"\n"
"        // components\n"
"        let mut components = array::ArrayTrait::new();\n"
"        components.append(game::TEST_CLASS_HASH);\n"
"        components.append(game_turn::TEST_CLASS_HASH);\n"
"        components.append(square::TEST_CLASS_HASH);\n"
"\n"
"        //systems\n"
"        let mut systems = array::ArrayTrait::new();\n"
"        systems.append(initiate_system::TEST_CLASS_HASH);\n"
"        systems.append(move_system::TEST_CLASS_HASH);\n"
"        let world = spawn_test_world(components, systems);\n"
"\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"\n"
"        let game_id = pedersen(white.into(), black.into());\n"
"\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"\n"
"        //Black pawn is now in (1,6)\n"
"        let b7 = get!(world, (game_id, 1, 6), (Square));\n"
"        match b7.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black Pawn "
"in (1,6)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,6)),\n"
"        };\n"
"\n"
"        //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //White pawn is now in (0,3)\n"
"        let a4 = get!(world, (game_id, 0, 3), (Square));\n"
"        match a4.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,3)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,3)),\n"
"        };\n"
"\n"
"        //Move black Pawn to (1,4)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(6);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(black.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        //Black pawn is now in (1,4)\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::BlackPawn, \"should be Black "
"Pawn  in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece  in (1,4)),\n"
"        };\n"
"\n"
"        // Move White Pawn to (1,4)\n"
"        // Capture black pawn\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(4);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"\n"
"        let b5 = get!(world, (game_id, 1, 4), (Square));\n"
"        match b5.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be WhitePawn  "
"in (1,4)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (1,4)),\n"
"        };\n"
"    }\n"
"}\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:143
#, fuzzy
msgid "Diving into the Code"
msgstr "## 코드 살펴보기"

#: src/tutorial/onchain-chess/4-test.md:145
msgid "First, we'll set up the players and their colors."
msgstr "먼저 플레이어와 플레이어의 색상을 설정합니다."

#: src/tutorial/onchain-chess/4-test.md:152
msgid ""
"We should list both Components and Systems in arrays, with each having "
"CLASS_HASH as elements."
msgstr ""
"컴포넌트와 시스템 모두를 배열에 나열하고, 각각 CLASS_HASH를 구성 요소로 사용"
"해야 합니다."

#: src/tutorial/onchain-chess/4-test.md:154
msgid ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"
msgstr ""
"```rust,ignore\n"
"// components\n"
"let mut components = array::ArrayTrait::new();\n"
"components.append(game::TEST_CLASS_HASH);\n"
"components.append(game_turn::TEST_CLASS_HASH);\n"
"components.append(square::TEST_CLASS_HASH);\n"
"\n"
"//systems\n"
"let mut systems = array::ArrayTrait::new();\n"
"systems.append(initiate_system::TEST_CLASS_HASH);\n"
"systems.append(move_system::TEST_CLASS_HASH);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:167
msgid "Next, we'll create our game world."
msgstr "다음으로 게임 월드를 만들겠습니다."

#: src/tutorial/onchain-chess/4-test.md:173
msgid ""
"We use `initiate_system` to put our Square pieces on the board. Each Square "
"holds a piece. The system's execute function needs some input, which we give "
"it as calldata."
msgstr ""
"`initiate_system`을 사용하여 정사각형 보드 조각들을 보드에 놓습니다. 각 정사"
"각형은 보드의 한 조각씩 가지고 있습니다. 시스템의 실행 함수에는 몇 가지 입력"
"이 필요하며, 이를 호출 데이터로 전달합니다."

#: src/tutorial/onchain-chess/4-test.md:175
msgid ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute('initiate_system'.into(), calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
"        // initiate\n"
"        let mut calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        calldata.append(white.into());\n"
"        calldata.append(black.into());\n"
"        world.execute(‘initiate_system’.into(), calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:183
msgid ""
"Let's check if a White pawn is at (0,1). Remember, to get a piece that "
"exists on the square, you need to use the keys of the `Square` component, "
"which are `game_id`, `x`, and `y`. Do the same check for the Black Pawn."
msgstr ""
"흰색 폰이 (0,1)에 있는지 확인해 봅시다. 사각형에 존재하는 말을 얻으려면 "
"`Square` 구성 요소의 키인 `game_id`, `x`, `y`를 사용해야 한다는 점을 기억하세"
"요. 검은 폰도 똑같이 확인합니다."

#: src/tutorial/onchain-chess/4-test.md:185
msgid ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, \"should be White Pawn "
"in (0,1)\");\n"
"            },\n"
"            Option::None(_) => assert(false, 'should have piece in (0,1)),\n"
"        };\n"
"```"
msgstr ""
"```rust,ignore\n"
"        //White pawn is now in (0,1)\n"
"        let a2 = get!(world, (game_id, 0, 1), (Square));\n"
"        match a2.piece {\n"
"            Option::Some(piece) => {\n"
"                assert(piece == PieceType::WhitePawn, “should be White Pawn "
"in (0,1)”);\n"
"            },\n"
"            Option::None(_) => assert(false, ‘should have piece in (0,1)),\n"
"        };\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:196
msgid ""
"After setting up the board, use `move_system` to make moves. Provide the "
"current position, the next position, the player's address, and the game id."
msgstr ""
"보드를 설정한 후 `move_system`을 사용하여 이동합니다. 현재 위치, 다음 위치, "
"플레이어의 주소, 게임 ID를 입력합니다."

#: src/tutorial/onchain-chess/4-test.md:198
msgid ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute('move_system'.into(), move_calldata);\n"
"```"
msgstr ""
"```rust,ignore\n"
" //Move White Pawn to (0,3)\n"
"        let mut move_calldata = array::ArrayTrait::<core::felt252>::new();\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(1);\n"
"        move_calldata.append(0);\n"
"        move_calldata.append(3);\n"
"        move_calldata.append(white.into());\n"
"        move_calldata.append(game_id);\n"
"        world.execute(‘move_system’.into(), move_calldata);\n"
"```"

#: src/tutorial/onchain-chess/4-test.md:210
msgid "Keep moving pieces and checking if they're in the right places."
msgstr "말을 계속 움직이고 올바른 위치에 있는지 확인하세요."

#: src/tutorial/onchain-chess/4-test.md:212
#, fuzzy
msgid "Congratulations!"
msgstr "## 축하합니다!"

#: src/tutorial/onchain-chess/4-test.md:214
msgid ""
"You've made the basic contracts for a chess game using the Dojo engine! This "
"tutorial was just the beginning. There are many ways to make the game "
"better, like optimizing parts, adding checks, or considering special cases. "
"If you want to do more with this chess game, try these challenges:"
msgstr ""
"Dojo 엔진을 사용하여 체스 게임의 기본 컨트랙트를 만들었습니다! 이 튜토리얼은 "
"시작에 불과합니다. 최적화, 추가적인 수 적합성 체크, 특수한 수 고려 등 게임을 "
"개선할 수 있는 방법은 많습니다. 이 체스 게임으로 더 많은 것을 해보고 싶으시다"
"면 다음 챌린지에 도전해 보세요:"

#: src/tutorial/onchain-chess/4-test.md:216
msgid ""
"Make an `initiate_system` that uses lazy init. If you're unsure about lazy "
"init, [read up on it](https://en.wikipedia.org/wiki/Lazy_initialization). "
"This can help make your game actions more efficient."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:217
msgid ""
"Add a checkmate feature. Our game doesn't end now, so decide when it should!"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:218
msgid ""
"Include special moves like castling, En Passant Capture, or Pawn Promotion."
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:219
msgid ""
"Make your own chess rules! You could even create your own version of the "
"[immortal game](https://immortal.game/)"
msgstr ""

#: src/tutorial/onchain-chess/4-test.md:221
msgid ""
"Lastly, share your project with others in the [Dojo community](https://"
"discord.gg/akd2yfuRS3)!"
msgstr ""
"마지막으로, [Dojo 커뮤니티](https://discord.gg/akd2yfuRS3)에서 다른 사람들과 "
"프로젝트를 공유하세요!"

#: src/misc/contributors.md:1
#, fuzzy
msgid "Contributing to Dojo Book"
msgstr "## 기여하기"

#: src/misc/contributors.md:3
msgid ""
"As the Dojo engine progresses and develops, it is essential for the Dojo "
"book to keep pace with these advancements. Updating and refining the book "
"ensures that it remains a relevant and valuable resource for those "
"interested in understanding and utilizing the latest Dojo engine features "
"and capabilities. All help is welcome!"
msgstr ""
"Dojo 엔진이 발전함에 따라 Dojo 책도 마찬가지로 계속 업데이트가 되어야합니다. "
"이 책을 계속 업데이트하여 최신 Dojo 엔진 기능을 이해하고 활용하는 데 관심이 "
"있는 분들에게 가치 있는 자료가 되도록 노력하겠습니다. 모든 도움을 환영합니다!"

#: src/misc/contributors.md:5
#, fuzzy
msgid "The purpose of the book"
msgstr "### 책의 목적"

#: src/misc/contributors.md:7
msgid ""
"The Dojo book is designed to be a comprehensive resource that caters to "
"users at various levels of experience. It aims to serve as both an "
"introductory guide for those new to Dojo and its ancillary packages, as well "
"as a reference for more experienced users seeking to deepen their "
"understanding of the engine's features and capabilities."
msgstr ""
"Dojo 책은 다양한 경험 수준의 사용자를 위한 종합적인 자료로 설계되었습니다. "
"Dojo 및 보조 패키지를 처음 접하는 사용자를 위한 입문서이자 엔진의 기능과 성능"
"을 더 깊이 이해하고자 하는 숙련된 사용자를 위한 참고서 역할을 하는 것을 목표"
"로 합니다."

#: src/misc/contributors.md:9
msgid "The book is split into some major chapters:"
msgstr "이 책은 몇 가지 주요 장으로 나뉩니다:"

#: src/misc/contributors.md:11
msgid "Framework Theory"
msgstr ""

#: src/misc/contributors.md:13
#, fuzzy
msgid "Building a World"
msgstr "## 소스에서 빌드"

#: src/misc/contributors.md:15
#, fuzzy
msgid "Code of Conduct"
msgstr "### 행동 강령"

#: src/misc/contributors.md:17
msgid ""
"The book follows the [Rust Code of Conduct](https://www.rust-lang.org/"
"policies/code-of-conduct)."
msgstr ""
"이 책은 [Rust Code of Conduct](https://www.rust-lang.org/policies/code-of-"
"conduct)을 따릅니다."

#: src/misc/contributors.md:19
#, fuzzy
msgid "Ways to contribute"
msgstr "### 기여하는 방법"

#: src/misc/contributors.md:21
#, fuzzy
msgid "Issues"
msgstr "#### 이슈"

#: src/misc/contributors.md:23
msgid ""
"If you think that some content is missing or out-of-date, feel free to open "
"an issue. If you find multiple pieces of content lacking, please open up a "
"separate issue for each."
msgstr ""
"일부 내용이 누락되었거나 오래되었다고 생각되면 언제든지 이슈를 개설해 주세"
"요. 여러 개의 콘텐츠가 누락된 경우 각각에 대해 별도의 이슈를 개설해 주세요."

#: src/misc/contributors.md:25
msgid ""
"The issues will then be labeled so other contributors can find chunks of "
"work they are interested in more easily."
msgstr ""
"그러면 이슈에 레이블이 지정되어 다른 기여자들이 관심 있는 작업 내용을 더 쉽"
"게 찾을 수 있습니다."

#: src/misc/contributors.md:27
msgid ""
"The issue should contain what is missing, or what could be improved, in as "
"much detail as you deem necessary."
msgstr ""
"이슈에는 누락된 내용이나 개선할 수 있는 내용이 필요하다고 생각되는 만큼 자세"
"히 포함되어야 합니다."

#: src/misc/contributors.md:29
#, fuzzy
msgid "Pull requests"
msgstr "#### 풀 리퀘스트"

#: src/misc/contributors.md:31
msgid ""
"Feel free to contribute changes to the book by opening a pull request - "
"anything is welcome, from reformulating a sentence, fixing a typo, to adding "
"new sections or chapters."
msgstr ""
"PR를 개설하여 문장을 고치거나 오타를 수정하는 것부터 새로운 섹션이나 챕터를 "
"추가하는 것까지 무엇이든 자유롭게 책에 기여하세요."

#: src/misc/contributors.md:33
msgid ""
"When your pull request is open, other contributors will take a look and may "
"request changes. Do not be discouraged!"
msgstr ""
"PR을 열게 되면 다른 기여자가 검토하고 변경을 요청할 수 있습니다. 낙심하지 마"
"세요!"

#: src/misc/contributors.md:35
#, fuzzy
msgid "Writing style"
msgstr "### 글쓰기 스타일"

#: src/misc/contributors.md:37
msgid ""
"This section documents a few standards for writing used throughout the book."
msgstr "이 섹션에서는 책 전체에서 사용되는 몇 가지 글쓰기 표준을 설명합니다."

#: src/misc/contributors.md:39
#, fuzzy
msgid "Chapters start with a second level heading"
msgstr "#### 챕터는 두 번째 레벨 제목으로 시작합니다"

#: src/misc/contributors.md:41
msgid "We use:"
msgstr "우리는 사용합니다:"

#: src/misc/contributors.md:47
msgid "We do not use:"
msgstr "우리는 사용하지 않습니다:"

#~ msgid "Dojo"
#~ msgstr "Dojo"

#~ msgid ""
#~ "- [Quickstart](./getting-started/quick-start.md)\n"
#~ "- [What is Dojo? ](./theory/what-is-dojo.md)\n"
#~ "- [Explore the Architecture](./cairo/hello-dojo.md)"
#~ msgstr ""
#~ "- [빠른 시작](./getting-started/quick-start.md)\n"
#~ "- [Dojo 란 무엇인가요? ](./theory/what-is-dojo.md)\n"
#~ "- [헬로 Dojo](./cairo/hello-dojo.md)"

#~ msgid ""
#~ "<video controls poster=\"https://"
#~ "gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
#~ "MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
#~ "  <source src=\"https://"
#~ "sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa.arweave.net/kW-"
#~ "uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/mp4\">\n"
#~ "  Your browser does not support the video tag.\n"
#~ "</video>"
#~ msgstr ""
#~ "<video controls poster=\"https://"
#~ "gf326cjag4w6pdpc42qp22enfhxsywmq6sgs7mkxbn6el7aioyxa.arweave.net/"
#~ "MXevCSA3LeeN4uag_WiNKe8sWZD0jS-xVwt8RfwIdi4\">\n"
#~ " <source src=\"https://"
#~ "sfx25btazqz62pajxecorlp4exskwgokakub44rxmpnsosep5iqa.arweave.net/kW-"
#~ "uhmDMM-08CbkE6K38JeSrGcoCqB5yN2PbJ0iP6iA\" type=\"video/mp4\">\n"
#~ "  브라우저가 동영상 태그를 지원하지 않습니다.\n"
#~ "</video>"

#~ msgid "# What is Dojo?"
#~ msgstr "# Dojo란 무엇인가요?"

#~ msgid "Dojo Sozo Workflow"
#~ msgstr "## Dojo 워크플로"

#~ msgid ""
#~ "- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/"
#~ "autonomous-worlds-aim-to-free-online-games-from-corporate-control/)\n"
#~ "- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/"
#~ "autonomous-worlds)\n"
#~ "- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep."
#~ "substack.com/p/the-strongest-crypto-gaming-thesis)\n"
#~ "- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/"
#~ "blog/mud-an-engine-for-autonomous-worlds)\n"
#~ "- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
#~ "- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza."
#~ "xyz/2023/05/composable-engineering)\n"
#~ "- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/"
#~ "wind-up-worlds/)\n"
#~ "- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-"
#~ "chevet/on-chain-realities-and-autonomous-worlds)"
#~ msgstr ""
#~ "- [Wired - Autonomous Worlds Primer](https://www.wired.com/story/"
#~ "autonomous-worlds-aim-to-free-online-games-from-corporate-control/)\n"
#~ "- [0xParc - Autonomous Worlds (Part 1)](https://0xparc.org/blog/"
#~ "autonomous-worlds)\n"
#~ "- [Gubsheep - The Strongest Crypto Gaming Thesis](https://gubsheep."
#~ "substack.com/p/the-strongest-crypto-gaming-thesis)\n"
#~ "- [Lattice - MUD: An engine for Autonomous Worlds](https://lattice.xyz/"
#~ "blog/mud-an-engine-for-autonomous-worlds)\n"
#~ "- [Guiltygyoza - Game 2.0](https://www.guiltygyoza.xyz/2022/07/game2)\n"
#~ "- [Guiltygyoza - Composable Engineering](https://www.guiltygyoza."
#~ "xyz/2023/05/composable-engineering)\n"
#~ "- [Jay Springett - Wind-up Worlds](https://www.thejaymo.net/2022/05/06/"
#~ "wind-up-worlds/)\n"
#~ "- [Are.na collection on Autonomous Worlds](https://www.are.na/sylve-"
#~ "chevet/on-chain-realities-and-autonomous-worlds)"

#~ msgid ""
#~ "- [Cairo book](https://cairo-book.github.io/)\n"
#~ "- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
#~ "- [Starknet Book](https://book.starknet.io/)"
#~ msgstr ""
#~ "- [Cairo book](https://cairo-book.github.io/)\n"
#~ "- [Awesome Cairo](https://github.com/auditless/awesome-cairo)\n"
#~ "- [Starknet Book](https://book.starknet.io/)"

#~ msgid "# FAQs"
#~ msgstr "# FAQs"

#~ msgid "## Quick Start"
#~ msgstr "## 빠른 시작"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup\n"
#~ "```"

#~ msgid "#### Prerequisites"
#~ msgstr "#### 전제 조건"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --branch master\n"
#~ "dojoup --path path/to/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —branch master\n"
#~ "dojoup —path path/to/dojo\n"
#~ "```"

#~ msgid "# Development Setup"
#~ msgstr "# 개발환경 설정"

#~ msgid ""
#~ "- Rust\n"
#~ "- Cairo"
#~ msgstr ""
#~ "- Rust\n"
#~ "- Cairo"

#~ msgid ""
#~ "```sh\n"
#~ "rustup override set stable && rustup update && cargo test\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "rustup override set stable && rustup update && cargo test\n"
#~ "```"

#~ msgid "## Get Started"
#~ msgstr "## 시작하기"

#~ msgid "# Hello Dojo"
#~ msgstr "# 헬로 Dojo"

#~ msgid ""
#~ "```console\n"
#~ "sozo init\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "sozo init\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "src\n"
#~ "  - components.cairo\n"
#~ "  - systems.cairo\n"
#~ "  - lib.cairo\n"
#~ "Scarb.toml\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "src\n"
#~ "  - components.cairo\n"
#~ "  - systems.cairo\n"
#~ "  - lib.cairo\n"
#~ "Scarb.toml\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Position {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "\n"
#~ "...rest of code\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Position {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "\n"
#~ "…rest of code\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                },\n"
#~ "                Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                },\n"
#~ "                Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context)\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context)\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Moves {\n"
#~ "            player: ctx.origin, remaining: 10\n"
#~ "            }, Position {\n"
#~ "            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Moves {\n"
#~ "            player: ctx.origin, remaining: 10\n"
#~ "            }, Position {\n"
#~ "            player: ctx.origin, x: position.x + 10, y: position.y + 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "-   Explained the anatomy of a Dojo project\n"
#~ "-   Explained the importace of the `#[derive(Component)]` and `#[system]` "
#~ "attribute\n"
#~ "-   Explained the `execute` function\n"
#~ "-   Explained the `Context` struct\n"
#~ "-   Touched on the `get!` and `set!` commands"
#~ msgstr ""
#~ "-   Dojo 프로젝트의 구조에 대해 설명했습니다\n"
#~ "-   `#[derive(Component)]`와 `#[system]` 속성의 중요성에 대해 설명했습니"
#~ "다\n"
#~ "-   `execute` 함수에 대한 설명\n"
#~ "-   `Context`구조체 설명\n"
#~ "-   `get!` 및 `set!` 명령어에 대해 설명했습니다"

#~ msgid ""
#~ "```bash\n"
#~ "sozo build\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo build\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "katana --disable-fee\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana —disable-fee\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sozo migrate --name test\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo migrate —name test\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Migration account: "
#~ "0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
#~ "\n"
#~ "[1] 🌎 Building World state....\n"
#~ "  > No remote World found\n"
#~ "[2] 🧰 Evaluating Worlds diff....\n"
#~ "  > Total diffs found: 7\n"
#~ "[3] 📦 Preparing for migration....\n"
#~ "  > Total items to be migrated (7): New 7 Update 0\n"
#~ "  \n"
#~ "# Executor\n"
#~ "  > Contract address: "
#~ "0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
#~ "# World\n"
#~ "  > Contract address: "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "# Components (2)\n"
#~ "Moves\n"
#~ "  > class hash: "
#~ "0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
#~ "Position\n"
#~ "  > class hash: "
#~ "0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
#~ "# Systems (3)\n"
#~ "spawn\n"
#~ "  > class hash: "
#~ "0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
#~ "move\n"
#~ "  > class hash: "
#~ "0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
#~ "library_call\n"
#~ "  > class hash: "
#~ "0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
#~ "\n"
#~ "🎉 Successfully migrated World on block #4 at address "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Migration account: "
#~ "0x33c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
#~ "\n"
#~ "[1] 🌎 Building World state….\n"
#~ "  > No remote World found\n"
#~ "[2] 🧰 Evaluating Worlds diff….\n"
#~ "  > Total diffs found: 7\n"
#~ "[3] 📦 Preparing for migration….\n"
#~ "  > Total items to be migrated (7): New 7 Update 0\n"
#~ "  \n"
#~ "# Executor\n"
#~ "  > Contract address: "
#~ "0x1a8cc7a653543337be184d21ceeb5cfc7e97af5ab7da5e4be77f373124d7e48\n"
#~ "# World\n"
#~ "  > Contract address: "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "# Components (2)\n"
#~ "Moves\n"
#~ "  > class hash: "
#~ "0x3240ca67c41c5ae5557f87f44cca2b590f40407082dd390d893a514cfb2b8cd\n"
#~ "Position\n"
#~ "  > class hash: "
#~ "0x4caa1806451739b6fb470652b8066a11f80e847d49003b43cca75a2fd7647b6\n"
#~ "# Systems (3)\n"
#~ "spawn\n"
#~ "  > class hash: "
#~ "0x1b949b00d5776c8ba13c2fdada38d4b196f3717c93c5c254c4909ed0eb249f7\n"
#~ "move\n"
#~ "  > class hash: "
#~ "0x2534c514efeab524f24cd4b03add904eb540391e9966ebc96f8ce98453a4e1e\n"
#~ "library_call\n"
#~ "  > class hash: "
#~ "0xabfd55d9bb6552aac17d78b33a6e18b06b1b95d4f684637e661dd83053fd45\n"
#~ "\n"
#~ "🎉 Successfully migrated World on block #4 at address "
#~ "0x71b95a2c000545624c51813444b57dbcdcc153dfc79b6b0e3a9a536168d1e16\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "sozo execute spawn\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "sozo execute spawn\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "torii\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "torii\n"
#~ "```"

#~ msgid ""
#~ "-   Built a Dojo world\n"
#~ "-   Deployed the project to Katana\n"
#~ "-   Ran the spawn system locally\n"
#~ "-   Indexed the world with Torii"
#~ msgstr ""
#~ "-   Dojo 월드 구축\n"
#~ "-   Katana에 프로젝트 배포\n"
#~ "-   로컬에서 spawn 시스템 실행\n"
#~ "-   Torii로 월드 인덱싱"

#~ msgid "# Config"
#~ msgstr "# 기본 설정"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let game_id = ctx.world.uuid();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let game_id = ctx.world.uuid();\n"
#~ "```"

#~ msgid "## Components"
#~ msgstr "## 컴포넌트(Components)"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Resource {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    #[key]\n"
#~ "    location: ContractAddress,\n"
#~ "    balance: u8,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Resource {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    #[key]\n"
#~ "    location: ContractAddress,\n"
#~ "    balance: u8,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Resource {\n"
#~ "            player: ctx.origin,\n"
#~ "            location: 12,\n"
#~ "            balance: 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "set!(\n"
#~ "    ctx.world,\n"
#~ "    (\n"
#~ "        Resource {\n"
#~ "            player: ctx.origin,\n"
#~ "            location: 12,\n"
#~ "            balance: 10\n"
#~ "        },\n"
#~ "    )\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "trait PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool;\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl PositionImpl of PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool {\n"
#~ "        if self.x - self.y == 0 {\n"
#~ "            return true;\n"
#~ "        }\n"
#~ "        false\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool {\n"
#~ "        self.x == b.x && self.y == b.y\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "trait PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool;\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "impl PositionImpl of PositionTrait {\n"
#~ "    fn is_zero(self: Position) -> bool {\n"
#~ "        if self.x - self.y == 0 {\n"
#~ "            return true;\n"
#~ "        }\n"
#~ "        false\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_equal(self: Position, b: Position) -> bool {\n"
#~ "        self.x == b.x && self.y == b.y\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct GameSettings {\n"
#~ "    #[key]\n"
#~ "    game_settings_id: u32,\n"
#~ "    combat_cool_down: u32,\n"
#~ "}\n"
#~ "``` "
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "const GAME_SETTINGS_ID: u32 = 9999999999999;\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct GameSettings {\n"
#~ "    #[key]\n"
#~ "    game_settings_id: u32,\n"
#~ "    combat_cool_down: u32,\n"
#~ "}\n"
#~ "``` "

#~ msgid ""
#~ "-   `u8`\n"
#~ "-   `u16`\n"
#~ "-   `u32`\n"
#~ "-   `u64`\n"
#~ "-   `u128`\n"
#~ "-   `u256`\n"
#~ "-   `ContractAddress`"
#~ msgstr ""
#~ "-   `u8`\n"
#~ "-   `u16`\n"
#~ "-   `u32`\n"
#~ "-   `u64`\n"
#~ "-   `u128`\n"
#~ "-   `u256`\n"
#~ "-   `ContractAddress`"

#~ msgid "## Systems"
#~ msgstr "## 시스템(Systems)"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin, (\n"
#~ "                Moves { player: ctx.origin, remaining: 10 }\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod Spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use traits::Into;\n"
#~ "\n"
#~ "    use dojo::world::Context;\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        set !(\n"
#~ "            ctx.world, ctx.origin, (\n"
#~ "                Moves { player: ctx.origin, remaining: 10 }\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "sozo auth writer Moves Spawn \n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "sozo auth writer Moves Spawn \n"
#~ "```"

#~ msgid "## Entities"
#~ msgstr "## 엔티티(Entities)"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Health {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    remaining: u8,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Component, Copy, Drop, Serde, SerdeLen)]\n"
#~ "struct Health {\n"
#~ "    #[key]\n"
#~ "    player: ContractAddress,\n"
#~ "    x: u32,\n"
#~ "    y: u32\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                    }, Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod spawn {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use box::BoxTrait;\n"
#~ "    use traits::Into;\n"
#~ "    use dojo::world::Context;\n"
#~ "\n"
#~ "    use dojo_examples::components::Position;\n"
#~ "    use dojo_examples::components::Moves;\n"
#~ "\n"
#~ "    fn execute(ctx: Context) {\n"
#~ "        let position = get!(ctx.world, ctx.origin, (Position));\n"
#~ "        set!(\n"
#~ "            ctx.world,\n"
#~ "            (\n"
#~ "                Moves {\n"
#~ "                    player: ctx.origin, remaining: 10\n"
#~ "                    }, Position {\n"
#~ "                    player: ctx.origin, x: position.x + 10, y: position.y "
#~ "+ 10\n"
#~ "                },\n"
#~ "            )\n"
#~ "        );\n"
#~ "        return ();\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "## Authorization"
#~ msgstr "## 권한 부여"

#~ msgid ""
#~ "```shell\n"
#~ "sozo auth writer Moves spawn\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "sozo auth writer Moves spawn\n"
#~ "```"

#~ msgid "## Commands"
#~ msgstr "## 명령어"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "let (position, moves) = get!(ctx.world, ctx.origin, (Position, Moves));\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "```"

#~ msgid "## Events"
#~ msgstr "## 이벤트(Events)"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[component]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: Address,\n"
#~ "    remaining: u32,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[component]\n"
#~ "struct Moves {\n"
#~ "    #[key]\n"
#~ "    player: Address,\n"
#~ "    remaining: u32,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct StoreDelRecord {\n"
#~ "    table: felt252,\n"
#~ "    keys: Span<felt252>,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct StoreDelRecord {\n"
#~ "    table: felt252,\n"
#~ "    keys: Span<felt252>,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct WorldSpawned {\n"
#~ "    address: ContractAddress,\n"
#~ "    caller: ContractAddress\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct WorldSpawned {\n"
#~ "    address: ContractAddress,\n"
#~ "    caller: ContractAddress\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct ComponentRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct ComponentRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct SystemRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct SystemRegistered {\n"
#~ "    name: felt252,\n"
#~ "    class_hash: ClassHash\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct Moved {\n"
#~ "    address: felt252,\n"
#~ "    direction: felt252,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Drop, starknet::Event)]\n"
#~ "struct Moved {\n"
#~ "    address: felt252,\n"
#~ "    direction: felt252,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context, direction: Direction) {\n"
#~ "    let (mut position, mut moves) = get !(ctx.world, ctx.origin, "
#~ "(Position, Moves));\n"
#~ "    moves.remaining -= 1;\n"
#~ "\n"
#~ "    let next = next_position(position, direction);\n"
#~ "    \n"
#~ "    set !(ctx.world, (moves, next));\n"
#~ "    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "    return ();\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "fn execute(ctx: Context, direction: Direction) {\n"
#~ "    let (mut position, mut moves) = get !(ctx.world, ctx.origin, "
#~ "(Position, Moves));\n"
#~ "    moves.remaining -= 1;\n"
#~ "\n"
#~ "    let next = next_position(position, direction);\n"
#~ "    \n"
#~ "    set !(ctx.world, (moves, next));\n"
#~ "    emit !(ctx.world, Moved { address: ctx.origin, direction });\n"
#~ "    return ();\n"
#~ "}\n"
#~ "```"

#~ msgid "## Testing"
#~ msgstr "## 테스트"

#~ msgid ""
#~ "```shell\n"
#~ "sozo test\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "sozo test\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "...rest of code\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use debug::PrintTrait;\n"
#~ "    use super::{Position, PositionTrait};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_zero() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), "
#~ "'not zero');\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_equal() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        let position = Position { player, x: 420, y: 0 };\n"
#~ "        position.print();\n"
#~ "        assert(PositionTrait::is_equal(position, Position { player, x: "
#~ "420, y: 0 }), 'not equal');\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "…rest of code\n"
#~ "\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use debug::PrintTrait;\n"
#~ "    use super::{Position, PositionTrait};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_zero() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        assert(PositionTrait::is_zero(Position { player, x: 0, y: 0 }), "
#~ "‘not zero’);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(100000)]\n"
#~ "    fn test_position_is_equal() {\n"
#~ "        let player = starknet::contract_address_const::<0x0>();\n"
#~ "        let position = Position { player, x: 420, y: 0 };\n"
#~ "        position.print();\n"
#~ "        assert(PositionTrait::is_equal(position, Position { player, x: "
#~ "420, y: 0 }), ‘not equal’);\n"
#~ "    }\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid "## Dojo Modules"
#~ msgstr "## Dojo 모듈"

#~ msgid "## ERC20"
#~ msgstr "## ERC20"

#~ msgid "# Overview"
#~ msgstr "# 개요"

#~ msgid ""
#~ "- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-"
#~ "react-app)\n"
#~ "- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"
#~ msgstr ""
#~ "- [Dojo-create-react-app](https://github.com/dojoengine/dojo-starter-"
#~ "react-app)\n"
#~ "- [Dojo-starter-phaser](https://github.com/dojoengine/dojo-starter-phaser)"

#~ msgid "### @dojoengine/core"
#~ msgstr "### @dojoengine/core"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/core\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/core\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/react\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/react\n"
#~ "```"

#~ msgid ""
#~ "```console\n"
#~ "yarn add @dojoengine/create-burner\n"
#~ "```"
#~ msgstr ""
#~ "```console\n"
#~ "yarn add @dojoengine/create-burner\n"
#~ "```"

#~ msgid ""
#~ "- World explorers\n"
#~ "- World deployers\n"
#~ "- Games\n"
#~ "- Anaylitics"
#~ msgstr ""
#~ "- World explorers\n"
#~ "- World deployers\n"
#~ "- Games\n"
#~ "- Anaylitics"

#~ msgid "### Getting Started"
#~ msgstr "### 시작하기"

#~ msgid ""
#~ "```sh   \n"
#~ "# Debian\n"
#~ "sudo apt-get install jq\n"
#~ "\n"
#~ "# Mac\n"
#~ "brew install jq\n"
#~ "```"
#~ msgstr ""
#~ "```sh   \n"
#~ "# Debian\n"
#~ "sudo apt-get install jq\n"
#~ "\n"
#~ "# Mac\n"
#~ "brew install jq\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --version nightly\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —version nightly\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --branch release/0.1.0\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —branch release/0.1.0\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --repo tarrencev/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —repo tarrencev/dojo\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --repo tarrencev/dojo --branch patch-10\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —repo tarrencev/dojo —branch patch-10\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --pr 1071\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —pr 1071\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup -C 94bfdb2\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup -C 94bfdb2\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "dojoup --path ./git/dojo\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "dojoup —path ./git/dojo\n"
#~ "```"

#~ msgid "## Sozo"
#~ msgstr "## Sozo"

#~ msgid ""
#~ "-   [init](./project-commands/init.md)\n"
#~ "-   [build](./project-commands/build.md)\n"
#~ "-   [test](./project-commands/test.md)\n"
#~ "-   [migrate](./project-commands/migrate.md)"
#~ msgstr ""
#~ "-   [init](./project-commands/init.md)\n"
#~ "-   [build](./project-commands/build.md)\n"
#~ "-   [test](./project-commands/test.md)\n"
#~ "-   [migrate](./project-commands/migrate.md)"

#~ msgid ""
#~ "-   [execute](./world-commands/execute.md)\n"
#~ "-   [register](./world-commands/register.md)\n"
#~ "-   [system](./world-commands/system.md)\n"
#~ "-   [component](./world-commands/component.md)\n"
#~ "-   [events](./world-commands/events.md)\n"
#~ "-   [auth](./world-commands/auth.md)"
#~ msgstr ""
#~ "-   [execute](./world-commands/execute.md)\n"
#~ "-   [register](./world-commands/register.md)\n"
#~ "-   [system](./world-commands/system.md)\n"
#~ "-   [component](./world-commands/component.md)\n"
#~ "-   [events](./world-commands/events.md)\n"
#~ "-   [auth](./world-commands/auth.md)"

#~ msgid ""
#~ "```sh\n"
#~ "sozo init\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo init\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo build\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo build\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo test\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo test\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo migrate [OPTIONS]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo migrate [OPTIONS]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo migrate --world 0x123456\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo migrate —world 0x123456\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo execute <SYSTEM> [OPTIONS]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo execute <SYSTEM> [OPTIONS]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo execute position --calldata 0x77,0x44\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo execute position —calldata 0x77,0x44\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo register [OPTIONS] <COMMAND>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo register [OPTIONS] <COMMAND>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Commands:\n"
#~ "  component  Register a component to a world.\n"
#~ "  system     Register a system to a world.\n"
#~ "  help       Print this message or the help of the given subcommand(s)\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Commands:\n"
#~ "  component  Register a component to a world.\n"
#~ "  system     Register a system to a world.\n"
#~ "  help       Print this message or the help of the given subcommand(s)\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "# example: component - register a component to a world\n"
#~ "# this will register the Moves component to the world\n"
#~ "sozo register component Moves\n"
#~ "\n"
#~ "# example: system - register a system to a world\n"
#~ "# this will register the spawn system to the world\n"
#~ "sozo register system spawn\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "# example: component - register a component to a world\n"
#~ "# this will register the Moves component to the world\n"
#~ "sozo register component Moves\n"
#~ "\n"
#~ "# example: system - register a system to a world\n"
#~ "# this will register the spawn system to the world\n"
#~ "sozo register system spawn\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo system <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  get         Get the class hash of a system.\n"
#~ "  dependency  Retrieve the component dependencies of a system.\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo system <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  get         Get the class hash of a system.\n"
#~ "  dependency  Retrieve the component dependencies of a system.\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo system get <NAME>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo system get <NAME>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo system dependency <NAME>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo system dependency <NAME>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo system get spawn\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo system get spawn\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo system dependency spawn\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo system dependency spawn\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo component <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  get     Get the class hash of a component\n"
#~ "  schema  Retrieve the schema for a component\n"
#~ "  entity  Get the component value for an entity\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo component <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  get     Get the class hash of a component\n"
#~ "  schema  Retrieve the schema for a component\n"
#~ "  entity  Get the component value for an entity\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo component get <NAME>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo component get <NAME>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo component schema <NAME>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo component schema <NAME>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo component entity <NAME> [KEYS]...\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo component entity <NAME> [KEYS]…\n"
#~ "```"

#~ msgid ""
#~ "_`NAME`_  \n"
#~ " &nbsp;&nbsp;&nbsp;&nbsp;The name of the component"
#~ msgstr ""
#~ "_`NAME`_\n"
#~ " &nbsp;&nbsp;&nbsp;&nbsp;컴포넌트의 이름"

#~ msgid ""
#~ "```sh\n"
#~ "sozo events\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo events\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sozo auth [OPTIONS] <COMMAND>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sozo auth [OPTIONS] <COMMAND>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Commands:\n"
#~ "  writer  Auth a system with the given calldata.\n"
#~ "  help    Print this message or the help of the given subcommand(s)\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Commands:\n"
#~ "  writer  Auth a system with the given calldata.\n"
#~ "  help    Print this message or the help of the given subcommand(s)\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "# example: writer - auth a system with the given calldata\n"
#~ "# This will auth the spawn system with the writer role for Position "
#~ "component\n"
#~ "sozo auth writer Position spawn\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "# example: writer - auth a system with the given calldata\n"
#~ "# This will auth the spawn system with the writer role for Position "
#~ "component\n"
#~ "sozo auth writer Position spawn\n"
#~ "```"

#~ msgid "## Katana"
#~ msgstr "## Katana"

#~ msgid "### Features"
#~ msgstr "### 특징"

#~ msgid "### Usage"
#~ msgstr "### 사용법"

#~ msgid ""
#~ "```sh\n"
#~ "katana [OPTIONS]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana [OPTIONS]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "# Produces a new block every 10 seconds\n"
#~ "katana --block-time 10\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "# 10초마다 새 블록을 생성합니다\n"
#~ "katana --block-time 10\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "katana --port <PORT>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana —port <PORT>\n"
#~ "```"

#~ msgid ""
#~ "| Type           | Version |\n"
#~ "| -------------- | ------- |\n"
#~ "| INVOKE         | 1       |\n"
#~ "| DECLARE        | 1, 2    |\n"
#~ "| DEPLOY_ACCOUNT |         |"
#~ msgstr ""
#~ "| Type           | Version |\n"
#~ "| -------------- | ------- |\n"
#~ "| INVOKE         | 1       |\n"
#~ "| DECLARE        | 1, 2    |\n"
#~ "| DEPLOY_ACCOUNT |         |"

#~ msgid ""
#~ "-   `starknet_blockNumber`\n"
#~ "-   `starknet_blockHashAndNumber`\n"
#~ "-   `starknet_getBlockWithTxs`\n"
#~ "-   `starknet_getBlockWithTxHashes`\n"
#~ "-   `starknet_getBlockTransactionCount`\n"
#~ "-   `starknet_getTransactionByHash`\n"
#~ "-   `starknet_getTransactionByBlockIdAndIndex`\n"
#~ "-   `starknet_getTransactionReceipt`\n"
#~ "-   `starknet_pendingTransactions`\n"
#~ "-   `starknet_getStateUpdate`\n"
#~ "\n"
#~ "-   `starknet_call`\n"
#~ "-   `starknet_estimateFee`\n"
#~ "\n"
#~ "-   `starknet_chainId`\n"
#~ "\n"
#~ "-   `starknet_getNonce`\n"
#~ "-   `starknet_getEvents`\n"
#~ "-   `starknet_getStorageAt`\n"
#~ "-   `starknet_getClassHashAt`\n"
#~ "-   `starknet_getClass`\n"
#~ "-   `starknet_getClassAt`\n"
#~ "\n"
#~ "-   `starknet_syncing`\n"
#~ "\n"
#~ "-   `starknet_addInvokeTransaction`\n"
#~ "-   `starknet_addDeclareTransaction`\n"
#~ "-   `starknet_addDeployAccountTransaction`"
#~ msgstr ""
#~ "-   `starknet_blockNumber`\n"
#~ "-   `starknet_blockHashAndNumber`\n"
#~ "-   `starknet_getBlockWithTxs`\n"
#~ "-   `starknet_getBlockWithTxHashes`\n"
#~ "-   `starknet_getBlockTransactionCount`\n"
#~ "-   `starknet_getTransactionByHash`\n"
#~ "-   `starknet_getTransactionByBlockIdAndIndex`\n"
#~ "-   `starknet_getTransactionReceipt`\n"
#~ "-   `starknet_pendingTransactions`\n"
#~ "-   `starknet_getStateUpdate`\n"
#~ "\n"
#~ "-   `starknet_call`\n"
#~ "-   `starknet_estimateFee`\n"
#~ "\n"
#~ "-   `starknet_chainId`\n"
#~ "\n"
#~ "-   `starknet_getNonce`\n"
#~ "-   `starknet_getEvents`\n"
#~ "-   `starknet_getStorageAt`\n"
#~ "-   `starknet_getClassHashAt`\n"
#~ "-   `starknet_getClass`\n"
#~ "-   `starknet_getClassAt`\n"
#~ "\n"
#~ "-   `starknet_syncing`\n"
#~ "\n"
#~ "-   `starknet_addInvokeTransaction`\n"
#~ "-   `starknet_addDeclareTransaction`\n"
#~ "-   `starknet_addDeployAccountTransaction`"

#~ msgid ""
#~ "-   bash\n"
#~ "-   elvish\n"
#~ "-   fish\n"
#~ "-   powershell\n"
#~ "-   zsh"
#~ msgstr ""
#~ "-   bash\n"
#~ "-   elvish\n"
#~ "-   fish\n"
#~ "-   powershell\n"
#~ "-   zsh"

#~ msgid "#### EXAMPLES"
#~ msgstr "#### 예시"

#~ msgid ""
#~ "```bash\n"
#~ "katana completions bash >> ~/.bashrc\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana completions bash >> ~/.bashrc\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "katana --accounts 15 --disable-fee\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana —accounts 15 —disable-fee\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "katana --chain-id SN_GOERLI --port 8545\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana —chain-id SN_GOERLI —port 8545\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "katana --load-state ./dump-state.bin --dump-state ./dump-state.bin\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "katana —load-state ./dump-state.bin —dump-state ./dump-state.bin\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "torii\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "torii\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cargo install --path ./crates/torii --profile local --force\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cargo install —path ./crates/torii —profile local —force\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "torii [OPTIONS]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "torii [OPTIONS]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "# Persistent database storage using file indexer.db\n"
#~ "torii --database-url sqlite:indexer.db\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "# indexer.db 파일을 사용한 영구 데이터베이스 저장소\n"
#~ "torii --database-url sqlite:indexer.db\n"
#~ "```"

#~ msgid ""
#~ "`-h, --help`\n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; Print help"
#~ msgstr ""
#~ "`h, --help`\n"
#~ "&nbsp;&nbsp;&nbsp;&nbsp; 도움말 출력"

#~ msgid ""
#~ "1. A system to spawn all the chess pieces\n"
#~ "2. A system to make pieces move\n"
#~ "3. Add some functions to check a legal move\n"
#~ "4. Play chess ♟♙ - integration test!"
#~ msgstr ""
#~ "1. 모든 체스 말 생성 시스템\n"
#~ "2. 기물의 움직임을 만드는 시스템\n"
#~ "3. 합법적인 이동을 확인하는 몇 가지 기능 추가\n"
#~ "4. 체스 플레이 - 통합 테스트!"

#~ msgid "# 0. Setup"
#~ msgstr "# 0. 설정"

#~ msgid ""
#~ "```sh\n"
#~ "mkdir dojo-chess\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "mkdir dojo-chess\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "cd dojo-chess\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "cd dojo-chess\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "mod components;\n"
#~ "mod systems;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "mod components;\n"
#~ "mod systems;\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[derive(Component)]\n"
#~ "struct Square {\n"
#~ "    #[key]\n"
#~ "    game_id: felt252,\n"
#~ "    #[key]\n"
#~ "    x: u32,\n"
#~ "    #[key]\n"
#~ "    y: u32,\n"
#~ "    piece: Option<PieceType>,\n"
#~ "}\n"
#~ "\n"
#~ "enum PieceType {\n"
#~ "    WhitePawn,\n"
#~ "    WhiteKnight,\n"
#~ "    WhiteBishop,\n"
#~ "    WhiteRook,\n"
#~ "    WhiteQueen,\n"
#~ "    WhiteKing,\n"
#~ "    BlackPawn,\n"
#~ "    BlackKnight,\n"
#~ "    BlackBishop,\n"
#~ "    BlackRook,\n"
#~ "    BlackQueen,\n"
#~ "    BlackKing,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[derive(Component)]\n"
#~ "struct Square {\n"
#~ "    #[key]\n"
#~ "    game_id: felt252,\n"
#~ "    #[key]\n"
#~ "    x: u32,\n"
#~ "    #[key]\n"
#~ "    y: u32,\n"
#~ "    piece: Option<PieceType>,\n"
#~ "}\n"
#~ "\n"
#~ "enum PieceType {\n"
#~ "    WhitePawn,\n"
#~ "    WhiteKnight,\n"
#~ "    WhiteBishop,\n"
#~ "    WhiteRook,\n"
#~ "    WhiteQueen,\n"
#~ "    WhiteKing,\n"
#~ "    BlackPawn,\n"
#~ "    BlackKnight,\n"
#~ "    BlackBishop,\n"
#~ "    BlackRook,\n"
#~ "    BlackQueen,\n"
#~ "    BlackKing,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod initiate_system {\n"
#~ "\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "#[system]\n"
#~ "mod initiate_system {\n"
#~ "\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "mod initiate;\n"
#~ "\n"
#~ "use initiate::initiate_system;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "mod initiate;\n"
#~ "\n"
#~ "use initiate::initiate_system;\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "mod initiate;\n"
#~ "mod move;\n"
#~ "\n"
#~ "use initiate::initiate_system;\n"
#~ "use move::move_system;\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "mod initiate;\n"
#~ "mod move;\n"
#~ "\n"
#~ "use initiate::initiate_system;\n"
#~ "use move::move_system;\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "error: Trait has no implementation in context:\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "error: Trait has no implementation in context:\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "#[derive(Component, Drop, SerdeLen, Serde)]\n"
#~ "struct Square {\n"
#~ "    #[key]\n"
#~ "    game_id: felt252,\n"
#~ "    #[key]\n"
#~ "    x: u32,\n"
#~ "    #[key]\n"
#~ "    y: u32,\n"
#~ "    piece: Option<PieceType>,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Serde, Drop, Copy, PartialEq)]\n"
#~ "enum PieceType {\n"
#~ "    WhitePawn,\n"
#~ "    WhiteKnight,\n"
#~ "    WhiteBishop,\n"
#~ "    WhiteRook,\n"
#~ "    WhiteQueen,\n"
#~ "    WhiteKing,\n"
#~ "    BlackPawn,\n"
#~ "    BlackKnight,\n"
#~ "    BlackBishop,\n"
#~ "    BlackRook,\n"
#~ "    BlackQueen,\n"
#~ "    BlackKing,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "\n"
#~ "#[derive(Component, Drop, SerdeLen, Serde)]\n"
#~ "struct Square {\n"
#~ "    #[key]\n"
#~ "    game_id: felt252,\n"
#~ "    #[key]\n"
#~ "    x: u32,\n"
#~ "    #[key]\n"
#~ "    y: u32,\n"
#~ "    piece: Option<PieceType>,\n"
#~ "}\n"
#~ "\n"
#~ "#[derive(Serde, Drop, Copy, PartialEq)]\n"
#~ "enum PieceType {\n"
#~ "    WhitePawn,\n"
#~ "    WhiteKnight,\n"
#~ "    WhiteBishop,\n"
#~ "    WhiteRook,\n"
#~ "    WhiteQueen,\n"
#~ "    WhiteKing,\n"
#~ "    BlackPawn,\n"
#~ "    BlackKnight,\n"
#~ "    BlackBishop,\n"
#~ "    BlackRook,\n"
#~ "    BlackQueen,\n"
#~ "    BlackKing,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "error: Trait has no implementation in context: dojo::serde::SerdeLen::"
#~ "<core::option::Option::<dojo_chess::components::PieceType>>\n"
#~ " --> Square:80:54\n"
#~ "                dojo::SerdeLen::<Option<PieceType>>::len()\n"
#~ "                                                     ^*^\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "error: Trait has no implementation in context: dojo::serde::SerdeLen::"
#~ "<core::option::Option::<dojo_chess::components::PieceType>>\n"
#~ " --> Square:80:54\n"
#~ "                dojo::SerdeLen::<Option<PieceType>>::len()\n"
#~ "                                                     ^*^\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
#~ "    #[inline(always)]\n"
#~ "    fn len() -> usize {\n"
#~ "        2\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "impl PieceOptionSerdeLen of dojo::SerdeLen<Option<PieceType>> {\n"
#~ "    #[inline(always)]\n"
#~ "    fn len() -> usize {\n"
#~ "        2\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "error: Variable not dropped. Trait has no implementation in context:\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "error: Variable not dropped. Trait has no implementation in context:\n"
#~ "```"

#~ msgid "### Requirements"
#~ msgstr "## 요구 사항"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "    game_id: felt252,\n"
#~ "    winner: Option<Color>,\n"
#~ "    white: ContractAddress,\n"
#~ "    black: ContractAddress\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "    game_id: felt252,\n"
#~ "    winner: Option<Color>,\n"
#~ "    white: ContractAddress,\n"
#~ "    black: ContractAddress\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "    game_id: felt252,\n"
#~ "    turn: Color\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "    game_id: felt252,\n"
#~ "    turn: Color\n"
#~ "```"

#~ msgid ""
#~ "<details>\n"
#~ "<summary>Click to see full `components.cairo` code</summary>"
#~ msgstr ""
#~ "<details>\n"
#~ "<summary>전체 `components.cairo` 코드를 보려면 클릭하세요</summary>"

#~ msgid "</details>"
#~ msgstr "</details>"

#~ msgid ""
#~ "<p align=\"center\">\n"
#~ "<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" "
#~ "height=\"auto\">"
#~ msgstr ""
#~ "<p align=\"center\">\n"
#~ "<img src=\"../../images/board.png\" alt=\"image\" width=\"300\" "
#~ "height=\"auto\">"

#~ msgid ""
#~ "1. Write an `execute` function in the system that accepts the world "
#~ "context, white address, and black address as input.\n"
#~ "2. Implement the game entity, comprised of the `Game` component and "
#~ "`GameTurn` component we created in the previous step.\n"
#~ "3. Implement square entities by `Square` component, from a1 to h8 "
#~ "containing the correct `PieceType`.\n"
#~ "4. Run `sozo test` and pass all the tests."
#~ msgstr ""
#~ "1. 시스템에서 월드 컨텍스트, 흰색 계정, 검은색 계정를 입력으로 받아들이는 "
#~ "`execute` 함수를 작성합니다.\n"
#~ "2. 이전 단계에서 만든 `Game` 컴포넌트와 `GameTurn` 컴포넌트로 구성된 게임 "
#~ "엔티티를 구현합니다.\n"
#~ "3. 정사각형(Square) 엔티티를 올바른 `PieceType`을 포함하는 a1부터 h8까지 "
#~ "`Square` 컴포넌트로 구현합니다.\n"
#~ "4. `sozo test`를 실행하고 모든 테스트를 통과합니다."

#~ msgid ""
#~ "- Spawn the test world that imports the components and systems used in "
#~ "testing.\n"
#~ "- Execute `initiate_system` by providing white and black player's wallet "
#~ "addresses as inputs.\n"
#~ "- Retrieve the game entity and piece entity created during "
#~ "`initiate_system`.\n"
#~ "- Ensure the game has been correctly created.\n"
#~ "- Verify that each `Piece` is located in the correct `Square`."
#~ msgstr ""
#~ "- 테스트에 사용되는 컴포넌트와 시스템을 가져오는 테스트 월드를 생성합니"
#~ "다.\n"
#~ "- 화이트 플레이어와 블랙 플레이어의 지갑 주소를 입력으로 제공하여 "
#~ "`initiate_system`을 실행합니다.\n"
#~ "- `Initiate_system` 중에 생성된 게임 엔티티와 조각 엔티티를 가져옵니다.\n"
#~ "- 게임이 올바르게 생성되었는지 확인합니다.\n"
#~ "- 각 `Piece`가 올바른 `Square`에 있는지 확인합니다."

#~ msgid ""
#~ "```rust,ignore\n"
#~ " fn execute(\n"
#~ "        ctx: Context,\n"
#~ "        curr_position: (u32, u32),\n"
#~ "        next_position: (u32, u32),\n"
#~ "        caller: ContractAddress,\n"
#~ "        game_id: felt252\n"
#~ "    )\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ " fn execute(\n"
#~ "        ctx: Context,\n"
#~ "        curr_position: (u32, u32),\n"
#~ "        next_position: (u32, u32),\n"
#~ "        caller: ContractAddress,\n"
#~ "        game_id: felt252\n"
#~ "    )\n"
#~ "```"

#~ msgid ""
#~ "- Follow the same logic as `test_initiate` from the previous chapter.\n"
#~ "- Move the White Knight from (1,0) to (2,2) using the `move_system`.\n"
#~ "- Retrieve the updated position and verify that the piece has "
#~ "successfully moved to its new location."
#~ msgstr ""
#~ "- 이전 장의 `test_initiate`와 동일한 논리를 따릅니다.\n"
#~ "- `move_system`을 사용하여 흰색 나이트를 (1,0)에서 (2,2)로 이동합니다.\n"
#~ "- 업데이트된 위치를 검색하고 밀이 새 위치로 성공적으로 이동했는지 확인합니"
#~ "다."

#~ msgid "# 3. Check Legal Move"
#~ msgstr "# 3. 가능한 움직임인지 확인"

#~ msgid ""
#~ "- If the next move goes outside the board.\n"
#~ "- If there's a piece that can be captured.\n"
#~ "- If the next move is allowed for the type of piece.\n"
#~ "- If the user can allow to make a action (based on the piece's color).\n"
#~ "- ... You can also add other custom check functions."
#~ msgstr ""
#~ "- 다음 수가 보드 밖으로 나가는 경우.\n"
#~ "- 점령할 수 있는 말이 있는 경우.\n"
#~ "- 다음 수이 해당 색깔에 허용되는 경우.\n"
#~ "- 사용자가 (말의 색깔에 따라) 행동을 허용할 수 있는 경우.\n"
#~ "- ... 다른 사용자 지정 확인 기능을 추가할 수도 있습니다."

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  fn is_right_piece_move(\n"
#~ "        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
#~ "next_position: (u32, u32)\n"
#~ "    ) -> bool {}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  fn is_right_piece_move(\n"
#~ "        maybe_piece: Option<PieceType>, curr_position: (u32, u32), "
#~ "next_position: (u32, u32)\n"
#~ "    ) -> bool {}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "  fn is_out_of_board(next_position: (u32, u32)) -> bool{}\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ " fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
#~ "game_id: felt252) -> bool{}\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ " fn is_correct_turn(maybe_piece: PieceType, caller: ContractAddress, "
#~ "game_id: felt252) -> bool{}\n"
#~ "```"

#~ msgid ""
#~ "1. Spawn `white_pawn_1` to (0,1)\n"
#~ "2. Move `white_pawn_1` to (0,3)\n"
#~ "3. Move `black_pawn_2` to (1,6)\n"
#~ "4. Move `white_pawn_1` to (0,4)\n"
#~ "5. Move `black_pawn_2` to (1,5)\n"
#~ "6. Move `white_pawn_1` to (1,5)\n"
#~ "7. Capture `black_pawn_2`"
#~ msgstr ""
#~ "1. Spawn `white_pawn_1` to (0,1)\n"
#~ "2. Move `white_pawn_1` to (0,3)\n"
#~ "3. Move `black_pawn_2` to (1,6)\n"
#~ "4. Move `white_pawn_1` to (0,4)\n"
#~ "5. Move `black_pawn_2` to (1,5)\n"
#~ "6. Move `white_pawn_1` to (1,5)\n"
#~ "7. Capture `black_pawn_2`"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "   let white = starknet::contract_address_const::<0x01>();\n"
#~ "   let black = starknet::contract_address_const::<0x02>();\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "   let white = starknet::contract_address_const::<0x01>();\n"
#~ "   let black = starknet::contract_address_const::<0x02>();\n"
#~ "```"

#~ msgid ""
#~ "```rust,ignore\n"
#~ "     let world = spawn_test_world(components, systems);\n"
#~ "```"
#~ msgstr ""
#~ "```rust,ignore\n"
#~ "     let world = spawn_test_world(components, systems);\n"
#~ "```"

#~ msgid ""
#~ "- Make an `initiate_system` that uses lazy init. If you're unsure about "
#~ "lazy init, [read up on it](https://en.wikipedia.org/wiki/"
#~ "Lazy_initialization). This can help make your game actions more "
#~ "efficient.\n"
#~ "- Add a checkmate feature. Our game doesn't end now, so decide when it "
#~ "should!\n"
#~ "- Include special moves like castling, En Passant Capture, or Pawn "
#~ "Promotion.\n"
#~ "- Make your own chess rules! You could even create your own version of "
#~ "the [immortal game](https://immortal.game/)"
#~ msgstr ""
#~ "- 지연 초기화를 사용하는 `initiate_system`을 만듭니다. 지연 초기화에 대해 "
#~ "잘 모르겠다면 [관련 내용을 읽어보세요](https://en.wikipedia.org/wiki/"
#~ "Lazy_initialization). 이렇게 하면 게임 동작을 더 효율적으로 만들 수 있습니"
#~ "다.\n"
#~ "- 체크메이트 기능을 추가합니다. 게임은 지금 끝나지 않으니 언제 끝날지 결정"
#~ "하세요!\n"
#~ "- Castling, En Passant Capture 또는 폰 승격과 같은 특수한 규칙들을 추가하"
#~ "세요.\n"
#~ "- 나만의 체스 규칙을 만들어 보세요! 나만의 [immortal game](https://"
#~ "immortal.game/) 버전을 만들 수도 있습니다"

#~ msgid ""
#~ "- Framework Theory\n"
#~ "- Getting Started\n"
#~ "- Building a World"
#~ msgstr ""
#~ "- 프레임워크 이론\n"
#~ "- 시작하기\n"
#~ "- 월드 구축"

#~ msgid ""
#~ "```md\n"
#~ "## Some Page\n"
#~ "```"
#~ msgstr ""
#~ "```md\n"
#~ "## Some Page\n"
#~ "```"

#~ msgid ""
#~ "```md\n"
#~ "# Some Page\n"
#~ "```"
#~ msgstr ""
#~ "```md\n"
#~ "# Some Page\n"
#~ "```"

#~ msgid ""
#~ "You can find the [answer](https://github.com/rkdud007/chess-dojo/blob/"
#~ "tutoralv2/src/systems/move.cairo) for chapter 3 here."
#~ msgstr ""
#~ "3장에 대한 [정답](https://github.com/rkdud007/chess-dojo/blob/tutoralv2/"
#~ "src/systems/move.cairo)은 여기에서 확인할 수 있습니다."
