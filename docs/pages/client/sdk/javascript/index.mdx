---
title: "Dojo.js Overview"
description: "Comprehensive guide to using the Dojo.js for building onchain applications"
---

# Dojo.js

The Dojo.js SDK provides a powerful, intuitive interface for interacting with onchain state in JavaScript.
It streamlines data fetching and subscriptions, supporting both simple and complex queries.

## Key Features

- **Type Safety**: Leverage TypeScript for robust, error-resistant code.
- **Intuitive query syntax**: Write ORM-like queries that feel natural.
- **Flexible subscriptions**: Subscribe to granular state changes in your world.
- **Signed messages**: Sign off-chain state and send to Torii.
- **Automatic Zustand Support**: Drop-in Zustand state management.
- **Optimistic Client Rendering**: Update state before a transaction has finalized.

:::note
dojo.js is a wrapper around [dojo.c](https://github.com/dojoengine/dojo.c) that exposes Torii client features via WASM.
For more information about the Torii gRPC client, check out [this documentation](/toolchain/torii/grpc).
:::

## Usage Example

Here's a concise example demonstrating how to subscribe to the `item` model in the `world` namespace, filtering for items with a durability of 2:

```typescript
import {
    ToriiQueryBuilder,
    MemberClause
} from "@dojoengine/sdk";

import {
    useEntityId,
    useEntityQuery,
    useModels,
    useModel,
} from "@dojoengine/sdk/react";

// <MyReactComponent>

// Create a member clause for durability = 2
const memberClause = MemberClause("world-Item", "durability", "Eq", 2);

// Subscribe to changes to the item model
useEntityQuery(
    new ToriiQueryBuilder()
        .withClause(memberClause.build())
        .includeHashedKeys()
);

// Fetch an array of items from the store
const items = useModels("world-Item")

// Fetches a single item from the store
const entityId = useEntityId(1)
const item = useModel(entityId, "world-Item")

// </MyReactComponent>
```

## Getting Started

### Quickstart Wizard

The fastest way to get started is using our quickstart wizard.

```bash
pnpx @dojoengine/create-dojo start
```

This will guide you through a series of prompts to configure your project.

### Manual Setup

For full control over your project structure, follow these steps:

::::steps

#### Create Your Project

Pick any JavaScript framework.
We recommend [pnpm](https://pnpm.io/) as your package manager.

#### Install Dependencies

```bash
cd {project_name}

# Essential packages
pnpm add @dojoengine/core @dojoengine/sdk @dojoengine/torii-client

# For React integration
pnpm add @dojoengine/create-burner @dojoengine/grpc @dojoengine/utils

# For state management (v1.6+)
pnpm add @dojoengine/state

# Build tools for WASM support
pnpm add -D vite-plugin-wasm vite-plugin-top-level-await

# Additional dependencies
pnpm add uuid @types/uuid zustand immer
```

#### Create `dojoConfig.ts`

Create a `dojoConfig.ts` file, which tells dojo.js where your manifest is located:

```typescript
import { createDojoConfig } from "@dojoengine/core";
import manifest from "../path/to/manifest_dev.json";

export const dojoConfig = createDojoConfig({ manifest });
```

#### Generate TypeScript Bindings

[Generate code bindings](/toolchain/sozo/binding-generation) with Sozo, letting you import Dojo models into TypeScript:

```bash
DOJO_MANIFEST_PATH="../path/to/Scarb.toml" sozo build --typescript
```

:::note
These instructions assume you have Dojo contracts relative to your client root.
:::

#### Initialize the SDK

With your bindings generated, you can now link Dojo models to your UI.

```typescript
// main.tsx

// General project imports
import { createRoot } from "react-dom/client";
import App from "./App.tsx";

// General Dojo.js imports
import { init } from "@dojoengine/sdk";
import { DojoSdkProvider } from "@dojoengine/sdk/react";

// Project-specific imports
import { dojoConfig } from "./dojoConfig.ts";
import { setupWorld } from "./bindings/typescript/contracts.gen.ts";
import type { SchemaType } from "./bindings/typescript/models.gen.ts";

async function main() {
    // Initialize the SDK with configuration options
    const sdk = await init<SchemaType>({
        client: {
            // Required: Address of the deployed World contract
            worldAddress: dojoConfig.manifest.world.address,
            // Optional: Torii indexer URL (defaults to http://localhost:8080)
            toriiUrl: dojoConfig.toriiUrl || "http://localhost:8080",
            // Optional: Relay URL for real-time messaging
            relayUrl: dojoConfig.relayUrl || "/ip4/127.0.0.1/tcp/9090",
        },
        // Domain configuration for typed message signing (See SNIP-12 for details)
        domain: {
            name: "MyDojoProject",
            version: "1.0",
            chainId: "KATANA", // or "SN_MAIN", "SN_SEPOLIA"
            revision: "1",
        },
    });

    createRoot(document.getElementById("root")!).render(
        <DojoSdkProvider
            sdk={sdk}
            dojoConfig={dojoConfig}
            clientFn={setupWorld}
        >
            <App />
        </DojoSdkProvider>
    );
}

main();
```

:::warning
The `init` function must be called only once to avoid creating multiple Torii clients.
:::

::::

## Usage Overview

### Understanding Queries

The SDK utilizes two primary types of queries to interact with the Dojo Engine.
Both query types enable filtering based on `entityIds` and model properties.
The key difference lies in the operators supported by the `where` clause:

1. **`SubscriptionQueryType`**
    - For real-time subscriptions to entity and event updates.
    - Supports only the `$is` operator for exact matches.
2. **`QueryType`**
    - For flexibly fetching entities and event messages.
    - Supports a variety of operators for more advanced filtering:
    - You combine queries with 'And' with 'Or' from deep queries. See [Advanced Usage](#advanced-usage).

### Querying Entities

This example fetches `player` entities from the `world` namespace where `id` is "1" and `name` is "Alice", demonstrating multiple conditions in a query.

Note: `$eq` is for exact matching. Other operators (`$gt`, `$lt`, etc.) are available for complex queries.

```typescript
// This is how a raw Torii query would look like.
{
    "Composite": {
        "operator": "And",
        "clauses": [
            {
                "Member": {
                    "model": "world-Player",
                    "member": "id",
                    "operator": "Eq",
                    "value": {
                        "Primitive": {
                            "U32": 1
                        }
                    }
                }
            },
            {
                "Member": {
                    "model": "world-Player",
                    "member": "name",
                    "operator": "Eq",
                    "value": "Alice",
                }
            },
    ]
  }
}

// ClauseBuilder version
const entities = await sdk.getEntities(
  new ToriiQueryBuilder().withClause(
    new ClauseBuilder().compose().and(
      new ClauseBuilder().where("world-Player", 'id', 'Eq', 1),
      new ClauseBuilder().where("world-Player", 'name', 'Eq', "Alice"),
    ).build();
  ).build()
);
// Or
const entities = await sdk.getEntities(
  new ToriiQueryBuilder().withClause(
    AndComposeClause([
      MemberClause("world-Player", 'id', 'Eq', 1),
      MemberClause("world-Player", 'name', 'Eq', "Alice"),
    ]).build();
  ).build()
);
```

### Subscribing To Entity Changes

Subscribing to entity changes is a bit more trivial.
Because Torii subscribe functions only works with `KeysClause` or `HashedKeysClause` **you need first to query your model and then subscribe to those using entityIds**.
This example subscribes to `item` model updates in the `world` namespace, filtering for swords with durability 5.
The callback triggers on matching item changes.

Key points:

- Namespace: `world`, Model: `item`
- Conditions: type "sword", durability 5
- Uses `$is` for exact matching

```typescript
const [initialEntities, subscription] = await sdk.subscribeEntities({
    query: new ToriiQueryBuilder()
        .withClause(
            AndComposeClause([
                MemberClause(
                    "world-item",
                    "type",
                    "Eq",
                    "sword"
                ),
                MemberClause(
                    "world-item",
                    "durability",
                    "Eq",
                    5
                ),
            ])
            .build()
        )
        .includeHashedKeys(),
    callback:  ({ data, error}) => {
        if (data) {
            console.log("Updated entities:", data);
        }
        if (error) {
            console.error("Subscription error:", error);
        }
    }
});
```

sdk first query entities and then use entityIds for subscription so you only have to care about what you original query was.

### Sending Signed Messages

**NOTE**: If you want messages to be actually sent and broadcasted to all of your torii client instance,
you'll have to properly set `relayUrl` in the `init` function.
`relayUrl` is a _multiaddr_ format which looks like something like this when deployed on slot: `/dns4/api.cartridge.gg/tcp/443/x-parity-wss/%2Fx%2Fyour-slot-deployment-name%2Ftorii%2Fwss`

```typescript
// onchain_dash-Message is a composition of the ${namespace}-${Model} type you want to sign.
// Here we take example of a chat because we don't want to load up those messages onchain
// But keep in mind this could be any models defined in your cairo code
const msg = sdk.generateTypedData("onchain_dash-Message", {
    identity: account?.address,
    content: toValidAscii(data.message),
    timestamp: Date.now(),
});

try {
    const signature = await account.signMessage(msg);

    try {
        await sdk.client.publishMessage({
            message: JSON.stringify(msg),
            signature: Array.isArray(signature)
                ? signature
                : [signature.r.toString(), signature.s.toString()]
        });
        reset();
    } catch (error) {
        console.error("failed to publish message:", error);
    }
} catch (error) {
    console.error("failed to sign message:", error);
}
```

### Using With Zustand

The SDK integrates with Zustand for reactive state management.
See example [here](https://github.com/dojoengine/dojo.js/tree/main/examples/example-vite-react-sdk).

#### React Provider Setup

```typescript
import { DojoSdkProvider } from "@dojoengine/sdk/react";
import { setupWorld } from "../generated/typescript/contracts.gen";
import { dojoConfig } from "../your-dojo-config-path/dojoConfig.ts";

const sdk = await init<SchemaType>({
    client: {
        toriiUrl: dojoConfig.toriiUrl,
        relayUrl: dojoConfig.relayUrl,
        worldAddress: dojoConfig.manifest.world.address,
    },
    domain: {
        name: "Example",
        version: "1.0",
        chainId: "your-chain-id",
        revision: "1",
    },
});

<DojoSdkProvider
    sdk={sdk}
    dojoConfig={dojoConfig}
    clientFn={setupWorld}
>
    <App />
</DojoSdkProvider>

...

// Using in your app
const state = useDojoStore((state) => state);
const entities = useDojoStore((state) => state.entities);

...

// Fetching entities from torii and binding them into dojo store directly
useEntityQuery(
    new ToriiQueryBuilder()
        .withClause(
            MemberClause("world-Item", "durability", "Eq", 2).build()
        )
        .includeHashedKeys()
);

// Get all models from the store
const models = useModels("world-Item")

// Get a single model from the store
// entityId = values of your model's keys
// Here Item key = 1
const entityId = useEntityId(1);
const model = useModel(entityId, "world-Item")
```

#### State Management Migration (v1.6+)

Starting from v1.6, state management has been reorganized:

- **New path (recommended)**: `@dojoengine/state/zustand`
- **Old path**: `@dojoengine/sdk/state` (still works via re-exports)

#### Zustand Vanilla Store

You can also use a vanilla store which can be imported:

```ts
// Recommended import path for v1.6+
import { createDojoStore } from "@dojoengine/state/zustand";

// Or use the backward-compatible path
// import { createDojoStore } from "@dojoengine/sdk/state";

const store = createDojoStore<Schema>();

// Contrary to react, zustand vanilla store is not wrapped into a bound store.
// To use your store:
const state = store.getState();
const entities = state.getEntities();
```

### Optimistic Client Rendering

We use [immer](https://immerjs.github.io/immer/) for efficient optimistic rendering. This allows instant client-side entity state updates while awaiting blockchain confirmation.

The process:

1. Update entity state optimistically.
2. Wait for condition (e.g., a specific state change).
3. Resolve update, providing immediate user feedback.

This ensures a responsive user experience while maintaining blockchain data integrity.

See our [example project](https://github.com/dojoengine/dojo.js/tree/main/examples/example-vite-react-sdk) for a real-world implementation.

Note: You will need to have a subscription running in order for the update to resolve.


```typescript
import { useCallback } from "react";
import { v4 as uuidv4 } from "uuid";
import { useDojoSDK } from "@dojoengine/sdk/react";
import { useAccount } from "@starknet-react/core";
import { getEntityIdFromKeys } from "@dojoengine/utils";

export function useSystemCalls(entityId: string) {
    const { account } = useAccount();
    const { useDojoStore, client } = useDojoSDK();
    const state = useDojoStore((s) => s);

    const spawn = useCallback(async () => {
        if (!account) return;

        // Generate a unique transaction ID
        const transactionId = uuidv4();

        // The value to update the Moves model with
        const remainingMoves = 100;

        // Apply an optimistic update to the state
        // this uses immer drafts to update the state
        state.applyOptimisticUpdate(transactionId, (draft) => {
            if (
                draft.entities[entityId]?.models?.dojo_starter?.Moves
            ) {
                draft.entities[entityId].models.dojo_starter.Moves!.remaining =
                    remainingMoves;
            }
        });

        try {
            // Execute the spawn action
            await client.actions.spawn({ account });

            // Wait for the entity to be updated with the new state
            await state.waitForEntityChange(entityId, (entity) => {
                return (
                    entity?.models?.dojo_starter?.Moves?.remaining ===
                    remainingMoves
                );
            });
        } catch (error) {
            // Revert the optimistic update if an error occurs
            state.revertOptimisticUpdate(transactionId);
            console.error("Error executing spawn:", error);
            throw error;
        } finally {
            // Confirm the transaction if successful
            state.confirmTransaction(transactionId);
        }
    }, [account, client, entityId, state]);

    return {
        spawn,
    };
}
```
```

## Advanced Usage

Create complex 'And' with 'Or' statements to narrow in on what you want to fetch.

### Complex Queries

```typescript
const entities = await sdk.getEntities({
    query: new ToriiQueryBuilder()
        .withClause(
            new ClauseBuilder()
                .compose()
                .and([
                    new ClauseBuilder()
                        .compose()
                        .and([
                            new ClauseBuilder().where(
                                "world-player",
                                "score",
                                "Gt",
                                100
                            ),
                            new ClauseBuilder()
                                .compose()
                                .or([
                                    new ClauseBuilder().where(
                                        "world-player",
                                        "name",
                                        "Eq",
                                        "Bob"
                                    ),
                                    new ClauseBuilder().where(
                                        "world-player",
                                        "name",
                                        "Eq",
                                        "Alice"
                                    ),
                                ]),
                        ]),
                    new ClauseBuilder().where(
                        "world-item",
                        "durability",
                        "Lt",
                        50
                    ),
                ])
                .build()
        ),
});

// OR (but only if you're a lazy ninja)
const entities = await sdk.getEntities({
    query: new ToriiQueryBuilder()
        .withClause(
            AndComposeClause([
                AndComposeClause([
                    MemberClause("world-player", "score", "Gt", 100),
                    OrComposeClause([
                        MemberClause("world-player", "name", "Eq", "Bob"),
                        MemberClause("world-player", "name", "Eq", "Alice"),
                    ]),
                ]),
                MemberClause("world-item", "durability", "Lt", 50),
            ]).build()
        )
        .build()
});
```
